@page "/projects/{Id}"
@page "/projects/{Id}/branches"
@page "/projects/{Id}/agents"
@page "/projects/{Id}/prompts"
@page "/projects/{Id}/settings"
@implements IDisposable
@implements IAsyncDisposable
@using Fleece.Core.Models
@using Homespun.Shared.Hubs
@using Homespun.Shared.Models.Notifications
@using Homespun.Shared.Models.PullRequests
@using Homespun.Shared.Requests
@using Microsoft.AspNetCore.SignalR.Client
@using Homespun.Client.Services
@inject HttpProjectApiService ProjectApi
@inject HttpPullRequestApiService PullRequestApi
@inject HttpIssueApiService IssueApi
@inject HttpFleeceSyncApiService FleeceSyncApi
@inject HttpGitHubInfoApiService GitHubInfoApi
@inject HttpCloneApiService CloneApi
@inject HttpSessionApiService SessionApi
@inject IAgentStartupTracker StartupTracker
@inject IBreadcrumbService BreadcrumbService
@inject HttpNotificationApiService NotificationApi
@inject ILogger<ProjectDetail> Logger
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IKeyboardNavigationService NavService

<PageTitle>@(_project?.Name ?? "Project")</PageTitle>

<div class="project-detail-page" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="ShouldPreventKeyDefault" tabindex="-1" @ref="_pageContainer">
@if (_project == null)
{
    <p>Loading...</p>
}
else
{
    <div class="flex justify-between items-center mb-3">
        <h1>@_project.Name</h1>
        <div class="flex items-center gap-2">
            <SplitButton PrimaryText="Pull"
                         PrimaryOnClick="PullAsync"
                         ButtonCssClass="btn-outline btn-sm"
                         Actions="@_syncActions">
                <PrimaryIcon>
                    <i class="bi bi-cloud-arrow-down me-1"></i>
                </PrimaryIcon>
            </SplitButton>
            <a href="projects/@Id/edit" class="btn btn-outline btn-sm">Edit Project</a>
        </div>
    </div>

    @* Tab Navigation *@
    <ul class="nav nav-tabs mb-3">
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "issues" ? "active" : "")"
               href="/projects/@Id"
               @onclick="SwitchToIssuesTab"
               @onclick:preventDefault>
                <i class="bi bi-kanban me-1"></i>Issues
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "branches" ? "active" : "")"
               href="/projects/@Id/branches"
               @onclick="SwitchToBranchesTab"
               @onclick:preventDefault>
                <i class="bi bi-diagram-2 me-1"></i>Branches
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "agents" ? "active" : "")"
               href="/projects/@Id/agents"
               @onclick="SwitchToAgentsTab"
               @onclick:preventDefault>
                <i class="bi bi-cpu me-1"></i>Agents
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "prompts" ? "active" : "")"
               href="/projects/@Id/prompts"
               @onclick="SwitchToPromptsTab"
               @onclick:preventDefault>
                <i class="bi bi-chat-square-text me-1"></i>Prompts
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "settings" ? "active" : "")"
               href="/projects/@Id/settings"
               @onclick="SwitchToSettingsTab"
               @onclick:preventDefault>
                <i class="bi bi-gear me-1"></i>Settings
            </a>
        </li>
    </ul>

    @if (_activeTab == "issues")
    {
        <div class="project-layout">
            <div class="timeline-column">
                <TimelineVisualization
                    @ref="_graphVisualization"
                    ProjectId="@Id"
                    OnPullRequestClick="@SelectPullRequestByNumber"
                    OnIssueClick="@SelectIssue"
                    SelectedNodeId="@GetSelectedNodeId()" />
            </div>

        <div class="detail-column">
            @if (_selectedPullRequest != null)
            {
                <CurrentPullRequestDetailPanel PullRequest="_selectedPullRequest"
                                               OnActionCompleted="RefreshData"
                                               OnClose="ClearSelection"/>
            }
            else if (_selectedMergedPr != null)
            {
                <MergedPullRequestDetailPanel Details="_selectedMergedPr"
                                              ProjectId="@Id"
                                              OnClose="ClearSelection"/>
            }
            else if (_isLoadingMergedPr)
            {
                <div class="card">
                    <div class="card-body text-center">
                        <span class="spinner-border spinner-border-sm mr-2" role="status"></span>
                        Loading pull request details...
                    </div>
                </div>
            }
            else if (_selectedIssue != null)
            {
                <IssueDetailPanel ProjectId="@Id"
                                  Issue="_selectedIssue"
                                  OnActionCompleted="RefreshData"
                                  OnClose="ClearSelection"/>
            }
            @* No item selected - show nothing *@
        </div>
    </div>

        <QuickIssueCreateBar ProjectId="@Id"
                             LocalPath="@_project.LocalPath"
                             OnIssueCreated="RefreshData"
                             OnIssueCreatedForEdit="NavigateToIssueEdit"/>
    }
    else if (_activeTab == "branches")
    {
        <CloneManagementPanel Project="@_project"
                                 OnDataChanged="RefreshData" />
    }
    else if (_activeTab == "agents")
    {
        <AgentWorkersPanel ProjectId="@Id" OnDataChanged="RefreshData" />
    }
    else if (_activeTab == "prompts")
    {
        <ProjectPromptsTab ProjectId="@Id" />
    }
    else if (_activeTab == "settings")
    {
        <div class="settings-tab-content">
            <div class="card mb-3">
                <div class="card-header">Project Information</div>
                <div class="card-body">
                    <dl class="info-list">
                        <dt>Local Path</dt>
                        <dd><code>@_project.LocalPath</code></dd>
                        <dt>Default Branch</dt>
                        <dd>@_project.DefaultBranch</dd>
                        @if (!string.IsNullOrEmpty(_project.GitHubOwner) && !string.IsNullOrEmpty(_project.GitHubRepo))
                        {
                            <dt>GitHub Repository</dt>
                            <dd>
                                <a href="https://github.com/@_project.GitHubOwner/@_project.GitHubRepo"
                                   target="_blank">
                                    @_project.GitHubOwner/@_project.GitHubRepo
                                </a>
                            </dd>
                        }
                    </dl>
                </div>
            </div>

            @if (IsDebugBuild)
            {
                <div class="card">
                    <div class="card-header">Debug Tools</div>
                    <div class="card-body">
                        <div class="flex flex-col gap-2">
                            <AsyncActionButton OnClick="StartTestAgentAsync"
                                               IsLoadingExternal="_isStartingTestAgent"
                                               CssClass="btn-outline-primary btn-sm"
                                               Text="Start Test Agent"
                                               LoadingText="Starting..." />
                            @if (!string.IsNullOrEmpty(_testAgentError))
                            {
                                <div class="alert alert-danger py-1 px-2 mb-0 text-sm">
                                    @_testAgentError
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    }

    @* Fleece Sync Conflict Modal *@
    <Modal IsOpen="@_showFleeceConflictModal"
           OnClose="@HideFleeceConflictModal"
           Title="Sync Conflict"
           Centered="true">
        <Body>
            <div class="alert alert-warning">
                <strong>Unable to pull changes from @_project?.DefaultBranch</strong>
            </div>
            <p class="small text-muted">@_fleecePullConflict?.ErrorMessage</p>
            <p>Choose how to resolve this conflict:</p>
        </Body>
        <Footer>
            <button type="button" class="btn btn-secondary" @onclick="HideFleeceConflictModal">Cancel</button>
            <AsyncActionButton OnClick="HandleFleeceConflictStash"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-warning"
                               Text="Stash Changes" />
            <AsyncActionButton OnClick="HandleFleeceConflictDiscard"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-danger"
                               Text="Discard All Changes" />
        </Footer>
    </Modal>

    @* Non-Fleece Changes Modal *@
    <Modal IsOpen="@_showNonFleeceChangesModal"
           OnClose="@HideNonFleeceChangesModal"
           Title="Non-Fleece Changes Detected"
           Size="ModalSize.Lg"
           Centered="true">
        <Body>
            <div class="alert alert-warning">
                <strong>Your local branch is behind the remote</strong>
            </div>
            <p>
                The sync cannot complete because your local branch needs to pull changes from the remote,
                but you have uncommitted changes outside the <code>.fleece/</code> folder that may cause conflicts.
            </p>
            @if (_nonFleeceChangedFiles != null && _nonFleeceChangedFiles.Count > 0)
            {
                <p><strong>Changed files outside .fleece/:</strong></p>
                <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                    <ul class="mb-0 small">
                        @foreach (var file in _nonFleeceChangedFiles)
                        {
                            <li><code>@file</code></li>
                        }
                    </ul>
                </div>
            }
            <p class="mt-3 text-muted small">
                You can discard these non-fleece changes to allow the sync to complete.
                Your <code>.fleece/</code> changes will be preserved.
            </p>
        </Body>
        <Footer>
            <button type="button" class="btn btn-secondary" @onclick="HideNonFleeceChangesModal">Cancel</button>
            <AsyncActionButton OnClick="HandleDiscardNonFleeceChanges"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-danger"
                               Text="Discard Non-Fleece Changes" />
        </Footer>
    </Modal>
}
</div>

<style>
    .project-detail-page {
        outline: none;
    }
    /* ==========================================================================
       Project Layout Grid
       ========================================================================== */
    .project-layout {
        display: grid;
        grid-template-columns: 1fr 300px;
        gap: var(--spacing-md);
        align-items: start;
        padding-bottom: 70px; /* Space for fixed quick-issue-bar */
    }

    @@media (max-width: 900px) {
        .project-layout {
            grid-template-columns: 1fr;
        }

        .detail-column {
            order: -1;
        }
    }

    .timeline-column {
        min-width: 0;
    }

    .detail-column {
        position: sticky;
        top: var(--spacing-md);
    }

    /* ==========================================================================
       Settings Tab
       ========================================================================== */
    .settings-tab-content {
        max-width: 800px;
    }
</style>

@code {
    [Parameter] public string Id { get; set; } = "";

    private Project? _project;
    private List<PullRequest>? _rootPullRequests;
    private List<FlattenedPR> _flattenedCurrentPRs = [];
    private PullRequest? _selectedPullRequest;
    private string? _selectedPullRequestId;
    private MergedPullRequestDetails? _selectedMergedPr;
    private bool _isLoadingMergedPr;
    private IssueResponse? _selectedIssue;
    private string? _selectedIssueId;
    private bool _isSyncingPRs;
    private bool _tokenMissing;
    private string? _syncError;
    private SyncResult? _lastSyncResult;
    private List<IssueResponse>? _openIssues;
    private List<IssueResponse>? _inProgressIssues;
    private TimelineVisualization? _graphVisualization;
    private HubConnection? _hubConnection;
    private bool _isRefreshing;
    private bool _isSyncing;

    // Tab navigation state
    private string _activeTab = "issues";

    // Track Id changes for same-component navigation
    private string? _previousId;

    // Keyboard navigation state
    private ElementReference _pageContainer;

    // Prevent default for keyboard shortcuts when on issues tab and not editing in a text field
    // This is computed based on current state so that navigation keys are prevented
    private bool ShouldPreventKeyDefault =>
        _activeTab == "issues" && NavService.EditMode == KeyboardEditMode.Viewing;

    protected override async Task OnParametersSetAsync()
    {
        if (_previousId != null && _previousId != Id)
        {
            // Id parameter changed â€” navigated to a different project
            // Dispose old SignalR connection
            if (_hubConnection != null)
            {
                await _hubConnection.DisposeAsync();
                _hubConnection = null;
            }

            // Reset all state
            _selectedPullRequest = null;
            _selectedPullRequestId = null;
            _selectedMergedPr = null;
            _isLoadingMergedPr = false;
            _selectedIssue = null;
            _selectedIssueId = null;
            _lastSyncResult = null;
            _syncError = null;
            _activeTab = "issues";

            // Determine tab from URL
            var uri = NavigationManager.Uri;
            if (uri.Contains("/settings")) _activeTab = "settings";
            else if (uri.Contains("/prompts")) _activeTab = "prompts";
            else if (uri.Contains("/agents")) _activeTab = "agents";
            else if (uri.Contains("/branches")) _activeTab = "branches";

            // Reload data for the new project
            await LoadData();
            await SetupSignalRConnection();

            if (_project != null)
            {
                _ = Task.Run(async () =>
                {
                    await InvokeAsync(async () =>
                    {
                        await SyncPullRequestsAsync();
                    });
                });
            }
        }
        _previousId = Id;
    }

    // IsDebugBuild property for conditional rendering
#if DEBUG
    private static bool IsDebugBuild => true;
    // Test agent state
    private bool _isStartingTestAgent;
    private string? _testAgentError;
    private const string TestAgentEntityId = "test-agent";
    private const string TestBranchName = "hsp/test";
#else
    private static bool IsDebugBuild => false;
    // Stubs for Release build (never used since IsDebugBuild is false)
    private bool _isStartingTestAgent => false;
    private string? _testAgentError => null;
    private Task StartTestAgentAsync() => Task.CompletedTask;
#endif

    // Fleece sync state
    private bool _isSyncingFleece;
    private string? _fleeceSyncError;
    private FleeceIssueSyncResult? _lastFleeceSyncResult;
    private bool _showFleeceConflictModal;
    private PullResult? _fleecePullConflict;
    private bool _showNonFleeceChangesModal;
    private IReadOnlyList<string>? _nonFleeceChangedFiles;

    // Split button sync actions
    private IReadOnlyList<SplitButtonAction> _syncActions = [];

    private void InitializeSyncActions()
    {
        _syncActions =
        [
            new SplitButtonAction(
                Key: "sync",
                Text: "Sync",
                Icon: (RenderFragment)(builder =>
                {
                    builder.OpenElement(0, "i");
                    builder.AddAttribute(1, "class", "bi bi-cloud-arrow-up");
                    builder.CloseElement();
                }),
                OnClick: EventCallback.Factory.Create(this, SyncAllAsync))
        ];
    }

    private record FlattenedPR(PullRequest PullRequest, int Level);

    protected override async Task OnInitializedAsync()
    {
        // Initialize sync actions for split button
        InitializeSyncActions();

        // Determine active tab from URL
        var uri = NavigationManager.Uri;
        if (uri.Contains("/settings"))
            _activeTab = "settings";
        else if (uri.Contains("/prompts"))
            _activeTab = "prompts";
        else if (uri.Contains("/agents"))
            _activeTab = "agents";
        else if (uri.Contains("/branches"))
            _activeTab = "branches";
        else
            _activeTab = "issues";

        // Subscribe to agent startup state changes to update UI
        StartupTracker.OnStateChanged += OnStartupStateChanged;

        await LoadData();
        await SetupSignalRConnection();

        // Start sync after project is loaded
        // Using Task.Run to not block the initial render
        if (_project != null)
        {
            _ = Task.Run(async () =>
            {
                await InvokeAsync(async () =>
                {
                    await SyncPullRequestsAsync();
                });
            });
        }
    }

    // Track if we've already processed the hash fragment
    private bool _hasProcessedHashFragment;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleHashFragmentAsync();
        }
    }

    private async Task HandleHashFragmentAsync()
    {
        if (_hasProcessedHashFragment) return;
        _hasProcessedHashFragment = true;

        var uri = new Uri(NavigationManager.Uri);
        if (!string.IsNullOrEmpty(uri.Fragment))
        {
            var fragment = uri.Fragment.TrimStart('#');
            if (fragment.StartsWith("issue-"))
            {
                var issueId = fragment.Substring(6);

                // Wait a brief moment for issues to be loaded if needed
                var retries = 0;
                while ((_openIssues == null || _openIssues.Count == 0) && retries < 10)
                {
                    await Task.Delay(100);
                    retries++;
                }

                if (_openIssues?.Any(i => i.Id == issueId) == true)
                {
                    SelectIssue(issueId);
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
    }

    private void SwitchTab(string tab)
    {
        if (_activeTab == tab) return;

        _activeTab = tab;
        ClearSelection();

        // Update the URL without causing a full navigation
        var newUrl = tab switch
        {
            "branches" => $"/projects/{Id}/branches",
            "agents" => $"/projects/{Id}/agents",
            "prompts" => $"/projects/{Id}/prompts",
            "settings" => $"/projects/{Id}/settings",
            _ => $"/projects/{Id}"
        };
        NavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
    }

    private void SwitchToIssuesTab() => SwitchTab("issues");
    private void SwitchToBranchesTab() => SwitchTab("branches");
    private void SwitchToAgentsTab() => SwitchTab("agents");
    private void SwitchToPromptsTab() => SwitchTab("prompts");
    private void SwitchToSettingsTab() => SwitchTab("settings");

    public void Dispose()
    {
        StartupTracker.OnStateChanged -= OnStartupStateChanged;
    }

    public async ValueTask DisposeAsync()
    {
        Dispose();
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private async void OnStartupStateChanged(string entityId, AgentStartupState state)
    {
        // Re-render when any startup state changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task SetupSignalRConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri(HubConstants.NotificationHub))
                .Build();

            // Listen for pull request sync events
            _hubConnection.On<string, SyncResult>("PullRequestsSynced", async (projectId, syncResult) =>
            {
                // Only refresh if this event is for our project
                if (projectId == Id)
                {
                    Logger.LogInformation("Received PullRequestsSynced event for project {ProjectId}", projectId);
                    _lastSyncResult = syncResult;
                    await InvokeAsync(async () =>
                    {
                        await RefreshData();
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection established for project {ProjectId}", Id);
        }
        catch (Exception ex)
        {
            // SignalR connection can fail when accessing via external hostname that the container can't resolve.
            // This is expected - real-time updates won't work but the page will still function.
            Logger.LogWarning("SignalR connection failed (real-time updates unavailable): {Message}", ex.Message);
        }
    }

    private async Task LoadData()
    {
        _project = await ProjectApi.GetProjectAsync(Id);
        if (_project != null)
        {
            // Set breadcrumb context with project info
            await BreadcrumbService.SetContextAsync(new BreadcrumbContext { ProjectId = Id });

            _rootPullRequests = await PullRequestApi.GetProjectPullRequestsAsync(Id);
            _flattenedCurrentPRs = FlattenPRs(_rootPullRequests ?? []);

            try
            {
                // Load all issues from Fleece
                var allIssues = await IssueApi.GetIssuesAsync(_project.Id);

                // Get open issues (all non-completed statuses)
                _openIssues = allIssues
                    .Where(i => i.Status is IssueStatus.Open or IssueStatus.Progress or IssueStatus.Review)
                    .ToList();

                // In-progress issues could be tracked separately if needed
                _inProgressIssues = [];
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load issues for project {ProjectId}", Id);
                _openIssues = [];
                _inProgressIssues = [];
            }
        }
    }

    private List<FlattenedPR> FlattenPRs(List<PullRequest> prs, int level = 0)
    {
        var result = new List<FlattenedPR>();
        foreach (var pr in prs.OrderBy(p => p.CreatedAt))
        {
            result.Add(new FlattenedPR(pr, level));
            if (pr.Children.Any())
            {
                result.AddRange(FlattenPRs(pr.Children.ToList(), level + 1));
            }
        }

        return result;
    }

    private async Task SyncPullRequestsAsync()
    {
        if (_project == null || _isSyncingPRs)
            return;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return;

        var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
        if (!isConfigured)
        {
            _tokenMissing = true;
            Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
            StateHasChanged();
            return;
        }

        _isSyncingPRs = true;
        _tokenMissing = false;
        _syncError = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting automatic PR sync for project {ProjectId} ({Owner}/{Repo})",
                _project.Id, _project.GitHubOwner, _project.GitHubRepo);

            _lastSyncResult = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (_lastSyncResult.Errors.Count > 0)
            {
                _syncError = string.Join("; ", _lastSyncResult.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, _syncError);
            }
            else
            {
                Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                    _project.Id, _lastSyncResult.Imported, _lastSyncResult.Updated, _lastSyncResult.Removed);
            }

            await LoadData();
        }
        catch (Exception ex)
        {
            _syncError = ex.Message;
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingPRs = false;
            StateHasChanged();
        }
    }

    private async Task RefreshData()
    {
        if (_isRefreshing) return;

        _isRefreshing = true;
        StateHasChanged();

        try
        {
            await LoadData();
            if (_selectedPullRequestId != null)
            {
                _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(_selectedPullRequestId);
            }
            await _graphVisualization?.RefreshAsync()!;
        }
        finally
        {
            _isRefreshing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Pull operation that fetches from remote and merges fleece issues without committing/pushing.
    /// Also syncs GitHub PRs.
    /// </summary>
    private async Task PullAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            // Run fleece pull and PR sync in parallel
            var fleecePullTask = PullFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleecePullTask, prSyncTask);

            // Collect errors
            if (results[0] is string fleeceError)
                errors.Add($"Fleece pull: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            // Show error notification if any errors occurred
            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Pull completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"pull-error-{_project.Id}"
                });
            }

            // Refresh data after both complete
            await LoadData();
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Internal fleece pull that returns an error message or null on success.
    /// </summary>
    private async Task<string?> PullFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.PullFleeceOnlyAsync(_project.Id);

            if (result != null && !result.Success)
            {
                // For conflicts requiring user interaction, show modal
                if (result.HasNonFleeceChanges)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null; // Don't report as error - handled via modal
                }

                return result.ErrorMessage ?? "Unknown fleece pull error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to pull fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    /// <summary>
    /// Combined sync operation that runs fleece sync and PR sync in parallel.
    /// </summary>
    private async Task SyncAllAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            // Run fleece sync and PR sync in parallel
            var fleeceSyncTask = SyncFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleeceSyncTask, prSyncTask);

            // Collect errors
            if (results[0] is string fleeceError)
                errors.Add($"Fleece sync: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            // Show error notification if any errors occurred
            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Sync completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"sync-error-{_project.Id}"
                });
            }

            // Refresh data after both complete
            await LoadData();
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Internal fleece sync that returns an error message or null on success.
    /// </summary>
    private async Task<string?> SyncFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.SyncAsync(_project.Id);

            if (result != null && !result.Success)
            {
                // For conflicts requiring user interaction, skip error reporting
                // (they'll be handled when user manually syncs via the button)
                if (result.HasNonFleeceChanges && result.RequiresPullFirst)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null; // Don't report as error - handled via modal
                }

                return result.ErrorMessage ?? "Unknown fleece sync error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    /// <summary>
    /// Internal PR sync that returns an error message or null on success.
    /// </summary>
    private async Task<string?> SyncPullRequestsInternalAsync()
    {
        if (_project == null)
            return null;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return null; // No GitHub config is not an error

        try
        {
            var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
            if (!isConfigured)
            {
                Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
                return null; // Token not configured - silently skip
            }

            var result = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (result.Errors.Count > 0)
            {
                var errorMessage = string.Join("; ", result.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, errorMessage);
                return errorMessage;
            }

            Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                _project.Id, result.Imported, result.Updated, result.Removed);

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    private async Task NavigateToIssueEdit(string issueId)
    {
        await RefreshData();
        // autoSuggest=true triggers background branch ID generation on the edit page
        NavigationManager.NavigateTo($"/projects/{Id}/issues/{issueId}/edit?autoSuggest=true");
    }

    private async Task SelectPullRequest(string pullRequestId)
    {
        // Clear any other selection
        _selectedIssueId = null;
        _selectedIssue = null;
        _selectedMergedPr = null;

        _selectedPullRequestId = pullRequestId;
        _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(pullRequestId);
    }

    private void SelectIssue(string issueId)
    {
        // Clear any pull request selection
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedMergedPr = null;

        _selectedIssueId = issueId;
        _selectedIssue = _openIssues?.FirstOrDefault(i => i.Id == issueId)
                         ?? _inProgressIssues?.FirstOrDefault(i => i.Id == issueId);
    }

    private async Task SelectPullRequestByNumber(int prNumber)
    {
        // Clear any existing selection
        _selectedIssueId = null;
        _selectedIssue = null;
        _selectedMergedPr = null;

        // Find the PR in current PRs (internal database)
        var currentPr = _flattenedCurrentPRs.FirstOrDefault(p => p.PullRequest.GitHubPRNumber == prNumber);
        if (currentPr != null)
        {
            _selectedPullRequestId = currentPr.PullRequest.Id;
            _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(currentPr.PullRequest.Id);
            return;
        }

        // Not in current PRs - try to fetch as merged/closed PR
        _selectedPullRequestId = null;
        _selectedPullRequest = null;

        // Show loading state and fetch merged PR details
        _isLoadingMergedPr = true;
        StateHasChanged();

        try
        {
            _selectedMergedPr = await PullRequestApi.GetMergedPullRequestDetailsAsync(Id, prNumber);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to fetch merged PR #{PrNumber} details", prNumber);
            _selectedMergedPr = null;
        }
        finally
        {
            _isLoadingMergedPr = false;
        }
    }

    private string? GetSelectedNodeId()
    {
        if (_selectedPullRequest != null && _selectedPullRequest.GitHubPRNumber.HasValue)
        {
            return $"pr-{_selectedPullRequest.GitHubPRNumber}";
        }

        if (_selectedMergedPr != null)
        {
            return $"pr-{_selectedMergedPr.PullRequest.Number}";
        }

        if (_selectedIssueId != null)
        {
            return $"issue-{_selectedIssueId}";
        }

        return null;
    }

    private void ClearSelection()
    {
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedMergedPr = null;
        _selectedIssueId = null;
        _selectedIssue = null;
    }

    private int GetTotalCurrentPRCount()
    {
        return _flattenedCurrentPRs.Count;
    }

    private int GetTotalCurrentCount()
    {
        return _flattenedCurrentPRs.Count + (_inProgressIssues?.Count ?? 0);
    }

    private static string GetCurrentPRStatusColor(OpenPullRequestStatus status) => status switch
    {
        OpenPullRequestStatus.InDevelopment => "status-in-development",
        OpenPullRequestStatus.ReadyForReview => "status-ready-for-review",
        OpenPullRequestStatus.HasReviewComments => "status-has-review-comments",
        OpenPullRequestStatus.Approved => "status-approved",
        _ => "status-default"
    };

    private static string GetIssueTypeStatusColor(IssueType type) => type switch
    {
        IssueType.Feature => "status-feature",
        IssueType.Bug => "status-bug",
        IssueType.Chore => "status-chore",
        IssueType.Task => "status-task",
        _ => "status-default"
    };

    private static string GetIssueStatusColor(IssueResponse issue)
    {
        if (issue.Status == IssueStatus.Closed || issue.Status == IssueStatus.Complete)
            return "status-approved";
        return GetIssueTypeStatusColor(issue.Type);
    }

    private static string GetIssueStatusTooltip(IssueResponse issue)
    {
        return $"{issue.Type} ({issue.Status})";
    }

    private static string? GetCurrentPRSubtitle(PullRequest pr)
    {
        var parts = new List<string>();

        if (!string.IsNullOrEmpty(pr.BranchName))
            parts.Add(pr.BranchName);

        return parts.Count > 0 ? string.Join(" - ", parts) : null;
    }

    private static string? GetIssueSubtitle(IssueResponse issue)
    {
        if (!string.IsNullOrEmpty(issue.Description))
        {
            // Truncate description for subtitle display
            var desc = issue.Description;
            if (desc.Length > 60)
                desc = desc[..57] + "...";
            return desc;
        }

        return null;
    }

    private AgentStartupStatus? GetStartupState(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.Status;
    }

    private string? GetStartupErrorMessage(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.ErrorMessage;
    }

#if DEBUG
    private async Task StartTestAgentAsync()
    {
        if (_project == null)
            return;

        _isStartingTestAgent = true;
        _testAgentError = null;
        StateHasChanged();

        try
        {
            // Clean up existing clone and branch if they exist
            // Try to remove the clone first (this handles the git clone tracking)
            try
            {
                var existingClones = await CloneApi.ListClonesAsync(Id);
                var testClone = existingClones.FirstOrDefault(c =>
                    c.Branch?.Replace("refs/heads/", "") == TestBranchName);
                if (testClone != null)
                {
                    await CloneApi.DeleteCloneAsync(Id, testClone.Path);
                }
            }
            catch (Exception ex2)
            {
                Logger.LogWarning(ex2, "Failed to clean up existing test clone, continuing...");
            }

            // TODO: Branch delete not available via HTTP API
            // await CommandRunner.RunAsync("git", $"branch -D \"{TestBranchName}\"", _project.LocalPath);

            // Prune any stale clone references
            await CloneApi.PruneClonesAsync(Id);

            // Create clone for hsp/test branch
            var createResult = await CloneApi.CreateCloneAsync(new CreateCloneRequest
            {
                ProjectId = Id,
                BranchName = TestBranchName,
                CreateBranch = true,
                BaseBranch = _project.DefaultBranch
            });
            var clonePath = createResult?.Path;

            if (string.IsNullOrEmpty(clonePath))
            {
                _testAgentError = "Failed to create clone for test branch.";
                return;
            }

            Logger.LogInformation("Created test clone at {ClonePath}", clonePath);

            // Start the agent session without a system prompt
            StartupTracker.MarkAsStarting(TestAgentEntityId);

            var session = await SessionApi.StartSessionAsync(
                TestAgentEntityId,
                Id,
                clonePath,
                SessionMode.Build,
                "sonnet",
                systemPrompt: null);

            StartupTracker.MarkAsStarted(TestAgentEntityId);

            Logger.LogInformation("Started test agent session {SessionId}", session.Id);

            // Send the task instruction as the initial message
            // This way the full instruction is visible in the chat
            var timestamp = DateTime.UtcNow.ToString("O");
            var taskMessage = $"""
                Create a file named `test.txt` in the current directory containing the following timestamp: {timestamp}

                After creating the file, confirm that it was created successfully.
                """;
            await SessionApi.SendMessageAsync(session.Id, taskMessage);

            // Agent started - user stays on current page and can monitor via status indicator
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start test agent");
            StartupTracker.MarkAsFailed(TestAgentEntityId, ex.Message);
            _testAgentError = $"Failed to start test agent: {ex.Message}";
        }
        finally
        {
            _isStartingTestAgent = false;
            StateHasChanged();
        }
    }
#endif

    private async Task SyncFleeceIssuesAsync()
    {
        if (_project == null || _isSyncingFleece)
            return;

        _isSyncingFleece = true;
        _fleeceSyncError = null;
        _nonFleeceChangedFiles = null;
        StateHasChanged();

        try
        {
            // In WASM mode, the server handles the full sync workflow
            // (commit, push, pull, conflict resolution) via a single endpoint
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                // Check if sync failed due to non-fleece changes blocking a required pull
                if (_lastFleeceSyncResult.HasNonFleeceChanges && _lastFleeceSyncResult.RequiresPullFirst)
                {
                    _nonFleeceChangedFiles = _lastFleeceSyncResult.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return;
                }

                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        catch (Exception ex)
        {
            _fleeceSyncError = ex.Message;
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private void HideFleeceConflictModal()
    {
        _showFleeceConflictModal = false;
        _fleecePullConflict = null;
    }

    private void HideNonFleeceChangesModal()
    {
        _showNonFleeceChangesModal = false;
        _nonFleeceChangedFiles = null;
    }

    private async Task HandleDiscardNonFleeceChanges()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideNonFleeceChangesModal();

            // Retry the sync - server handles conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictStash()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            // Retry sync - server handles stash/pull/conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictDiscard()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            // Retry sync - server handles discard/pull/conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        // Only handle keyboard shortcuts on the issues tab
        if (_activeTab != "issues") return;

        // Don't handle if in edit mode - let the inline editor handle it
        if (NavService.EditMode != KeyboardEditMode.Viewing)
        {
            // Handle Escape to cancel edit
            if (e.Key == "Escape")
            {
                NavService.CancelEdit();
            }
            return;
        }

        // Handle navigation and edit commands
        // Note: preventDefault is handled by ShouldPreventKeyDefault property
        switch (e.Key)
        {
            case "j":
            case "ArrowDown":
                NavService.MoveDown();
                break;
            case "k":
            case "ArrowUp":
                NavService.MoveUp();
                break;
            case "h":
            case "ArrowLeft":
                NavService.MoveToChild();
                break;
            case "l":
            case "ArrowRight":
                NavService.MoveToParent();
                break;
            case "i":
                NavService.StartEditingAtStart();
                break;
            case "a":
                NavService.StartEditingAtEnd();
                break;
            case "r":
                NavService.StartReplacingTitle();
                break;
            case "o":
                if (e.ShiftKey)
                    NavService.CreateIssueAbove();
                else
                    NavService.CreateIssueBelow();
                break;
            case "O":
                NavService.CreateIssueAbove();
                break;
            case "Escape":
                // Clear selection or close sidebar panel
                ClearSelection();
                break;
        }
    }

}
