@page "/projects/{Id}"
@page "/projects/{Id}/branches"
@page "/projects/{Id}/agents"
@page "/projects/{Id}/prompts"
@page "/projects/{Id}/secrets"
@page "/projects/{Id}/settings"
@implements IDisposable
@implements IAsyncDisposable
@using Fleece.Core.Models
@using Homespun.Shared.Hubs
@using Homespun.Shared.Models.Notifications
@using Homespun.Shared.Models.PullRequests
@using Homespun.Shared.Models.Sessions
@using Homespun.Shared.Requests
@using Homespun.Shared.Models.Fleece
@using Microsoft.AspNetCore.SignalR.Client
@using Homespun.Client.Services
@inject HttpProjectApiService ProjectApi
@inject HttpPullRequestApiService PullRequestApi
@inject HttpIssueApiService IssueApi
@inject HttpIssueHistoryApiService IssueHistoryApi
@inject HttpFleeceSyncApiService FleeceSyncApi
@inject HttpGitHubInfoApiService GitHubInfoApi
@inject HttpCloneApiService CloneApi
@inject HttpSessionApiService SessionApi
@inject IAgentStartupTracker StartupTracker
@inject IBreadcrumbService BreadcrumbService
@inject HttpNotificationApiService NotificationApi
@inject ILogger<ProjectDetail> Logger
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IKeyboardNavigationService NavService
@inject IPanelService PanelService

<PageTitle>@(_project?.Name ?? "Project")</PageTitle>

<div class="project-detail-page @(_sidebarOpen ? "sidebar-open" : "")" @onkeydown="HandleKeyDown" tabindex="-1" @ref="_pageContainer">
@if (_project == null)
{
    <p>Loading...</p>
}
else
{
    <div class="project-sticky-header">
        <div class="flex justify-between items-center">
            <h1>@_project.Name</h1>
            <div class="flex items-center gap-2">
                <SplitButton PrimaryText="Pull"
                             PrimaryOnClick="PullAsync"
                             ButtonCssClass="btn-outline btn-sm"
                             Actions="@_syncActions">
                    <PrimaryIcon>
                        <i class="bi bi-cloud-arrow-down me-1"></i>
                    </PrimaryIcon>
                </SplitButton>
                <a href="projects/@Id/edit" class="btn btn-outline btn-sm">Edit Project</a>
            </div>
        </div>
        @if (_activeTab == "issues")
        {
            <ProjectToolbar SelectedIssueId="@NavService.SelectedIssueId"
                            ProjectId="@Id"
                            IsAgentRunning="@IsSelectedIssueAgentRunning()"
                            OnEditClick="HandleEditIssue"
                            OnRunAgentClick="HandleRunAgentOnIssue" />
        }
    </div>

    @* Tab Navigation *@
    <ul class="nav nav-tabs mb-3">
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "issues" ? "active" : "")"
               href="/projects/@Id"
               @onclick="SwitchToIssuesTab"
               @onclick:preventDefault>
                <i class="bi bi-kanban me-1"></i>Issues
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "branches" ? "active" : "")"
               href="/projects/@Id/branches"
               @onclick="SwitchToBranchesTab"
               @onclick:preventDefault>
                <i class="bi bi-diagram-2 me-1"></i>Branches
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "agents" ? "active" : "")"
               href="/projects/@Id/agents"
               @onclick="SwitchToAgentsTab"
               @onclick:preventDefault>
                <i class="bi bi-cpu me-1"></i>Agents
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "prompts" ? "active" : "")"
               href="/projects/@Id/prompts"
               @onclick="SwitchToPromptsTab"
               @onclick:preventDefault>
                <i class="bi bi-chat-square-text me-1"></i>Prompts
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "secrets" ? "active" : "")"
               href="/projects/@Id/secrets"
               @onclick="SwitchToSecretsTab"
               @onclick:preventDefault>
                <i class="bi bi-key me-1"></i>Secrets
            </a>
        </li>
        <li class="nav-item">
            <a class="nav-link @(_activeTab == "settings" ? "active" : "")"
               href="/projects/@Id/settings"
               @onclick="SwitchToSettingsTab"
               @onclick:preventDefault>
                <i class="bi bi-gear me-1"></i>Settings
            </a>
        </li>
    </ul>

    @if (_activeTab == "issues")
    {
        @* Issue Toolbar *@
        <div class="issue-toolbar mb-2">
            <div class="flex items-center gap-2">
                <button class="btn btn-outline btn-sm"
                        @onclick="HandleCreateAbove"
                        disabled="@(!CanCreateIssue())"
                        title="Create issue above (Shift+O)">
                    <i class="bi bi-arrow-bar-up" aria-hidden="true"></i>
                </button>
                <button class="btn btn-outline btn-sm"
                        @onclick="HandleCreateBelow"
                        disabled="@(!CanCreateIssue())"
                        title="Create issue below (O)">
                    <i class="bi bi-arrow-bar-down" aria-hidden="true"></i>
                </button>
                <button class="btn btn-outline btn-sm"
                        @onclick="UndoAsync"
                        disabled="@(!_canUndo || _isUndoRedoing)"
                        title="@(_historyState?.UndoDescription ?? "Undo")">
                    <i class="bi bi-arrow-counterclockwise" aria-hidden="true"></i>
                </button>
                <button class="btn btn-outline btn-sm"
                        @onclick="RedoAsync"
                        disabled="@(!_canRedo || _isUndoRedoing)"
                        title="@(_historyState?.RedoDescription ?? "Redo")">
                    <i class="bi bi-arrow-clockwise" aria-hidden="true"></i>
                </button>
                @if (_historyState != null && _historyState.TotalEntries > 0)
                {
                    <span class="text-muted text-sm">@_historyState.TotalEntries history entries</span>
                }
            </div>
        </div>

        <IssueControlPanel />

        <div class="project-layout">
            <div class="timeline-column">
                <SearchBar IsVisible="@NavService.IsSearching"
                           SearchTerm="@NavService.SearchTerm"
                           MatchCount="@NavService.MatchingIndices.Count"
                           CurrentMatchIndex="@NavService.CurrentMatchIndex"
                           OnSearchTermChanged="HandleSearchTermChanged"
                           OnEnter="HandleSearchEnter"
                           OnEscape="HandleSearchEscape" />
                <TimelineVisualization
                    @ref="_graphVisualization"
                    ProjectId="@Id"
                    OnPullRequestClick="@HandlePullRequestClickFromGraph"
                    OnIssueClick="@HandleIssueClickFromGraph"
                    OnIssueCreated="@HandleInlineIssueCreated"
                    OnEditClick="@HandleEditIssue"
                    OnRunAgentClick="@HandleRunAgentOnIssue"
                    OnOpenPanelClick="@HandleOpenPanelFromGraph"
                    SelectedNodeId="@GetSelectedNodeId()"
                    ActiveSearchTerm="@GetActiveSearchTerm()" />
            </div>
        </div>

        @* Collapsible Detail Sidebar *@
        <div class="detail-sidebar @(_sidebarOpen ? "open" : "")">
            @if (_selectedPullRequest != null)
            {
                <CurrentPullRequestDetailPanel PullRequest="_selectedPullRequest"
                                               OnActionCompleted="RefreshData"
                                               OnClose="CloseSidebar"/>
            }
            else if (_selectedMergedPr != null)
            {
                <MergedPullRequestDetailPanel Details="_selectedMergedPr"
                                              ProjectId="@Id"
                                              OnClose="CloseSidebar"/>
            }
            else if (_isLoadingMergedPr)
            {
                <div class="card">
                    <div class="card-body text-center">
                        <span class="spinner-border spinner-border-sm mr-2" role="status"></span>
                        Loading pull request details...
                    </div>
                </div>
            }
            else if (_selectedIssue != null)
            {
                <IssueDetailPanel ProjectId="@Id"
                                  Issue="_selectedIssue"
                                  OnActionCompleted="RefreshData"
                                  OnClose="CloseSidebar"/>
            }
        </div>

    }
    else if (_activeTab == "branches")
    {
        <CloneManagementPanel Project="@_project"
                                 OnDataChanged="RefreshData" />
    }
    else if (_activeTab == "agents")
    {
        <SessionsPanel ProjectId="@Id" OnSessionStopped="RefreshData" />
    }
    else if (_activeTab == "prompts")
    {
        <ProjectPromptsTab ProjectId="@Id" />
    }
    else if (_activeTab == "secrets")
    {
        <ProjectSecretsTab ProjectId="@Id" />
    }
    else if (_activeTab == "settings")
    {
        <div class="settings-tab-content">
            <div class="card mb-3">
                <div class="card-header">Project Information</div>
                <div class="card-body">
                    <dl class="info-list">
                        <dt>Local Path</dt>
                        <dd><code>@_project.LocalPath</code></dd>
                        <dt>Default Branch</dt>
                        <dd>@_project.DefaultBranch</dd>
                        @if (!string.IsNullOrEmpty(_project.GitHubOwner) && !string.IsNullOrEmpty(_project.GitHubRepo))
                        {
                            <dt>GitHub Repository</dt>
                            <dd>
                                <a href="https://github.com/@_project.GitHubOwner/@_project.GitHubRepo"
                                   target="_blank">
                                    @_project.GitHubOwner/@_project.GitHubRepo
                                </a>
                            </dd>
                        }
                    </dl>
                </div>
            </div>

            @if (IsDebugBuild)
            {
                <div class="card">
                    <div class="card-header">Debug Tools</div>
                    <div class="card-body">
                        <div class="flex flex-col gap-2">
                            <AsyncActionButton OnClick="StartTestAgentAsync"
                                               IsLoadingExternal="_isStartingTestAgent"
                                               CssClass="btn-outline-primary btn-sm"
                                               Text="Start Test Agent"
                                               LoadingText="Starting..." />
                            @if (!string.IsNullOrEmpty(_testAgentError))
                            {
                                <div class="alert alert-danger py-1 px-2 mb-0 text-sm">
                                    @_testAgentError
                                </div>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    }

    @* Fleece Sync Conflict Modal *@
    <Modal IsOpen="@_showFleeceConflictModal"
           OnClose="@HideFleeceConflictModal"
           Title="Sync Conflict"
           Centered="true">
        <Body>
            <div class="alert alert-warning">
                <strong>Unable to pull changes from @_project?.DefaultBranch</strong>
            </div>
            <p class="small text-muted">@_fleecePullConflict?.ErrorMessage</p>
            <p>Choose how to resolve this conflict:</p>
        </Body>
        <Footer>
            <button type="button" class="btn btn-secondary" @onclick="HideFleeceConflictModal">Cancel</button>
            <AsyncActionButton OnClick="HandleFleeceConflictStash"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-warning"
                               Text="Stash Changes" />
            <AsyncActionButton OnClick="HandleFleeceConflictDiscard"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-danger"
                               Text="Discard All Changes" />
        </Footer>
    </Modal>

    @* Non-Fleece Changes Modal *@
    <Modal IsOpen="@_showNonFleeceChangesModal"
           OnClose="@HideNonFleeceChangesModal"
           Title="Non-Fleece Changes Detected"
           Size="ModalSize.Lg"
           Centered="true">
        <Body>
            <div class="alert alert-warning">
                <strong>Your local branch is behind the remote</strong>
            </div>
            <p>
                The sync cannot complete because your local branch needs to pull changes from the remote,
                but you have uncommitted changes outside the <code>.fleece/</code> folder that may cause conflicts.
            </p>
            @if (_nonFleeceChangedFiles != null && _nonFleeceChangedFiles.Count > 0)
            {
                <p><strong>Changed files outside .fleece/:</strong></p>
                <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                    <ul class="mb-0 small">
                        @foreach (var file in _nonFleeceChangedFiles)
                        {
                            <li><code>@file</code></li>
                        }
                    </ul>
                </div>
            }
            <p class="mt-3 text-muted small">
                You can discard these non-fleece changes to allow the sync to complete.
                Your <code>.fleece/</code> changes will be preserved.
            </p>
        </Body>
        <Footer>
            <button type="button" class="btn btn-secondary" @onclick="HideNonFleeceChangesModal">Cancel</button>
            <AsyncActionButton OnClick="HandleDiscardNonFleeceChanges"
                               IsLoadingExternal="_isSyncingFleece"
                               CssClass="btn-danger"
                               Text="Discard Non-Fleece Changes" />
        </Footer>
    </Modal>
}
</div>

<style>
    .project-detail-page {
        outline: none;
        max-width: 100%;
        overflow-x: hidden;
        transition: margin-right 0.2s ease;
    }

    /* Desktop: Squash main content when sidebar is open */
    .project-detail-page.sidebar-open {
        margin-right: 350px;
    }

    /* ==========================================================================
       Sticky Header - Title and Toolbar
       ========================================================================== */
    .project-sticky-header {
        position: sticky;
        top: 0;
        z-index: 90;
        background: var(--bg-primary, #1a1a2e);
        padding-bottom: var(--spacing-sm, 8px);
        margin-bottom: var(--spacing-md, 16px);
        border-bottom: 1px solid var(--border-color, rgba(255, 255, 255, 0.1));
    }

    /* ==========================================================================
       Project Layout Grid
       ========================================================================== */
    .project-layout {
        display: grid;
        grid-template-columns: 1fr;
        gap: var(--spacing-md);
        align-items: start;
        max-width: 100%;
        min-width: 0;
    }

    .timeline-column {
        min-width: 0;
        max-width: 100%;
        overflow-x: auto;
    }

    /* ==========================================================================
       Collapsible Detail Sidebar
       ========================================================================== */
    .detail-sidebar {
        position: fixed;
        right: 0;
        top: var(--topbar-height, 48px);
        height: calc(100vh - var(--topbar-height, 48px));
        width: 350px;
        background: var(--bg-primary);
        border-left: 1px solid var(--border-color);
        transform: translateX(100%);
        transition: transform 0.2s ease;
        overflow-y: auto;
        z-index: 100;
        padding: var(--spacing-md);
    }

    .detail-sidebar.open {
        transform: translateX(0);
    }

    /* ==========================================================================
       Mobile: Overlay behavior (sidebar covers content)
       ========================================================================== */
    @@media (max-width: 768px) {
        .detail-sidebar {
            width: 100%;
        }

        /* On mobile, don't squash - let sidebar overlay */
        .project-detail-page.sidebar-open {
            margin-right: 0;
        }
    }

    /* ==========================================================================
       Issue Toolbar
       ========================================================================== */
    .issue-toolbar {
        display: flex;
        justify-content: flex-end;
        padding: 0.5rem 0;
    }

    .issue-toolbar .text-muted {
        color: var(--text-muted, #6c757d);
    }

    .issue-toolbar .text-sm {
        font-size: 0.875rem;
    }

    /* ==========================================================================
       Settings Tab
       ========================================================================== */
    .settings-tab-content {
        max-width: 800px;
    }
</style>

@code {
    [Parameter] public string Id { get; set; } = "";

    private Project? _project;
    private List<PullRequest>? _rootPullRequests;
    private List<FlattenedPR> _flattenedCurrentPRs = [];
    private PullRequest? _selectedPullRequest;
    private string? _selectedPullRequestId;
    private MergedPullRequestDetails? _selectedMergedPr;
    private bool _isLoadingMergedPr;
    private IssueResponse? _selectedIssue;
    private string? _selectedIssueId;
    private bool _isSyncingPRs;
    private bool _tokenMissing;
    private string? _syncError;
    private SyncResult? _lastSyncResult;
    private List<IssueResponse>? _openIssues;
    private List<IssueResponse>? _inProgressIssues;
    private TimelineVisualization? _graphVisualization;
    private HubConnection? _hubConnection;
    private bool _isRefreshing;
    private bool _isSyncing;

    // Undo/Redo state
    private IssueHistoryState? _historyState;
    private bool _canUndo;
    private bool _canRedo;
    private bool _isUndoRedoing;

    // Tab navigation state
    private string _activeTab = "issues";

    // Track Id changes for same-component navigation
    private string? _previousId;

    // Keyboard navigation state
    private ElementReference _pageContainer;
    private KeyboardEditMode _previousEditMode = KeyboardEditMode.Viewing;

    // Collapsible sidebar state - tracks which item was CLICKED (not keyboard-selected)
    private bool _sidebarOpen = false;  // Collapsed by default


    protected override async Task OnParametersSetAsync()
    {
        if (_previousId != null && _previousId != Id)
        {
            // Id parameter changed â€” navigated to a different project
            // Dispose old SignalR connection
            if (_hubConnection != null)
            {
                await _hubConnection.DisposeAsync();
                _hubConnection = null;
            }

            // Reset all state
            _selectedPullRequest = null;
            _selectedPullRequestId = null;
            _selectedMergedPr = null;
            _isLoadingMergedPr = false;
            _selectedIssue = null;
            _selectedIssueId = null;
            _lastSyncResult = null;
            _syncError = null;
            _activeTab = "issues";
            _sidebarOpen = false;

            // Determine tab from URL
            var uri = NavigationManager.Uri;
            if (uri.Contains("/settings")) _activeTab = "settings";
            else if (uri.Contains("/secrets")) _activeTab = "secrets";
            else if (uri.Contains("/prompts")) _activeTab = "prompts";
            else if (uri.Contains("/agents")) _activeTab = "agents";
            else if (uri.Contains("/branches")) _activeTab = "branches";

            // Reload data for the new project
            await LoadData();
            await SetupSignalRConnection();

            if (_project != null)
            {
                _ = Task.Run(async () =>
                {
                    await InvokeAsync(async () =>
                    {
                        await SyncPullRequestsAsync();
                    });
                });
            }
        }
        _previousId = Id;
    }

    // IsDebugBuild property for conditional rendering
#if DEBUG
    private static bool IsDebugBuild => true;
    // Test agent state
    private bool _isStartingTestAgent;
    private string? _testAgentError;
    private const string TestAgentEntityId = "test-agent";
    private const string TestBranchName = "hsp/test";
#else
    private static bool IsDebugBuild => false;
    // Stubs for Release build (never used since IsDebugBuild is false)
    private bool _isStartingTestAgent => false;
    private string? _testAgentError => null;
    private Task StartTestAgentAsync() => Task.CompletedTask;
#endif

    // Fleece sync state
    private bool _isSyncingFleece;
    private string? _fleeceSyncError;
    private FleeceIssueSyncResult? _lastFleeceSyncResult;
    private bool _showFleeceConflictModal;
    private PullResult? _fleecePullConflict;
    private bool _showNonFleeceChangesModal;
    private IReadOnlyList<string>? _nonFleeceChangedFiles;

    // Split button sync actions
    private IReadOnlyList<SplitButtonAction> _syncActions = [];

    private void InitializeSyncActions()
    {
        _syncActions =
        [
            new SplitButtonAction(
                Key: "sync",
                Text: "Sync",
                Icon: (RenderFragment)(builder =>
                {
                    builder.OpenElement(0, "i");
                    builder.AddAttribute(1, "class", "bi bi-cloud-arrow-up");
                    builder.CloseElement();
                }),
                OnClick: EventCallback.Factory.Create(this, SyncAllAsync))
        ];
    }

    private record FlattenedPR(PullRequest PullRequest, int Level);

    protected override async Task OnInitializedAsync()
    {
        // Initialize sync actions for split button
        InitializeSyncActions();

        // Determine active tab from URL
        var uri = NavigationManager.Uri;
        if (uri.Contains("/settings"))
            _activeTab = "settings";
        else if (uri.Contains("/secrets"))
            _activeTab = "secrets";
        else if (uri.Contains("/prompts"))
            _activeTab = "prompts";
        else if (uri.Contains("/agents"))
            _activeTab = "agents";
        else if (uri.Contains("/branches"))
            _activeTab = "branches";
        else
            _activeTab = "issues";

        // Subscribe to agent startup state changes to update UI
        StartupTracker.OnStateChanged += OnStartupStateChanged;

        // Subscribe to panel service state changes
        PanelService.OnStateChanged += OnPanelServiceStateChanged;

        // Register panel availability for issues tab
        if (_activeTab == "issues")
        {
            PanelService.SetPanelAvailable(true);
        }

        await LoadData();
        await SetupSignalRConnection();

        // Start sync after project is loaded
        // Using Task.Run to not block the initial render
        if (_project != null)
        {
            _ = Task.Run(async () =>
            {
                await InvokeAsync(async () =>
                {
                    await SyncPullRequestsAsync();
                });
            });
        }
    }

    // Track if we've already processed the hash fragment
    private bool _hasProcessedHashFragment;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await HandleHashFragmentAsync();

            if (_activeTab == "issues")
            {
                await JSRuntime.InvokeVoidAsync("homespunInterop.focusElement", _pageContainer);
                await JSRuntime.InvokeVoidAsync("homespunInterop.setupKeyboardPrevention", _pageContainer);
            }

            NavService.OnStateChanged += OnNavServiceStateChanged;
            NavService.OnOpenEditRequested += OnOpenEditRequested;
            NavService.OnIssueCreatedForEdit += NavigateToIssueEditAsync;
            NavService.OnMoveOperationRequested += OnMoveOperationRequested;
        }
    }

    private Task NavigateToIssueEditAsync(string issueId)
    {
        return NavigateToIssueEdit(issueId);
    }

    private async Task HandleHashFragmentAsync()
    {
        if (_hasProcessedHashFragment) return;
        _hasProcessedHashFragment = true;

        var uri = new Uri(NavigationManager.Uri);
        if (!string.IsNullOrEmpty(uri.Fragment))
        {
            var fragment = uri.Fragment.TrimStart('#');
            if (fragment.StartsWith("issue-"))
            {
                var issueId = fragment.Substring(6);

                // Wait a brief moment for issues to be loaded if needed
                var retries = 0;
                while ((_openIssues == null || _openIssues.Count == 0) && retries < 10)
                {
                    await Task.Delay(100);
                    retries++;
                }

                if (_openIssues?.Any(i => i.Id == issueId) == true)
                {
                    SelectIssue(issueId);
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
    }

    private void OnNavServiceStateChanged()
    {
        var currentMode = NavService.EditMode;
        if (_previousEditMode != KeyboardEditMode.Viewing && currentMode == KeyboardEditMode.Viewing)
        {
            // Transitioned from edit/create mode back to viewing - re-focus page container
            _ = InvokeAsync(async () =>
            {
                await JSRuntime.InvokeVoidAsync("homespunInterop.focusElement", _pageContainer);
            });
        }
        _previousEditMode = currentMode;
    }

    private void OnOpenEditRequested(string issueId)
    {
        HandleEditIssue(issueId);
    }

    private async Task OnMoveOperationRequested(string sourceIssueId, string targetIssueId, MoveOperationType operation, bool addToExisting)
    {
        try
        {
            string childId, parentId;
            if (operation == MoveOperationType.AsChildOf)
            {
                // Source becomes child of target
                childId = sourceIssueId;
                parentId = targetIssueId;
            }
            else // AsParentOf
            {
                // Target becomes child of source
                childId = targetIssueId;
                parentId = sourceIssueId;
            }

            var request = new SetParentRequest
            {
                ProjectId = Id,
                ParentIssueId = parentId,
                AddToExisting = addToExisting
            };

            await IssueApi.SetParentAsync(childId, request);

            // Refresh the task graph
            await RefreshData();
        }
        catch (InvalidOperationException ex)
        {
            // Cycle detected - log the error
            Logger.LogWarning("Move operation would create cycle: {Message}", ex.Message);
            // TODO: Show a toast notification to the user
        }
    }

    private void OnPanelServiceStateChanged()
    {
        // Sync local sidebar state with panel service
        if (_sidebarOpen != PanelService.IsPanelOpen)
        {
            _sidebarOpen = PanelService.IsPanelOpen;
            InvokeAsync(StateHasChanged);
        }
    }

    private void SwitchTab(string tab)
    {
        if (_activeTab == tab) return;

        // Cancel any in-progress edit when leaving issues tab
        if (_activeTab == "issues" && NavService.EditMode != KeyboardEditMode.Viewing)
        {
            NavService.CancelEdit();
        }

        _activeTab = tab;
        ClearSelection();

        // Update panel availability based on tab
        PanelService.SetPanelAvailable(tab == "issues");

        // Update the URL without causing a full navigation
        var newUrl = tab switch
        {
            "branches" => $"/projects/{Id}/branches",
            "agents" => $"/projects/{Id}/agents",
            "prompts" => $"/projects/{Id}/prompts",
            "secrets" => $"/projects/{Id}/secrets",
            "settings" => $"/projects/{Id}/settings",
            _ => $"/projects/{Id}"
        };
        NavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);

        if (tab == "issues")
        {
            _ = InvokeAsync(async () =>
            {
                await JSRuntime.InvokeVoidAsync("homespunInterop.focusElement", _pageContainer);
                await JSRuntime.InvokeVoidAsync("homespunInterop.setupKeyboardPrevention", _pageContainer);
            });
        }
    }

    private void SwitchToIssuesTab() => SwitchTab("issues");
    private void SwitchToBranchesTab() => SwitchTab("branches");
    private void SwitchToAgentsTab() => SwitchTab("agents");
    private void SwitchToPromptsTab() => SwitchTab("prompts");
    private void SwitchToSecretsTab() => SwitchTab("secrets");
    private void SwitchToSettingsTab() => SwitchTab("settings");

    public void Dispose()
    {
        StartupTracker.OnStateChanged -= OnStartupStateChanged;
        NavService.OnStateChanged -= OnNavServiceStateChanged;
        NavService.OnOpenEditRequested -= OnOpenEditRequested;
        NavService.OnIssueCreatedForEdit -= NavigateToIssueEditAsync;
        NavService.OnMoveOperationRequested -= OnMoveOperationRequested;
        PanelService.OnStateChanged -= OnPanelServiceStateChanged;
        PanelService.SetPanelAvailable(false);
    }

    public async ValueTask DisposeAsync()
    {
        Dispose();
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private async void OnStartupStateChanged(string entityId, AgentStartupState state)
    {
        // Re-render when any startup state changes
        await InvokeAsync(StateHasChanged);
    }

    private async Task SetupSignalRConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri(HubConstants.NotificationHub))
                .Build();

            // Listen for pull request sync events
            _hubConnection.On<string, SyncResult>("PullRequestsSynced", async (projectId, syncResult) =>
            {
                // Only refresh if this event is for our project
                if (projectId == Id)
                {
                    Logger.LogInformation("Received PullRequestsSynced event for project {ProjectId}", projectId);
                    _lastSyncResult = syncResult;
                    await InvokeAsync(async () =>
                    {
                        await RefreshData();
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection established for project {ProjectId}", Id);
        }
        catch (Exception ex)
        {
            // SignalR connection can fail when accessing via external hostname that the container can't resolve.
            // This is expected - real-time updates won't work but the page will still function.
            Logger.LogWarning("SignalR connection failed (real-time updates unavailable): {Message}", ex.Message);
        }
    }

    private async Task LoadData()
    {
        _project = await ProjectApi.GetProjectAsync(Id);
        if (_project != null)
        {
            // Set breadcrumb context with project info
            await BreadcrumbService.SetContextAsync(new BreadcrumbContext { ProjectId = Id });

            _rootPullRequests = await PullRequestApi.GetProjectPullRequestsAsync(Id);
            _flattenedCurrentPRs = FlattenPRs(_rootPullRequests ?? []);

            try
            {
                // Load all issues from Fleece
                var allIssues = await IssueApi.GetIssuesAsync(_project.Id);

                // Get open issues (all non-completed statuses)
                _openIssues = allIssues
                    .Where(i => i.Status is IssueStatus.Open or IssueStatus.Progress or IssueStatus.Review)
                    .ToList();

                // In-progress issues could be tracked separately if needed
                _inProgressIssues = [];

                // Load history state for undo/redo
                await RefreshHistoryStateAsync();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load issues for project {ProjectId}", Id);
                _openIssues = [];
                _inProgressIssues = [];
            }
        }
    }

    private List<FlattenedPR> FlattenPRs(List<PullRequest> prs, int level = 0)
    {
        var result = new List<FlattenedPR>();
        foreach (var pr in prs.OrderBy(p => p.CreatedAt))
        {
            result.Add(new FlattenedPR(pr, level));
            if (pr.Children.Any())
            {
                result.AddRange(FlattenPRs(pr.Children.ToList(), level + 1));
            }
        }

        return result;
    }

    private async Task SyncPullRequestsAsync()
    {
        if (_project == null || _isSyncingPRs)
            return;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return;

        var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
        if (!isConfigured)
        {
            _tokenMissing = true;
            Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
            StateHasChanged();
            return;
        }

        _isSyncingPRs = true;
        _tokenMissing = false;
        _syncError = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting automatic PR sync for project {ProjectId} ({Owner}/{Repo})",
                _project.Id, _project.GitHubOwner, _project.GitHubRepo);

            _lastSyncResult = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (_lastSyncResult.Errors.Count > 0)
            {
                _syncError = string.Join("; ", _lastSyncResult.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, _syncError);
            }
            else
            {
                Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                    _project.Id, _lastSyncResult.Imported, _lastSyncResult.Updated, _lastSyncResult.Removed);
            }

            await LoadData();
        }
        catch (Exception ex)
        {
            _syncError = ex.Message;
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingPRs = false;
            StateHasChanged();
        }
    }

    private async Task RefreshData()
    {
        if (_isRefreshing) return;

        _isRefreshing = true;
        StateHasChanged();

        try
        {
            await LoadData();
            if (_selectedPullRequestId != null)
            {
                _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(_selectedPullRequestId);
            }
            await _graphVisualization?.RefreshAsync()!;
        }
        finally
        {
            _isRefreshing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Pull operation that fetches from remote and merges fleece issues without committing/pushing.
    /// Also syncs GitHub PRs.
    /// </summary>
    private async Task PullAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            // Run fleece pull and PR sync in parallel
            var fleecePullTask = PullFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleecePullTask, prSyncTask);

            // Collect errors
            if (results[0] is string fleeceError)
                errors.Add($"Fleece pull: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            // Show error notification if any errors occurred
            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Pull completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"pull-error-{_project.Id}"
                });
            }

            // Refresh data after both complete
            await LoadData();
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Internal fleece pull that returns an error message or null on success.
    /// </summary>
    private async Task<string?> PullFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.PullFleeceOnlyAsync(_project.Id);

            if (result != null && !result.Success)
            {
                // For conflicts requiring user interaction, show modal
                if (result.HasNonFleeceChanges)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null; // Don't report as error - handled via modal
                }

                return result.ErrorMessage ?? "Unknown fleece pull error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to pull fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    /// <summary>
    /// Combined sync operation that runs fleece sync and PR sync in parallel.
    /// </summary>
    private async Task SyncAllAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            // Run fleece sync and PR sync in parallel
            var fleeceSyncTask = SyncFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleeceSyncTask, prSyncTask);

            // Collect errors
            if (results[0] is string fleeceError)
                errors.Add($"Fleece sync: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            // Show error notification if any errors occurred
            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Sync completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"sync-error-{_project.Id}"
                });
            }

            // Refresh data after both complete
            await LoadData();
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Internal fleece sync that returns an error message or null on success.
    /// </summary>
    private async Task<string?> SyncFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.SyncAsync(_project.Id);

            if (result != null && !result.Success)
            {
                // For conflicts requiring user interaction, skip error reporting
                // (they'll be handled when user manually syncs via the button)
                if (result.HasNonFleeceChanges && result.RequiresPullFirst)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null; // Don't report as error - handled via modal
                }

                return result.ErrorMessage ?? "Unknown fleece sync error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    /// <summary>
    /// Internal PR sync that returns an error message or null on success.
    /// </summary>
    private async Task<string?> SyncPullRequestsInternalAsync()
    {
        if (_project == null)
            return null;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return null; // No GitHub config is not an error

        try
        {
            var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
            if (!isConfigured)
            {
                Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
                return null; // Token not configured - silently skip
            }

            var result = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (result.Errors.Count > 0)
            {
                var errorMessage = string.Join("; ", result.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, errorMessage);
                return errorMessage;
            }

            Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                _project.Id, result.Imported, result.Updated, result.Removed);

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    private async Task NavigateToIssueEdit(string issueId)
    {
        await RefreshData();
        // autoSuggest=true triggers background branch ID generation on the edit page
        NavigationManager.NavigateTo($"/projects/{Id}/issues/{issueId}/edit?autoSuggest=true");
    }

    private async Task SelectPullRequest(string pullRequestId)
    {
        // Clear any other selection
        _selectedIssueId = null;
        _selectedIssue = null;
        _selectedMergedPr = null;

        _selectedPullRequestId = pullRequestId;
        _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(pullRequestId);
    }

    private void SelectIssue(string issueId)
    {
        // Clear any pull request selection
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedMergedPr = null;

        _selectedIssueId = issueId;
        _selectedIssue = _openIssues?.FirstOrDefault(i => i.Id == issueId)
                         ?? _inProgressIssues?.FirstOrDefault(i => i.Id == issueId);
    }

    /// <summary>
    /// Handles a click event on an issue in the task graph.
    /// On desktop: Opens the collapsible sidebar and displays the issue details.
    /// On mobile: Only selects the issue (panel opened via explicit button).
    /// Distinct from keyboard navigation which only highlights.
    /// </summary>
    private async Task HandleIssueClickFromGraph(string issueId)
    {
        SelectIssue(issueId);

        // On mobile, don't auto-open the sidebar - user must use the open panel button
        var isMobile = await JSRuntime.InvokeAsync<bool>("sidebarManager.isMobile");
        if (!isMobile)
        {
            _sidebarOpen = true;
            PanelService.SetPanelOpen(true);
        }
    }

    /// <summary>
    /// Handles explicit "Open Panel" button click from issue row (mobile only).
    /// </summary>
    private void HandleOpenPanelFromGraph(string issueId)
    {
        SelectIssue(issueId);
        _sidebarOpen = true;
        PanelService.SetPanelOpen(true);
    }

    /// <summary>
    /// Handles a click event on a pull request in the timeline.
    /// This opens the collapsible sidebar and displays the PR details.
    /// </summary>
    private async Task HandlePullRequestClickFromGraph(int prNumber)
    {
        await SelectPullRequestByNumber(prNumber);

        // On mobile, don't auto-open the sidebar
        var isMobile = await JSRuntime.InvokeAsync<bool>("sidebarManager.isMobile");
        if (!isMobile)
        {
            _sidebarOpen = true;
            PanelService.SetPanelOpen(true);
        }
    }

    /// <summary>
    /// Closes the collapsible sidebar without clearing the selection.
    /// </summary>
    private void CloseSidebar()
    {
        _sidebarOpen = false;
        PanelService.SetPanelOpen(false);
    }

    /// <summary>
    /// Selects an issue by ID, fetching from API if not found in local cache.
    /// Use this for newly created issues that may not be in the cached list yet.
    /// </summary>
    private async Task SelectIssueAsync(string issueId)
    {
        // Clear any pull request selection
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedMergedPr = null;

        _selectedIssueId = issueId;

        // Try to find in cached lists first
        _selectedIssue = _openIssues?.FirstOrDefault(i => i.Id == issueId)
                         ?? _inProgressIssues?.FirstOrDefault(i => i.Id == issueId);

        // If not found locally, fetch from API
        if (_selectedIssue == null)
        {
            try
            {
                _selectedIssue = await IssueApi.GetIssueAsync(issueId, Id);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to fetch issue {IssueId} for selection", issueId);
            }
        }
    }

    private async Task HandleInlineIssueCreated(string newIssueId)
    {
        // Refresh data to include the new issue
        await RefreshData();

        // Select the newly created issue (fetch from API if not in cache)
        await SelectIssueAsync(newIssueId);

        // Open the sidebar to show the new issue details
        _sidebarOpen = true;
    }

    private void HandleEditIssue(string issueId)
    {
        NavigationManager.NavigateTo($"/projects/{Id}/issues/{issueId}/edit");
    }

    private async Task HandleRunAgentOnIssue((string IssueId, AgentPrompt? Prompt) args)
    {
        var issue = _openIssues?.FirstOrDefault(i => i.Id == args.IssueId)
                    ?? _inProgressIssues?.FirstOrDefault(i => i.Id == args.IssueId);

        if (issue == null || _project == null) return;

        // Select the issue first
        SelectIssue(args.IssueId);

        // Get or create clone for the issue's branch
        var branchName = issue.WorkingBranchId ?? $"issue/{args.IssueId}";
        var clones = await CloneApi.ListClonesAsync(Id);
        var existingClone = clones.FirstOrDefault(c => c.Branch == branchName);

        string clonePath;
        if (existingClone != null)
        {
            clonePath = existingClone.Path;
        }
        else
        {
            // Create clone for the branch
            var request = new CreateCloneRequest
            {
                ProjectId = Id,
                BranchName = branchName,
                CreateBranch = true
            };
            var createResult = await CloneApi.CreateCloneAsync(request);
            clonePath = createResult?.Path ?? string.Empty;
            if (string.IsNullOrEmpty(clonePath))
            {
                Logger.LogError("Failed to create clone for branch {Branch}", branchName);
                return;
            }
        }

        // Start the agent session
        var mode = args.Prompt?.Mode ?? SessionMode.Build;
        var model = "opus"; // Default model

        // Build system prompt based on issue context
        string? systemPrompt = null;
        if (args.Prompt?.InitialMessage != null)
        {
            var context = new PromptContext
            {
                Title = issue.Title,
                Id = issue.Id,
                Description = issue.Description,
                Branch = branchName,
                Type = issue.Type.ToString()
            };
            systemPrompt = HttpAgentPromptApiService.RenderTemplate(args.Prompt.InitialMessage, context);
        }

        try
        {
            var session = await SessionApi.StartSessionAsync(
                args.IssueId,
                Id,
                clonePath,
                mode,
                model,
                systemPrompt);

            if (session != null)
            {
                // Navigate to the session
                NavigationManager.NavigateTo($"/session/{session.Id}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start agent session for issue {IssueId}", args.IssueId);
        }
    }

    private async Task SelectPullRequestByNumber(int prNumber)
    {
        // Clear any existing selection
        _selectedIssueId = null;
        _selectedIssue = null;
        _selectedMergedPr = null;

        // Find the PR in current PRs (internal database)
        var currentPr = _flattenedCurrentPRs.FirstOrDefault(p => p.PullRequest.GitHubPRNumber == prNumber);
        if (currentPr != null)
        {
            _selectedPullRequestId = currentPr.PullRequest.Id;
            _selectedPullRequest = await PullRequestApi.GetPullRequestAsync(currentPr.PullRequest.Id);
            return;
        }

        // Not in current PRs - try to fetch as merged/closed PR
        _selectedPullRequestId = null;
        _selectedPullRequest = null;

        // Show loading state and fetch merged PR details
        _isLoadingMergedPr = true;
        StateHasChanged();

        try
        {
            _selectedMergedPr = await PullRequestApi.GetMergedPullRequestDetailsAsync(Id, prNumber);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to fetch merged PR #{PrNumber} details", prNumber);
            _selectedMergedPr = null;
        }
        finally
        {
            _isLoadingMergedPr = false;
        }
    }

    private string? GetSelectedNodeId()
    {
        if (_selectedPullRequest != null && _selectedPullRequest.GitHubPRNumber.HasValue)
        {
            return $"pr-{_selectedPullRequest.GitHubPRNumber}";
        }

        if (_selectedMergedPr != null)
        {
            return $"pr-{_selectedMergedPr.PullRequest.Number}";
        }

        if (_selectedIssueId != null)
        {
            return $"issue-{_selectedIssueId}";
        }

        return null;
    }

    private void ClearSelection()
    {
        _selectedPullRequestId = null;
        _selectedPullRequest = null;
        _selectedMergedPr = null;
        _selectedIssueId = null;
        _selectedIssue = null;
        _sidebarOpen = false;
    }

    #region Search Methods

    private void HandleSearchTermChanged(string term)
    {
        NavService.UpdateSearchTerm(term);
    }

    private void HandleSearchEnter()
    {
        NavService.EmbedSearch();
    }

    private void HandleSearchEscape()
    {
        NavService.ClearSearch();
    }

    private string? GetActiveSearchTerm()
    {
        // Return the search term when search is embedded (committed)
        return NavService.IsSearchEmbedded ? NavService.SearchTerm : null;
    }

    #endregion

    private int GetTotalCurrentPRCount()
    {
        return _flattenedCurrentPRs.Count;
    }

    private int GetTotalCurrentCount()
    {
        return _flattenedCurrentPRs.Count + (_inProgressIssues?.Count ?? 0);
    }

    private static string GetCurrentPRStatusColor(OpenPullRequestStatus status) => status switch
    {
        OpenPullRequestStatus.InDevelopment => "status-in-development",
        OpenPullRequestStatus.ReadyForReview => "status-ready-for-review",
        OpenPullRequestStatus.HasReviewComments => "status-has-review-comments",
        OpenPullRequestStatus.Approved => "status-approved",
        _ => "status-default"
    };

    private static string GetIssueTypeStatusColor(IssueType type) => type switch
    {
        IssueType.Feature => "status-feature",
        IssueType.Bug => "status-bug",
        IssueType.Chore => "status-chore",
        IssueType.Task => "status-task",
        _ => "status-default"
    };

    private static string GetIssueStatusColor(IssueResponse issue)
    {
        if (issue.Status == IssueStatus.Closed || issue.Status == IssueStatus.Complete)
            return "status-approved";
        return GetIssueTypeStatusColor(issue.Type);
    }

    private static string GetIssueStatusTooltip(IssueResponse issue)
    {
        return $"{issue.Type} ({issue.Status})";
    }

    private static string? GetCurrentPRSubtitle(PullRequest pr)
    {
        var parts = new List<string>();

        if (!string.IsNullOrEmpty(pr.BranchName))
            parts.Add(pr.BranchName);

        return parts.Count > 0 ? string.Join(" - ", parts) : null;
    }

    private static string? GetIssueSubtitle(IssueResponse issue)
    {
        if (!string.IsNullOrEmpty(issue.Description))
        {
            // Truncate description for subtitle display
            var desc = issue.Description;
            if (desc.Length > 60)
                desc = desc[..57] + "...";
            return desc;
        }

        return null;
    }

    private AgentStartupStatus? GetStartupState(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.Status;
    }

    /// <summary>
    /// Checks if the currently selected issue has an agent running.
    /// Used by the toolbar to disable the run button when agent is active.
    /// </summary>
    private bool IsSelectedIssueAgentRunning()
    {
        var selectedId = NavService.SelectedIssueId;
        if (string.IsNullOrEmpty(selectedId)) return false;

        var state = StartupTracker.GetState(selectedId);
        return state?.Status == AgentStartupStatus.Starting || state?.Status == AgentStartupStatus.Started;
    }

    private string? GetStartupErrorMessage(string entityId)
    {
        var state = StartupTracker.GetState(entityId);
        return state?.ErrorMessage;
    }

#if DEBUG
    private async Task StartTestAgentAsync()
    {
        if (_project == null)
            return;

        _isStartingTestAgent = true;
        _testAgentError = null;
        StateHasChanged();

        try
        {
            // Clean up existing clone and branch if they exist
            // Try to remove the clone first (this handles the git clone tracking)
            try
            {
                var existingClones = await CloneApi.ListClonesAsync(Id);
                var testClone = existingClones.FirstOrDefault(c =>
                    c.Branch?.Replace("refs/heads/", "") == TestBranchName);
                if (testClone != null)
                {
                    await CloneApi.DeleteCloneAsync(Id, testClone.Path);
                }
            }
            catch (Exception ex2)
            {
                Logger.LogWarning(ex2, "Failed to clean up existing test clone, continuing...");
            }

            // TODO: Branch delete not available via HTTP API
            // await CommandRunner.RunAsync("git", $"branch -D \"{TestBranchName}\"", _project.LocalPath);

            // Prune any stale clone references
            await CloneApi.PruneClonesAsync(Id);

            // Create clone for hsp/test branch
            var createResult = await CloneApi.CreateCloneAsync(new CreateCloneRequest
            {
                ProjectId = Id,
                BranchName = TestBranchName,
                CreateBranch = true,
                BaseBranch = _project.DefaultBranch
            });
            var clonePath = createResult?.Path;

            if (string.IsNullOrEmpty(clonePath))
            {
                _testAgentError = "Failed to create clone for test branch.";
                return;
            }

            Logger.LogInformation("Created test clone at {ClonePath}", clonePath);

            // Start the agent session without a system prompt
            StartupTracker.MarkAsStarting(TestAgentEntityId);

            var session = await SessionApi.StartSessionAsync(
                TestAgentEntityId,
                Id,
                clonePath,
                SessionMode.Build,
                "sonnet",
                systemPrompt: null);

            StartupTracker.MarkAsStarted(TestAgentEntityId);

            Logger.LogInformation("Started test agent session {SessionId}", session.Id);

            // Send the task instruction as the initial message
            // This way the full instruction is visible in the chat
            var timestamp = DateTime.UtcNow.ToString("O");
            var taskMessage = $"""
                Create a file named `test.txt` in the current directory containing the following timestamp: {timestamp}

                After creating the file, confirm that it was created successfully.
                """;
            await SessionApi.SendMessageAsync(session.Id, taskMessage);

            // Agent started - user stays on current page and can monitor via status indicator
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start test agent");
            StartupTracker.MarkAsFailed(TestAgentEntityId, ex.Message);
            _testAgentError = $"Failed to start test agent: {ex.Message}";
        }
        finally
        {
            _isStartingTestAgent = false;
            StateHasChanged();
        }
    }
#endif

    private async Task SyncFleeceIssuesAsync()
    {
        if (_project == null || _isSyncingFleece)
            return;

        _isSyncingFleece = true;
        _fleeceSyncError = null;
        _nonFleeceChangedFiles = null;
        StateHasChanged();

        try
        {
            // In WASM mode, the server handles the full sync workflow
            // (commit, push, pull, conflict resolution) via a single endpoint
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                // Check if sync failed due to non-fleece changes blocking a required pull
                if (_lastFleeceSyncResult.HasNonFleeceChanges && _lastFleeceSyncResult.RequiresPullFirst)
                {
                    _nonFleeceChangedFiles = _lastFleeceSyncResult.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return;
                }

                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        catch (Exception ex)
        {
            _fleeceSyncError = ex.Message;
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private void HideFleeceConflictModal()
    {
        _showFleeceConflictModal = false;
        _fleecePullConflict = null;
    }

    private void HideNonFleeceChangesModal()
    {
        _showNonFleeceChangesModal = false;
        _nonFleeceChangedFiles = null;
    }

    private async Task HandleDiscardNonFleeceChanges()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideNonFleeceChangesModal();

            // Retry the sync - server handles conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictStash()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            // Retry sync - server handles stash/pull/conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictDiscard()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            // Retry sync - server handles discard/pull/conflict resolution
            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                _fleeceSyncError = _lastFleeceSyncResult.ErrorMessage;
                return;
            }

            await RefreshData();
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        // Only handle keyboard shortcuts on the issues tab
        if (_activeTab != "issues") return;

        // Don't handle when typing in search bar
        if (NavService.IsSearching) return;

        // Handle SelectingAgentPrompt mode separately
        if (NavService.EditMode == KeyboardEditMode.SelectingAgentPrompt)
        {
            switch (e.Key)
            {
                case "Escape":
                    NavService.CancelEdit();
                    break;
                case "j":
                case "ArrowDown":
                    NavService.MovePromptSelectionDown();
                    break;
                case "k":
                case "ArrowUp":
                    NavService.MovePromptSelectionUp();
                    break;
                case "Enter":
                    // Start the agent with selected prompt
                    _ = StartAgentFromKeyboardAsync();
                    break;
            }
            return;
        }

        // Handle SelectingMoveTarget mode
        if (NavService.EditMode == KeyboardEditMode.SelectingMoveTarget)
        {
            if (e.Key == "Escape")
            {
                NavService.CancelMoveOperation();
            }
            return;
        }

        // Don't handle if in other edit modes - let the inline editor handle it
        if (NavService.EditMode != KeyboardEditMode.Viewing)
        {
            // Handle Escape to cancel edit
            if (e.Key == "Escape")
            {
                NavService.CancelEdit();
            }
            return;
        }

        // Handle navigation and edit commands
        // Note: preventDefault is handled by ShouldPreventKeyDefault property
        switch (e.Key)
        {
            case "/":
                // Start search (Vim-style)
                NavService.StartSearch();
                break;
            case "n":
                // Navigate to next search match
                if (NavService.IsSearchEmbedded)
                {
                    NavService.MoveToNextMatch();
                }
                break;
            case "N":
                // Navigate to previous search match
                if (NavService.IsSearchEmbedded)
                {
                    NavService.MoveToPreviousMatch();
                }
                break;
            case "j":
            case "ArrowDown":
                NavService.MoveDown();
                break;
            case "k":
            case "ArrowUp":
                NavService.MoveUp();
                break;
            case "h":
            case "ArrowLeft":
                NavService.MoveToChild();
                break;
            case "l":
            case "ArrowRight":
                NavService.MoveToParent();
                break;
            case "i":
                NavService.StartEditingAtStart();
                break;
            case "a":
                NavService.StartEditingAtEnd();
                break;
            case "r":
                NavService.StartReplacingTitle();
                break;
            case "o":
                if (e.ShiftKey)
                    NavService.CreateIssueAbove();
                else
                    NavService.CreateIssueBelow();
                break;
            case "O":
                NavService.CreateIssueAbove();
                break;
            case "Enter":
                NavService.OpenSelectedIssueForEdit();
                break;
            case "e":
                // Start agent prompt selection mode
                NavService.StartSelectingPrompt();
                break;
            case "Escape":
                // Clear search if active, otherwise clear selection or close sidebar panel
                if (NavService.IsSearchEmbedded)
                {
                    NavService.ClearSearch();
                }
                else
                {
                    ClearSelection();
                }
                break;
            case "u":
                // u for undo (vim-style)
                _ = UndoAsync();
                break;
            case "g":
                NavService.MoveToFirst();
                break;
            case "G":
                NavService.MoveToLast();
                break;
        }
    }

    /// <summary>
    /// Starts the agent session from keyboard selection (Enter in SelectingAgentPrompt mode).
    /// </summary>
    private async Task StartAgentFromKeyboardAsync()
    {
        var issueRowActions = _graphVisualization?.GetActiveIssueRowActions();
        if (issueRowActions != null)
        {
            await issueRowActions.HandleKeyboardEnterAsync();
        }
        NavService.AcceptPromptSelection();
    }

    #region Create Issue Operations

    /// <summary>
    /// Determines if the create above/below buttons should be enabled.
    /// </summary>
    private bool CanCreateIssue() =>
        NavService.SelectedIndex >= 0 &&
        NavService.EditMode == KeyboardEditMode.Viewing;

    /// <summary>
    /// Handles the "Create Above" button click.
    /// </summary>
    private void HandleCreateAbove() => NavService.CreateIssueAbove();

    /// <summary>
    /// Handles the "Create Below" button click.
    /// </summary>
    private void HandleCreateBelow() => NavService.CreateIssueBelow();

    #endregion

    #region Undo/Redo Operations

    /// <summary>
    /// Refreshes the history state from the server.
    /// </summary>
    private async Task RefreshHistoryStateAsync()
    {
        try
        {
            _historyState = await IssueHistoryApi.GetStateAsync(Id);
            _canUndo = _historyState?.CanUndo ?? false;
            _canRedo = _historyState?.CanRedo ?? false;
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load history state for project {ProjectId}", Id);
            _historyState = null;
            _canUndo = false;
            _canRedo = false;
        }
    }

    /// <summary>
    /// Undoes the last change to issues.
    /// </summary>
    private async Task UndoAsync()
    {
        if (!_canUndo || _isUndoRedoing)
            return;

        _isUndoRedoing = true;
        StateHasChanged();

        try
        {
            var result = await IssueHistoryApi.UndoAsync(Id);
            if (result.Success)
            {
                _historyState = result.State;
                _canUndo = _historyState?.CanUndo ?? false;
                _canRedo = _historyState?.CanRedo ?? false;

                // Refresh the issues display
                await RefreshData();
            }
            else
            {
                Logger.LogWarning("Undo failed: {ErrorMessage}", result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to undo for project {ProjectId}", Id);
        }
        finally
        {
            _isUndoRedoing = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Redoes a previously undone change.
    /// </summary>
    private async Task RedoAsync()
    {
        if (!_canRedo || _isUndoRedoing)
            return;

        _isUndoRedoing = true;
        StateHasChanged();

        try
        {
            var result = await IssueHistoryApi.RedoAsync(Id);
            if (result.Success)
            {
                _historyState = result.State;
                _canUndo = _historyState?.CanUndo ?? false;
                _canRedo = _historyState?.CanRedo ?? false;

                // Refresh the issues display
                await RefreshData();
            }
            else
            {
                Logger.LogWarning("Redo failed: {ErrorMessage}", result.ErrorMessage);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to redo for project {ProjectId}", Id);
        }
        finally
        {
            _isUndoRedoing = false;
            StateHasChanged();
        }
    }

    #endregion

}
