@using Homespun.Client.Services
@using Homespun.Shared.Requests
@using Fleece.Core.Models
@using Microsoft.JSInterop
@inject HttpIssueApiService IssueApi
@inject IJSRuntime JSRuntime

<div class="inline-issue-create" data-testid="inline-issue-create">
    <div class="inline-issue-lane-indicator">
        @if (_laneOffset > 0)
        {
            <span class="lane-indicator parent">Parent of @(InsertAbove ? "below" : "above")</span>
        }
        else if (_laneOffset < 0)
        {
            <span class="lane-indicator child">Child of @(InsertAbove ? "below" : "above")</span>
        }
    </div>
    <div class="inline-issue-input-wrapper">
        <input @ref="_inputElement"
               type="text"
               class="inline-issue-input"
               placeholder="Enter issue title..."
               @bind="_title"
               @bind:event="oninput"
               @onkeydown="HandleKeyDown"
               @onblur="HandleBlur"
               data-testid="inline-issue-input" />
        @if (_isSubmitting)
        {
            <span class="inline-issue-spinner"></span>
        }
    </div>
</div>

<style>
    .inline-issue-create {
        display: flex;
        flex-direction: column;
        padding: 8px 12px;
        background-color: var(--bg-secondary, rgba(255, 255, 255, 0.05));
        border: 1px solid var(--color-ocean, #51A5C1);
        border-radius: 4px;
        margin: 4px 8px;
    }

    .inline-issue-lane-indicator {
        min-height: 20px;
        margin-bottom: 4px;
    }

    .lane-indicator {
        font-size: 11px;
        font-weight: 600;
        padding: 2px 6px;
        border-radius: 3px;
    }

    .lane-indicator.parent {
        background-color: rgba(139, 92, 246, 0.2);
        color: #8b5cf6;
        border: 1px solid #8b5cf6;
    }

    .lane-indicator.child {
        background-color: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
    }

    .inline-issue-input-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .inline-issue-input {
        flex: 1;
        background: var(--bg-primary, #1a1a2e);
        border: 1px solid var(--border-color, rgba(255, 255, 255, 0.1));
        border-radius: 4px;
        padding: 8px 12px;
        color: var(--text-primary, #eaeaea);
        font-size: 14px;
        outline: none;
    }

    .inline-issue-input:focus {
        border-color: var(--color-ocean, #51A5C1);
        box-shadow: 0 0 0 2px rgba(81, 165, 193, 0.2);
    }

    .inline-issue-input::placeholder {
        color: var(--text-muted, #6c757d);
    }

    .inline-issue-spinner {
        width: 16px;
        height: 16px;
        border: 2px solid var(--text-muted, #6c757d);
        border-top-color: var(--color-ocean, #51A5C1);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    @@keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>

@code {
    /// <summary>
    /// The project ID for creating the issue.
    /// </summary>
    [Parameter] public required string ProjectId { get; set; }

    /// <summary>
    /// The index in the render list where the new issue will be inserted.
    /// </summary>
    [Parameter] public int InsertIndex { get; set; }

    /// <summary>
    /// Whether creating above (true) or below (false) the selected issue.
    /// </summary>
    [Parameter] public bool InsertAbove { get; set; }

    /// <summary>
    /// The adjacent issue (either above or below depending on InsertAbove).
    /// This is the issue that will become a parent/child based on TAB/Shift+TAB.
    /// </summary>
    [Parameter] public string? AdjacentIssueId { get; set; }

    /// <summary>
    /// Whether TAB is allowed (there's an adjacent issue to become parent of).
    /// </summary>
    [Parameter] public bool CanMoveUp { get; set; }

    /// <summary>
    /// Whether Shift+TAB is allowed (there's an adjacent issue to become child of).
    /// </summary>
    [Parameter] public bool CanMoveDown { get; set; }

    /// <summary>
    /// Inherited parent issue ID from the reference issue's parent.
    /// When creating a sibling (no Tab/Shift+Tab), this parent is inherited.
    /// </summary>
    [Parameter] public string? InheritedParentIssueId { get; set; }

    /// <summary>
    /// Inherited sort order for the parent relationship.
    /// Used for series-mode parents to position the new sibling between adjacent siblings.
    /// </summary>
    [Parameter] public string? InheritedParentSortOrder { get; set; }

    /// <summary>
    /// Called when the user cancels (Escape or blur without submitting).
    /// </summary>
    [Parameter] public EventCallback OnCancel { get; set; }

    /// <summary>
    /// Called when a new issue is successfully created.
    /// </summary>
    [Parameter] public EventCallback<string> OnCreated { get; set; }

    private ElementReference _inputElement;
    private string _title = "";
    private int _laneOffset = 0; // 0 = sibling, +1 = parent, -1 = child
    private bool _tabPressed = false;
    private bool _isSubmitting = false;
    private bool _isCancelled = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("homespunInterop.focusWithCursor", _inputElement, "start", 0);
            }
            catch
            {
                // Focus might fail if element is not in DOM yet
            }
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "Enter":
                if (!string.IsNullOrWhiteSpace(_title) && !_isSubmitting)
                {
                    await SubmitAsync();
                }
                break;

            case "Escape":
                _isCancelled = true;
                await OnCancel.InvokeAsync();
                break;

            case "Tab":
                // Only allow one TAB/Shift+TAB press
                if (_tabPressed) break;

                if (e.ShiftKey)
                {
                    // Shift+TAB: Move down a lane (become child)
                    if (CanMoveDown && _laneOffset > -1)
                    {
                        _laneOffset = -1;
                        _tabPressed = true;
                    }
                }
                else
                {
                    // TAB: Move up a lane (become parent)
                    if (CanMoveUp && _laneOffset < 1)
                    {
                        _laneOffset = 1;
                        _tabPressed = true;
                    }
                }
                break;
        }
    }

    private async Task HandleBlur()
    {
        // Small delay to allow for button clicks
        await Task.Delay(100);

        if (!_isSubmitting && !_isCancelled)
        {
            await OnCancel.InvokeAsync();
        }
    }

    private async Task SubmitAsync()
    {
        if (_isSubmitting) return;
        _isSubmitting = true;
        StateHasChanged();

        try
        {
            var request = new CreateIssueRequest
            {
                ProjectId = ProjectId,
                Title = _title.Trim(),
                Type = IssueType.Task
            };

            // Set parent/child relationship based on lane offset
            if (_laneOffset > 0 && AdjacentIssueId != null)
            {
                // New issue becomes parent of adjacent issue
                // The adjacent issue should have the new issue as its parent
                request.ChildIssueId = AdjacentIssueId;
            }
            else if (_laneOffset < 0 && AdjacentIssueId != null)
            {
                // New issue becomes child of adjacent issue
                request.ParentIssueId = AdjacentIssueId;
            }
            else if (!string.IsNullOrEmpty(InheritedParentIssueId))
            {
                // Sibling case: inherit parent from reference issue
                request.ParentIssueId = InheritedParentIssueId;
                request.ParentSortOrder = InheritedParentSortOrder;
            }

            var createdIssue = await IssueApi.CreateIssueAsync(request);
            if (createdIssue != null)
            {
                await OnCreated.InvokeAsync(createdIssue.Id);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to create issue: {ex.Message}");
            _isSubmitting = false;
            StateHasChanged();
        }
    }
}
