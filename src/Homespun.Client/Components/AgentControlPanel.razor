@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable

@inject HttpSessionApiService SessionStoreApi
@inject HttpSessionApiService SessionApi
@inject HttpAgentPromptApiService AgentPromptApi
@inject IAgentStartupTracker StartupTracker
@inject NavigationManager NavigationManager
@inject ILogger<AgentControlPanel> Logger

@*
    Reusable component for managing Claude agent sessions.
    Shows appropriate controls based on session state:
    - No session: AgentSelector + Start button
    - Starting: Spinner
    - Active session: Status badge + Chat link + Stop button
*@

@if (_isStarting)
{
    <div class="agent-control-panel @(Compact ? "compact" : "")">
        <span class="badge bg-warning text-dark">
            <BbSpinner Size="SpinnerSize.Small" Class="me-1" />
            Starting...
        </span>
    </div>
}
else if (_session != null)
{
    <div class="agent-control-panel @(Compact ? "compact" : "") d-flex align-items-center gap-2">
        <span class="badge @_session.Status.ToBadgeClass()">
            @_session.Status.ToDisplayLabel()
        </span>
        <BbButton Variant="ButtonVariant.Default" Size="ButtonSize.Small" Href="@($"/session/{_session.Id}")">
            Chat
        </BbButton>
        <BbButton Variant="ButtonVariant.Destructive" Size="ButtonSize.Small"
                OnClick="StopSessionAsync"
                Disabled="@_isLoading">
            @if (_isLoading)
            {
                <BbSpinner Size="SpinnerSize.Small" />
            }
            else
            {
                <span>Stop</span>
            }
        </BbButton>
    </div>
}
else
{
    <div class="agent-control-panel @(Compact ? "compact" : "")">
        <AgentSelector
            Disabled="@Disabled"
            IsStarting="@_isStarting"
            OnStart="HandleAgentStart" />
    </div>
}

@if (!string.IsNullOrEmpty(_errorMessage))
{
    <FormMessage Type="FormMessageType.Error" Message="@_errorMessage" Class="mt-1 mb-0" />
}

<style>
    .agent-control-panel.compact {
        font-size: 0.875rem;
    }

    .agent-control-panel.compact .btn-sm {
        padding: 0.2rem 0.5rem;
        font-size: 0.75rem;
    }

    .alert-sm {
        font-size: 0.75rem;
    }
</style>

@code {
    /// <summary>
    /// Unique identifier for session tracking (e.g., issue ID or clone entity ID).
    /// </summary>
    [Parameter, EditorRequired]
    public required string EntityId { get; set; }

    /// <summary>
    /// Path to the clone where the agent will operate.
    /// </summary>
    [Parameter, EditorRequired]
    public required string ClonePath { get; set; }

    /// <summary>
    /// Project identifier.
    /// </summary>
    [Parameter, EditorRequired]
    public required string ProjectId { get; set; }

    /// <summary>
    /// Default model to use for the session.
    /// </summary>
    [Parameter]
    public string Model { get; set; } = "opus";

    /// <summary>
    /// Optional system prompt for the session.
    /// </summary>
    [Parameter]
    public string? SystemPrompt { get; set; }

    /// <summary>
    /// Optional title for prompt template rendering (e.g., issue title).
    /// </summary>
    [Parameter]
    public string? EntityTitle { get; set; }

    /// <summary>
    /// Optional description for prompt template rendering (e.g., issue description).
    /// </summary>
    [Parameter]
    public string? EntityDescription { get; set; }

    /// <summary>
    /// Optional type for prompt template rendering (e.g., "Feature", "Bug", "Task").
    /// </summary>
    [Parameter]
    public string? EntityType { get; set; }

    /// <summary>
    /// Optional branch name for prompt template rendering.
    /// If not provided, falls back to extracting from ClonePath.
    /// </summary>
    [Parameter]
    public string? BranchName { get; set; }

    /// <summary>
    /// Whether to use compact layout (smaller buttons/text).
    /// </summary>
    [Parameter]
    public bool Compact { get; set; }

    /// <summary>
    /// Whether the controls should be disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Callback when a session is successfully started.
    /// </summary>
    [Parameter]
    public EventCallback<ClaudeSession> OnSessionStarted { get; set; }

    /// <summary>
    /// Callback when a session is stopped.
    /// </summary>
    [Parameter]
    public EventCallback OnSessionStopped { get; set; }

    private ClaudeSession? _session;
    private bool _isStarting;
    private bool _isLoading;
    private string? _errorMessage;
    private HubConnection? _hubConnection;

    protected override async Task OnInitializedAsync()
    {
        await UpdateSessionStateAsync();

        // Set up SignalR connection for real-time updates (non-blocking)
        _ = SetupSignalRConnectionAsync();
    }

    private async Task SetupSignalRConnectionAsync()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/claudecode"))
                .WithAutomaticReconnect()
                .Build();

            // Subscribe to session started events - update UI when session becomes active
            _hubConnection.On<ClaudeSession>("SessionStarted", async (session) =>
            {
                // Only handle events for this specific entity
                if (session.EntityId == EntityId)
                {
                    await InvokeAsync(() =>
                    {
                        _session = session;
                        _isStarting = false;
                        StateHasChanged();
                    });
                }
            });

            // Subscribe to session status changes - refresh session data
            _hubConnection.On<string, ClaudeSessionStatus, bool>("SessionStatusChanged", async (sessionId, status, hasPendingPlanApproval) =>
            {
                // Refresh if the changed session is ours
                if (_session?.Id == sessionId)
                {
                    await InvokeAsync(async () =>
                    {
                        _session = await SessionStoreApi.GetSessionByEntityIdAsync(EntityId);
                        StateHasChanged();
                    });
                }
            });

            // Subscribe to session stopped events - clear the session
            _hubConnection.On<string>("SessionStopped", async (sessionId) =>
            {
                // Clear session if it was ours
                if (_session?.Id == sessionId)
                {
                    await InvokeAsync(() =>
                    {
                        _session = null;
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to set up SignalR connection for AgentControlPanel");
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        await UpdateSessionStateAsync();
    }

    private async Task UpdateSessionStateAsync()
    {
        _session = await SessionStoreApi.GetSessionByEntityIdAsync(EntityId);
        _isStarting = StartupTracker.IsStarting(EntityId);
    }

    private async Task HandleAgentStart(AgentPrompt? selectedPrompt)
    {
        _errorMessage = null;
        if (!StartupTracker.TryMarkAsStarting(EntityId)) return;
        _isStarting = true;
        StateHasChanged();

        try
        {
            var mode = selectedPrompt?.Mode ?? SessionMode.Build;

            _session = await SessionApi.StartSessionAsync(
                EntityId,
                ProjectId,
                ClonePath,
                mode,
                Model,
                SystemPrompt);

            StartupTracker.MarkAsStarted(EntityId);

            // Send initial message if prompt has one
            if (selectedPrompt != null && !string.IsNullOrEmpty(selectedPrompt.InitialMessage))
            {
                // Build full prompt context with all available entity information
                var promptContext = new PromptContext
                {
                    Id = EntityId,
                    Title = EntityTitle ?? string.Empty,
                    Description = EntityDescription,
                    Type = EntityType ?? string.Empty,
                    Branch = BranchName ?? Path.GetFileName(ClonePath) ?? string.Empty
                };

                var initialMessage = HttpAgentPromptApiService.RenderTemplate(
                    selectedPrompt.InitialMessage, promptContext);

                if (!string.IsNullOrEmpty(initialMessage))
                {
                    await SessionApi.SendMessageAsync(_session.Id, initialMessage);
                }
            }

            await OnSessionStarted.InvokeAsync(_session);

            // Navigate to session page
            NavigationManager.NavigateTo($"/session/{_session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start session for entity {EntityId}", EntityId);
            StartupTracker.MarkAsFailed(EntityId, ex.Message);
            StartupTracker.Clear(EntityId);
            _errorMessage = $"Failed to start: {ex.Message}";
            _session = null;
        }
        finally
        {
            _isStarting = false;
            StateHasChanged();
        }
    }

    private async Task StopSessionAsync()
    {
        if (_session == null) return;

        _isLoading = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            await SessionApi.StopSessionAsync(_session.Id);
            _session = null;
            await OnSessionStopped.InvokeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to stop session {SessionId}", _session?.Id);
            _errorMessage = $"Failed to stop: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
