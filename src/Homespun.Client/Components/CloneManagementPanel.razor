@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable

@inject HttpCloneApiService CloneApi
@inject HttpSessionApiService SessionStoreApi
@inject HttpSessionApiService SessionApi
@inject HttpPullRequestApiService GitHubApi
@inject HttpFleeceSyncApiService FleeceSyncApi
@inject HttpPullRequestApiService PullRequestApi
@inject HttpPullRequestApiService PullRequestWorkflowApi
@inject NavigationManager NavigationManager
@inject ILogger<CloneManagementPanel> Logger

<div class="clone-management-panel">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h4 class="mb-0">Branches</h4>
        <div class="btn-group">
            <button class="btn btn-outline-secondary btn-sm" @onclick="RefreshDataAsync" disabled="@_isLoading">
                @if (_isLoading)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="FetchAllAsync" disabled="@_isFetching">
                @if (_isFetching)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-cloud-download"></i> Fetch
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="PruneClonesAsync" disabled="@_isPruning" title="Clean up stale clone references">
                @if (_isPruning)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-trash"></i> Prune
            </button>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            @_errorMessage
            <button type="button" class="btn-close" @onclick="() => _errorMessage = null"></button>
        </div>
    }

    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="alert alert-success alert-dismissible fade show" role="alert">
            @_successMessage
            <button type="button" class="btn-close" @onclick="() => _successMessage = null"></button>
        </div>
    }

    @* Active Branches Section *@
    <div class="section-header d-flex justify-content-between align-items-center">
        <span>Active Branches</span>
        <span class="badge bg-secondary">@_clones.Count(w => !w.IsBare)</span>
    </div>
    @if (_clones.Count(w => !w.IsBare) == 0)
    {
        <div class="text-muted p-3">No active branches</div>
    }
    else
    {
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th>Path</th>
                    <th>Status</th>
                    <th>Last Commit</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var clone in _clones.Where(w => !w.IsBare))
                {
                    var branchName = GetShortBranchName(clone.Branch);
                    var branchInfo = _branches.FirstOrDefault(b => b.ShortName == branchName);
                    var session = GetSessionForClone(clone);
                    var prInfo = GetPullRequestForBranch(branchName);
                    var status = GetCloneStatus(clone.Path);
                    var deleteKey = $"clone:{branchName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@branchName</strong>
                            <span class="badges">
                                @if (IsDefaultBranch(branchName))
                                {
                                    <span class="badge bg-primary">default</span>
                                }
                                @if (branchInfo?.IsMerged == true)
                                {
                                    <span class="badge bg-success">merged</span>
                                }
                                @if (prInfo != null)
                                {
                                    <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                       target="_blank"
                                       class="badge bg-info text-decoration-none">
                                        PR #@prInfo.GitHubPRNumber
                                    </a>
                                }
                                @if (!clone.IsOnCorrectBranch)
                                {
                                    <span class="badge bg-danger" title="Expected branch: @clone.ExpectedBranch">
                                        Wrong Branch
                                    </span>
                                }
                                @if (status != null && status.HasChanges)
                                {
                                    @if (status.ModifiedCount > 0)
                                    {
                                        <span class="badge bg-warning text-dark" title="Modified files">M: @status.ModifiedCount</span>
                                    }
                                    @if (status.StagedCount > 0)
                                    {
                                        <span class="badge bg-success" title="Staged files">S: @status.StagedCount</span>
                                    }
                                    @if (status.UntrackedCount > 0)
                                    {
                                        <span class="badge bg-secondary" title="Untracked files">U: @status.UntrackedCount</span>
                                    }
                                }
                            </span>
                        </td>
                        <td><code class="clone-path">@clone.Path</code></td>
                        <td class="status-col">
                            @if (session != null)
                            {
                                <span class="badge @GetSessionStatusBadgeClass(session.Status)">
                                    @session.Status
                                </span>
                            }
                            @if (false) @* StartupTracker not available in WASM *@
                            {
                                <span class="badge bg-warning text-dark">
                                    <span class="spinner-border spinner-border-sm me-1" role="status" style="width: 0.6rem; height: 0.6rem;"></span>
                                    Starting...
                                </span>
                            }
                            @if (branchInfo != null && (branchInfo.AheadCount > 0 || branchInfo.BehindCount > 0))
                            {
                                <span class="sync-info">
                                    @if (branchInfo.AheadCount > 0)
                                    {
                                        <span class="text-success">+@branchInfo.AheadCount</span>
                                    }
                                    @if (branchInfo.BehindCount > 0)
                                    {
                                        <span class="text-danger">-@branchInfo.BehindCount</span>
                                    }
                                </span>
                            }
                        </td>
                        <td class="commit-col">
                            @if (!string.IsNullOrEmpty(branchInfo?.LastCommitMessage))
                            {
                                <span class="commit-message" title="@branchInfo.LastCommitMessage">@TruncateMessage(branchInfo.LastCommitMessage)</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                @if (IsDefaultBranch(branchName))
                                {
                                    @if (session != null)
                                    {
                                        <a href="/session/@session.Id" class="btn btn-sm btn-primary me-1" title="Open chat">
                                            Chat
                                        </a>
                                        <button class="btn btn-sm btn-outline-danger me-1"
                                                @onclick="() => StopSessionAsync(session)"
                                                disabled="@_operationInProgress"
                                                title="Stop session">
                                            Stop
                                        </button>
                                    }
                                    else @* StartupTracker not available in WASM *@
                                    {
                                        <button class="btn btn-sm btn-success me-1"
                                                @onclick="() => StartMainBranchSessionAsync(clone)"
                                                disabled="@_operationInProgress"
                                                title="Start a new agent session on the main branch">
                                            <i class="bi bi-robot me-1"></i>Run Agent
                                        </button>
                                    }

                                    @if (branchInfo?.BehindCount > 0)
                                    {
                                        <button class="btn btn-sm btn-outline-info"
                                                @onclick="() => UpdateMainBranchAsync(clone)"
                                                disabled="@(_operationInProgress || _isUpdatingMain)"
                                                title="Pull latest changes and sync fleece issues (@branchInfo.BehindCount commits behind)">
                                            @if (_isUpdatingMain)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            <i class="bi bi-cloud-download me-1"></i>Update
                                        </button>
                                    }
                                }
                                else
                                {
                                    @if (!clone.IsOnCorrectBranch)
                                    {
                                        <button class="btn btn-sm btn-warning me-1"
                                                @onclick="() => FixBranchAsync(clone)"
                                                disabled="@_operationInProgress"
                                                title="Checkout the correct branch: @clone.ExpectedBranch">
                                            Fix Branch
                                        </button>
                                    }

                                    <AgentControlPanel
                                        EntityId="@GetCloneEntityId(clone)"
                                        ClonePath="@clone.Path"
                                        ProjectId="@Project.Id"
                                        Model="@(Project.DefaultModel ?? "opus")"
                                        SystemPrompt="@($"You are working on branch: {branchName}")"
                                        BranchName="@branchName"
                                        Compact="true"
                                        Disabled="@_operationInProgress" />

                                    @if (branchInfo?.BehindCount > 0)
                                    {
                                        <button class="btn btn-sm btn-outline-secondary me-1"
                                                @onclick="() => PullLatestAsync(clone)"
                                                disabled="@_operationInProgress"
                                                title="Pull latest changes">
                                            Pull
                                        </button>
                                        <button class="btn btn-sm btn-outline-warning me-1"
                                                @onclick="() => StartRebaseAgentAsync(clone)"
                                                disabled="@(_operationInProgress || session != null)"
                                                title="Start rebase agent to rebase onto @Project.DefaultBranch">
                                            <i class="bi bi-arrow-repeat"></i> Rebase
                                        </button>
                                    }

                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => ShowDeleteCloneConfirmation(clone, branchInfo)"
                                            disabled="@_operationInProgress"
                                            title="Delete clone">
                                        Delete
                                    </button>
                                }
                            }
                            else
                            {
                                @* Inline delete confirmation *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-options">
                                        @if (_deleteIncludesClone)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteCloneOnly">
                                                <span class="form-check-label">Keep branch</span>
                                            </label>
                                        }
                                        @if (_hasRemoteBranch && !_deleteCloneOnly)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteRemoteBranch">
                                                <span class="form-check-label">Delete remote</span>
                                            </label>
                                        }
                                    </div>
                                    <div class="inline-confirm-actions">
                                        @if (!_deleteTargetIsMerged)
                                        {
                                            <span class="badge bg-warning text-dark me-1" title="This branch has not been merged">unmerged</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Lost Clones Section *@
    @if (_lostClones.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center bg-warning bg-opacity-25">
            <span><i class="bi bi-exclamation-triangle me-1"></i> Lost Clones</span>
            <span class="badge bg-warning text-dark">@_lostClones.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Folder</th>
                    <th>Path</th>
                    <th>Status</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var lost in _lostClones)
                {
                    var deleteKey = $"lost:{lost.FolderName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@lost.FolderName</strong>
                            <span class="badges">
                                <span class="badge bg-warning text-dark">Lost</span>
                                @if (lost.CanRepair)
                                {
                                    <span class="badge bg-info" title="Can be repaired to branch: @lost.MatchingBranchName">
                                        <i class="bi bi-arrow-right"></i> @lost.MatchingBranchName
                                    </span>
                                }
                                @if (lost.Status != null && lost.Status.HasChanges)
                                {
                                    @if (lost.Status.ModifiedCount > 0)
                                    {
                                        <span class="badge bg-danger" title="Modified files - may lose work!">M: @lost.Status.ModifiedCount</span>
                                    }
                                    @if (lost.Status.StagedCount > 0)
                                    {
                                        <span class="badge bg-success" title="Staged files">S: @lost.Status.StagedCount</span>
                                    }
                                    @if (lost.Status.UntrackedCount > 0)
                                    {
                                        <span class="badge bg-secondary" title="Untracked files">U: @lost.Status.UntrackedCount</span>
                                    }
                                }
                            </span>
                        </td>
                        <td><code class="clone-path">@lost.Path</code></td>
                        <td class="status-col">
                            @if (lost.Status != null && lost.Status.HasChanges)
                            {
                                <span class="badge bg-danger">Has changes</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                @if (lost.CanRepair)
                                {
                                    <button class="btn btn-sm btn-outline-success me-1"
                                            @onclick="() => RepairLostCloneAsync(lost)"
                                            disabled="@_operationInProgress"
                                            title="Reattach to branch @lost.MatchingBranchName">
                                        Repair
                                    </button>
                                }
                                <button class="btn btn-sm btn-outline-danger"
                                        @onclick="() => ShowDeleteLostCloneConfirmation(lost)"
                                        disabled="@_operationInProgress"
                                        title="Delete folder permanently">
                                    Delete
                                </button>
                            }
                            else
                            {
                                @* Inline delete confirmation for lost clones *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-actions">
                                        @if (_deleteLostCloneHasChanges)
                                        {
                                            <span class="badge bg-danger me-1" title="Has uncommitted changes">has changes</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Local Branches Without Clones *@
    @{
        var branchesWithoutClones = _branches.Where(b => !b.HasClone && !IsDefaultBranch(b.ShortName)).ToList();
    }
    @if (branchesWithoutClones.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center">
            <span>Local Branches (No Clone)</span>
            <span class="badge bg-secondary">@branchesWithoutClones.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th>Last Commit</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var branch in branchesWithoutClones)
                {
                    var prInfo = GetPullRequestForBranch(branch.ShortName);
                    var deleteKey = $"branch:{branch.ShortName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@branch.ShortName</strong>
                            <span class="badges">
                                @if (branch.IsMerged)
                                {
                                    <span class="badge bg-success">merged</span>
                                }
                                @if (prInfo != null)
                                {
                                    <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                       target="_blank"
                                       class="badge bg-info text-decoration-none">
                                        PR #@prInfo.GitHubPRNumber
                                    </a>
                                }
                            </span>
                        </td>
                        <td class="commit-col">
                            @if (!string.IsNullOrEmpty(branch.LastCommitMessage))
                            {
                                <span class="commit-message" title="@branch.LastCommitMessage">@TruncateMessage(branch.LastCommitMessage)</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                <button class="btn btn-sm btn-outline-primary me-1"
                                        @onclick="() => CreateCloneForBranchAsync(branch.ShortName)"
                                        disabled="@_operationInProgress"
                                        title="Create branch clone">
                                    Start
                                </button>
                                <button class="btn btn-sm btn-outline-danger"
                                        @onclick="() => ShowDeleteBranchConfirmation(branch)"
                                        disabled="@_operationInProgress"
                                        title="Delete branch">
                                    Delete
                                </button>
                            }
                            else
                            {
                                @* Inline delete confirmation *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-options">
                                        @if (_hasRemoteBranch)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteRemoteBranch">
                                                <span class="form-check-label">Delete remote</span>
                                            </label>
                                        }
                                    </div>
                                    <div class="inline-confirm-actions">
                                        @if (!_deleteTargetIsMerged)
                                        {
                                            <span class="badge bg-warning text-dark me-1" title="This branch has not been merged">unmerged</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Remote Branches Section *@
    @if (_remoteBranches.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center">
            <span>Remote Branches (Not Local)</span>
            <span class="badge bg-secondary">@_remoteBranches.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var remoteBranch in _remoteBranches)
                {
                    <tr>
                        <td><strong class="branch-name">origin/@remoteBranch</strong></td>
                        <td class="actions-col">
                            <button class="btn btn-sm btn-outline-primary me-1"
                                    @onclick="() => CreateCloneFromRemoteAsync(remoteBranch)"
                                    disabled="@_operationInProgress"
                                    title="Create local clone from remote branch">
                                Checkout
                            </button>
                            <button class="btn btn-sm btn-outline-danger"
                                    @onclick="() => DeleteRemoteBranchAsync(remoteBranch)"
                                    disabled="@_operationInProgress"
                                    title="Delete remote branch">
                                Delete
                            </button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
</div>

<style>
    .clone-management-panel {
        font-size: 0.875rem;
    }

    .section-header {
        padding: 0.5rem 0.75rem;
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color, #dee2e6);
        border-bottom: none;
        border-radius: var(--border-radius, 0.375rem) var(--border-radius, 0.375rem) 0 0;
        font-weight: 600;
        margin-top: 1rem;
    }

    .section-header:first-of-type {
        margin-top: 0;
    }

    .wt-table {
        margin-bottom: 1rem;
        border: 1px solid var(--border-color, #dee2e6);
        border-top: none;
        border-radius: 0 0 var(--border-radius, 0.375rem) var(--border-radius, 0.375rem);
        overflow: hidden;
    }

    .wt-table thead th {
        user-select: none;
        -webkit-user-select: none;
        font-weight: 600;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        background-color: var(--bg-secondary);
        color: var(--text-secondary);
        border-bottom-width: 1px;
    }

    .branch-name {
        font-family: var(--font-family-mono, monospace);
        font-size: 0.85rem;
    }

    .badges {
        margin-left: 0.5rem;
    }

    .badges .badge {
        font-size: 0.7rem;
        margin-right: 0.25rem;
    }

    .clone-path {
        font-size: 0.75rem;
        word-break: break-all;
    }

    .commit-col {
        max-width: 300px;
    }

    .commit-message {
        font-style: italic;
        color: var(--text-muted, #6c757d);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
        max-width: 100%;
    }

    .status-col {
        white-space: nowrap;
    }

    .sync-info {
        font-size: 0.8rem;
        margin-left: 0.25rem;
    }

    .actions-col {
        white-space: nowrap;
        text-align: right;
    }

    .wt-table tbody tr:hover {
        background-color: var(--bg-hover, #f8f9fa);
    }

    .wt-table tbody tr.table-danger:hover {
        background-color: var(--bs-table-danger-bg, #f8d7da);
    }

    .inline-confirm {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    .inline-confirm-options {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .inline-confirm-options .form-check {
        margin-bottom: 0;
        font-size: 0.8rem;
    }

    .inline-confirm-actions {
        display: flex;
        align-items: center;
    }
</style>

@code {
    [Parameter] public required Project Project { get; set; }
    [Parameter] public EventCallback OnDataChanged { get; set; }

    private List<CloneInfo> _clones = [];
    private List<BranchInfo> _branches = [];
    private List<string> _remoteBranches = [];
    private List<PullRequest> _pullRequests = [];
    private List<LostCloneInfo> _lostClones = [];
    private Dictionary<string, CloneStatus> _cloneStatuses = new();
    private List<SessionSummary> _projectSessions = [];
    private bool _isLoading;
    private bool _isFetching;
    private bool _isPruning;
    private bool _isUpdatingMain;
    private bool _operationInProgress;
    private string? _errorMessage;
    private string? _successMessage;
    private HubConnection? _hubConnection;

    // Delete confirmation state
    private string? _deleteTargetKey;
    private string _deleteTargetName = "";
    private bool _deleteTargetIsMerged;
    private bool _deleteIncludesClone;
    private bool _deleteCloneOnly;
    private bool _deleteRemoteBranch;
    private bool _hasRemoteBranch;
    private bool _deleteLostCloneHasChanges;
    private CloneInfo? _deleteTargetClone;
    private BranchInfo? _deleteTargetBranch;
    private LostCloneInfo? _deleteTargetLostClone;

    private bool IsDeleteTarget(string key) => _deleteTargetKey == key;

    protected override async Task OnInitializedAsync()
    {
        await RefreshDataAsync();

        // Set up SignalR connection for real-time updates (non-blocking)
        _ = SetupSignalRConnectionAsync();
    }

    private async Task SetupSignalRConnectionAsync()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/claudecode"))
                .WithAutomaticReconnect()
                .Build();

            // Subscribe to session started events - update UI when a session becomes active
            _hubConnection.On<ClaudeSession>("SessionStarted", async (session) =>
            {
                // Only handle events for sessions in this project
                if (session.ProjectId == Project.Id)
                {
                    await InvokeAsync(async () =>
                    {
                        // Refresh session list to show new session
                        _projectSessions = await SessionStoreApi.GetProjectSessionsAsync(Project.Id);
                        StateHasChanged();
                    });
                }
            });

            // Subscribe to session status changes - refresh session data
            _hubConnection.On<string, ClaudeSessionStatus, bool>("SessionStatusChanged", async (sessionId, status, _) =>
            {
                // Check if any of our tracked sessions matches
                var matchingSession = _projectSessions.FirstOrDefault(s => s.Id == sessionId);
                if (matchingSession != null)
                {
                    await InvokeAsync(async () =>
                    {
                        // Refresh session list to get updated status
                        _projectSessions = await SessionStoreApi.GetProjectSessionsAsync(Project.Id);
                        StateHasChanged();
                    });
                }
            });

            // Subscribe to session stopped events - refresh the session list
            _hubConnection.On<string>("SessionStopped", async (sessionId) =>
            {
                // Check if any of our tracked sessions matches
                var matchingSession = _projectSessions.FirstOrDefault(s => s.Id == sessionId);
                if (matchingSession != null)
                {
                    await InvokeAsync(async () =>
                    {
                        // Refresh session list to remove stopped session
                        _projectSessions = await SessionStoreApi.GetProjectSessionsAsync(Project.Id);
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to set up SignalR connection for CloneManagementPanel");
        }
    }

    private async Task RefreshDataAsync()
    {
        _isLoading = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Load clones via HTTP API
            _clones = await CloneApi.ListClonesAsync(Project.Id);

            // Branch listing, merge status, remote branches, lost clones, and clone statuses
            // are not available via the HTTP API in WASM - initialize as empty
            _branches = [];
            _remoteBranches = [];
            _lostClones = [];
            _cloneStatuses.Clear();

            // Load pull requests for this project
            _pullRequests = await PullRequestApi.GetProjectPullRequestsAsync(Project.Id);

            // Load sessions for this project to support GetSessionForClone
            _projectSessions = await SessionStoreApi.GetProjectSessionsAsync(Project.Id);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load clone data for project {ProjectId}", Project.Id);
            _errorMessage = $"Failed to load data: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task FetchAllAsync()
    {
        _isFetching = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Fetch is not available via HTTP API in WASM
            _errorMessage = "Fetch is not available in the browser client";
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fetch: {ex.Message}";
        }
        finally
        {
            _isFetching = false;
            StateHasChanged();
        }
    }

    private async Task PruneClonesAsync()
    {
        _isPruning = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            await CloneApi.PruneClonesAsync(Project.Id);
            _successMessage = "Pruned stale clone references";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to prune: {ex.Message}";
        }
        finally
        {
            _isPruning = false;
            StateHasChanged();
        }
    }

    private CloneStatus? GetCloneStatus(string clonePath)
    {
        return _cloneStatuses.GetValueOrDefault(clonePath);
    }

    private async Task FixBranchAsync(CloneInfo clone)
    {
        if (string.IsNullOrEmpty(clone.ExpectedBranch))
        {
            _errorMessage = "No expected branch to fix";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Branch checkout is not available via HTTP API in WASM
            _errorMessage = "Branch checkout is not available in the browser client";
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fix branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task PullLatestAsync(CloneInfo clone)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            await CloneApi.PullCloneAsync(clone.Path);
            _successMessage = $"Pulled latest changes for {GetShortBranchName(clone.Branch)}";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to pull: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateCloneForBranchAsync(string branchName)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var response = await CloneApi.CreateCloneAsync(new CreateCloneRequest
            {
                ProjectId = Project.Id,
                BranchName = branchName,
                CreateBranch = false
            });

            if (response != null && !string.IsNullOrEmpty(response.Path))
            {
                _successMessage = $"Created clone for {branchName}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create clone for {branchName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to create clone: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateCloneFromRemoteAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var response = await CloneApi.CreateCloneAsync(new CreateCloneRequest
            {
                ProjectId = Project.Id,
                BranchName = remoteBranch,
                CreateBranch = false
            });

            if (response != null && !string.IsNullOrEmpty(response.Path))
            {
                _successMessage = $"Created clone for {remoteBranch}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create clone for {remoteBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to checkout remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task DeleteRemoteBranchAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Remote branch deletion is not available via HTTP API in WASM
            _errorMessage = "Remote branch deletion is not available in the browser client";
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task RepairLostCloneAsync(LostCloneInfo lost)
    {
        if (!lost.CanRepair || string.IsNullOrEmpty(lost.MatchingBranchName))
        {
            _errorMessage = "Cannot repair: no matching branch found";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Clone repair is not available via HTTP API in WASM
            _errorMessage = "Clone repair is not available in the browser client";
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to repair clone: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private void ShowDeleteLostCloneConfirmation(LostCloneInfo lost)
    {
        _deleteTargetKey = $"lost:{lost.FolderName}";
        _deleteTargetName = lost.FolderName;
        _deleteTargetIsMerged = false;
        _deleteIncludesClone = false;
        _deleteCloneOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = false;
        _deleteLostCloneHasChanges = lost.Status?.HasChanges ?? false;
        _deleteTargetClone = null;
        _deleteTargetBranch = null;
        _deleteTargetLostClone = lost;
    }

    private async Task DeleteLostCloneAsync(LostCloneInfo lost)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Lost clone folder deletion is not available via HTTP API in WASM
            _errorMessage = $"Lost clone deletion is not available in the browser client";
            HideDeleteConfirmation();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete folder: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartSessionAsync(CloneInfo clone, SessionMode mode)
    {
        var entityId = GetCloneEntityId(clone);
        var branchName = GetShortBranchName(clone.Branch);

        _operationInProgress = true;
        StateHasChanged();

        try
        {
            var session = await SessionApi.CreateSessionAsync(new CreateSessionRequest
            {
                EntityId = entityId,
                ProjectId = Project.Id,
                Mode = mode,
                Model = Project.DefaultModel ?? "sonnet",
                WorkingDirectory = clone.Path,
                SystemPrompt = $"You are working on branch: {branchName}"
            });

            if (session != null)
            {
                // Navigate to the session
                NavigationManager.NavigateTo($"/session/{session.Id}");
            }
            else
            {
                _errorMessage = "Failed to start session: no session returned";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start session for clone {ClonePath}", clone.Path);
            _errorMessage = $"Failed to start session: {ex.Message}";
            StateHasChanged();
        }
        finally
        {
            _operationInProgress = false;
        }
    }

    private async Task StartMainBranchSessionAsync(CloneInfo clone)
    {
        var entityId = GetCloneEntityId(clone);

        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Start a new blank session on the main branch without a system prompt
            var session = await SessionApi.CreateSessionAsync(new CreateSessionRequest
            {
                EntityId = entityId,
                ProjectId = Project.Id,
                Mode = SessionMode.Build,
                Model = Project.DefaultModel ?? "sonnet",
                WorkingDirectory = clone.Path,
                SystemPrompt = null
            });

            if (session != null)
            {
                // Navigate to the session
                NavigationManager.NavigateTo($"/session/{session.Id}");
            }
            else
            {
                _errorMessage = "Failed to start session: no session returned";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start main branch session for clone {ClonePath}", clone.Path);
            _errorMessage = $"Failed to start session: {ex.Message}";
            StateHasChanged();
        }
        finally
        {
            _operationInProgress = false;
        }
    }

    private async Task UpdateMainBranchAsync(CloneInfo clone)
    {
        _isUpdatingMain = true;
        _operationInProgress = true;
        _errorMessage = null;
        _successMessage = null;
        StateHasChanged();

        try
        {
            // Use fleece sync via HTTP API
            var syncResult = await FleeceSyncApi.SyncAsync(Project.Id);

            if (syncResult != null && syncResult.Success)
            {
                _successMessage = syncResult.FilesCommitted > 0
                    ? $"Updated {Project.DefaultBranch} and synced {syncResult.FilesCommitted} fleece file(s)"
                    : $"Updated {Project.DefaultBranch} to latest";
            }
            else if (syncResult != null && syncResult.RequiresPullFirst && syncResult.HasNonFleeceChanges)
            {
                // Non-fleece changes are blocking the sync - try a plain pull instead
                try
                {
                    await CloneApi.PullCloneAsync(clone.Path);
                    _successMessage = $"Updated {Project.DefaultBranch} to latest";
                }
                catch
                {
                    _errorMessage = $"Failed to update: {syncResult.ErrorMessage}";
                }
            }
            else
            {
                _errorMessage = $"Failed to update: {syncResult?.ErrorMessage ?? "Unknown error"}";
            }

            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update main branch");
            _errorMessage = $"Failed to update: {ex.Message}";
        }
        finally
        {
            _isUpdatingMain = false;
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StopSessionAsync(ClaudeSession session)
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            await SessionApi.StopSessionAsync(session.Id);
            _successMessage = "Session stopped";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to stop session: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartRebaseAgentAsync(CloneInfo clone)
    {
        // Rebase agent is not available in WASM - it requires direct server-side git operations
        _errorMessage = "Rebase agent is not available in the browser client";
        StateHasChanged();
        await Task.CompletedTask;
    }

    private void ShowDeleteCloneConfirmation(CloneInfo clone, BranchInfo? branchInfo)
    {
        var branchName = GetShortBranchName(clone.Branch);
        _deleteTargetKey = $"clone:{branchName}";
        _deleteTargetName = branchName;
        _deleteTargetIsMerged = branchInfo?.IsMerged ?? false;
        _deleteIncludesClone = true;
        _deleteCloneOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branchInfo?.Upstream != null;
        _deleteTargetClone = clone;
        _deleteTargetBranch = branchInfo;
    }

    private void ShowDeleteBranchConfirmation(BranchInfo branch)
    {
        _deleteTargetKey = $"branch:{branch.ShortName}";
        _deleteTargetName = branch.ShortName;
        _deleteTargetIsMerged = branch.IsMerged;
        _deleteIncludesClone = false;
        _deleteCloneOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branch.Upstream != null;
        _deleteTargetClone = null;
        _deleteTargetBranch = branch;
    }

    private void HideDeleteConfirmation()
    {
        _deleteTargetKey = null;
        _deleteTargetClone = null;
        _deleteTargetBranch = null;
        _deleteTargetLostClone = null;
        _deleteLostCloneHasChanges = false;
    }

    private async Task ExecuteDeleteAsync()
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Handle lost clone deletion
            if (_deleteTargetLostClone != null)
            {
                await DeleteLostCloneAsync(_deleteTargetLostClone);
                return;
            }

            var branchName = _deleteTargetBranch?.ShortName ?? GetShortBranchName(_deleteTargetClone?.Branch);

            // Stop any active session first
            if (_deleteTargetClone != null)
            {
                var session = GetSessionForClone(_deleteTargetClone);
                if (session != null)
                {
                    await SessionApi.StopSessionAsync(session.Id);
                }

                // Remove the clone via HTTP API
                await CloneApi.DeleteCloneAsync(Project.Id, _deleteTargetClone.Path);
            }

            // Note: Local and remote branch deletion is not available via HTTP API in WASM.
            // Only clone removal is supported.
            if (!_deleteCloneOnly && !string.IsNullOrEmpty(branchName))
            {
                Logger.LogWarning("Branch deletion is not available in the browser client. Only clone was removed.");
            }

            _successMessage = _deleteCloneOnly
                ? $"Removed clone for {branchName}"
                : $"Removed clone for {branchName} (branch deletion not available in browser)";

            HideDeleteConfirmation();
            await RefreshDataAsync();
            await OnDataChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Delete failed: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private ClaudeSession? GetSessionForClone(CloneInfo clone)
    {
        var entityId = GetCloneEntityId(clone);
        // Find session by entity ID from the cached project sessions
        var summary = _projectSessions.FirstOrDefault(s => s.EntityId == entityId
            && s.Status is ClaudeSessionStatus.Running or ClaudeSessionStatus.WaitingForInput or ClaudeSessionStatus.Starting);
        if (summary == null) return null;
        // Map SessionSummary to a minimal ClaudeSession for use in the template
        return new ClaudeSession
        {
            Id = summary.Id,
            EntityId = summary.EntityId,
            ProjectId = summary.ProjectId,
            WorkingDirectory = "",
            Model = summary.Model,
            Mode = summary.Mode,
            Status = summary.Status
        };
    }

    private string GetCloneEntityId(CloneInfo clone)
    {
        // Use the branch name as the entity ID for session tracking
        var branchName = GetShortBranchName(clone.Branch);
        return $"clone:{branchName}";
    }

    private PullRequest? GetPullRequestForBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return null;
        return _pullRequests.FirstOrDefault(pr => pr.BranchName == branchName);
    }

    private static string GetShortBranchName(string? branch)
    {
        if (string.IsNullOrEmpty(branch)) return "unknown";
        return branch.Replace("refs/heads/", "");
    }

    private bool IsDefaultBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return false;
        return branchName == Project.DefaultBranch;
    }

    private static string TruncateMessage(string? message, int maxLength = 60)
    {
        if (string.IsNullOrEmpty(message)) return "";
        return message.Length <= maxLength ? message : message[..(maxLength - 3)] + "...";
    }

    private static string GetSessionStatusBadgeClass(ClaudeSessionStatus status) => status switch
    {
        ClaudeSessionStatus.Running => "bg-success",
        ClaudeSessionStatus.WaitingForInput => "bg-info",
        ClaudeSessionStatus.Starting => "bg-warning text-dark",
        ClaudeSessionStatus.Stopped => "bg-secondary",
        ClaudeSessionStatus.Error => "bg-danger",
        _ => "bg-secondary"
    };

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}
