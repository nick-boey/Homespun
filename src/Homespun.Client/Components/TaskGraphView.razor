@using Homespun.Shared.Models.Fleece
@using Homespun.Shared.Models.Gitgraph
@using Homespun.Shared.Models.Sessions
@using Homespun.Client.Services
@using Homespun.Shared.Requests
@using Homespun.Shared.Utilities
@using Fleece.Core.Models
@inject HttpIssueApiService IssueApi

@if (TaskGraph != null && (_renderLines.Count > 0 || TaskGraph.MergedPrs.Count > 0))
{
    <div class="task-graph"
         tabindex="0"
         @onkeydown="HandleKeyDown"
         @onkeydown:preventDefault="_isCreatingInline"
         data-testid="task-graph">
        @for (var i = 0; i < _renderLines.Count; i++)
        {
            var line = _renderLines[i];
            @if (line is TaskGraphLoadMoreRenderLine)
            {
                <div class="task-graph-row task-graph-load-more" @onclick="HandleLoadMoreClick">
                    <div class="task-graph-graph-cell">
                        @((MarkupString)GenerateLoadMoreSvg())
                    </div>
                    <div class="task-graph-content-cell">
                        <span class="task-graph-load-more-text">Load more PRs</span>
                    </div>
                </div>
            }
            else if (line is TaskGraphPrRenderLine prLine)
            {
                var isSelected = SelectedNodeId == $"pr-{prLine.PrNumber}";
                <div class="task-graph-row @(isSelected ? "task-graph-row-selected" : "")"
                     @onclick="() => HandlePrClick(prLine.Url)">
                    <div class="task-graph-graph-cell">
                        @((MarkupString)GeneratePrSvg(prLine))
                    </div>
                    <div class="task-graph-content-cell">
                        <span class="task-graph-pr-badge @(prLine.IsMerged ? "merged" : "closed")">
                            #@prLine.PrNumber
                        </span>
                        <span class="task-graph-title">@prLine.Title</span>
                        @if (prLine.AgentStatus != null)
                        {
                            <span class="agent-status-badge @GetAgentStatusClass(prLine.AgentStatus)">
                                <span class="agent-status-dot @(prLine.AgentStatus.IsActive ? "agent-status-dot-active" : "")"></span>
                                @GetAgentStatusLabel(prLine.AgentStatus)
                            </span>
                        }
                    </div>
                </div>
            }
            else if (line is TaskGraphIssueRenderLine issueLine)
            {
                @* Insert new issue before this issue if needed (for inserting above first issue) *@
                @if (NavService?.EditMode == KeyboardEditMode.CreatingNew
                    && NavService?.PendingNewIssue != null
                    && NavService.PendingNewIssue.IsAbove
                    && NavService.PendingNewIssue.ReferenceIssueId == issueLine.IssueId)
                {
                    <div class="task-graph-row task-graph-row-selected task-graph-row-editing">
                        <div class="task-graph-graph-cell">
                            @((MarkupString)GenerateNewIssueSvg(issueLine.Lane))
                        </div>
                        <div class="task-graph-content-cell">
                            <span class="task-graph-issue-type task">Task</span>
                            <span class="task-graph-issue-id task-graph-issue-id-new">NEW</span>
                            <InlineIssueEditor Title="@NavService.PendingNewIssue.Title"
                                               CursorPosition="EditCursorPosition.Start"
                                               Placeholder="Enter new issue title..." />
                        </div>
                    </div>
                }

                var isSelected = SelectedNodeId == $"issue-{issueLine.IssueId}";
                var agentStatus = issueLine.AgentStatus;
                var index = i;
                var isEditing = NavService?.EditMode == KeyboardEditMode.EditingExisting
                    && NavService?.PendingEdit?.IssueId == issueLine.IssueId;

                @* Show inline create above this issue if creating above selected *@
                @if (_isCreatingInline && _inlineCreateAbove && issueLine.IssueId == _selectedIssueIdForCreate)
                {
                    var aboveParentInfo = GetInheritedParentInfo(issueLine.IssueId, insertAbove: true);
                    <InlineIssueCreateInput ProjectId="@ProjectId"
                                            InsertIndex="@index"
                                            InsertAbove="true"
                                            AdjacentIssueId="@GetAdjacentIssueId(index, true)"
                                            CanMoveUp="@CanMoveUp(index, true)"
                                            CanMoveDown="@CanMoveDown(index, true)"
                                            InheritedParentIssueId="@aboveParentInfo.ParentId"
                                            InheritedParentSortOrder="@aboveParentInfo.SortOrder"
                                            OnCancel="CancelInlineCreate"
                                            OnCreated="HandleInlineIssueCreated" />
                }

                <div class="task-graph-row @(isSelected ? "task-graph-row-selected" : "") @(isEditing ? "task-graph-row-editing" : "")"
                     @onclick="() => HandleIssueClick(issueLine.IssueId)"
                     data-testid="task-graph-issue-row"
                     data-issue-id="@issueLine.IssueId">
                    <div class="task-graph-graph-cell">
                        @((MarkupString)GenerateIssueSvg(index, issueLine, agentStatus))
                    </div>
                    <div class="task-graph-content-cell">
                        <div class="task-graph-issue-type-wrapper">
                            <span class="task-graph-issue-type @GetIssueTypeClass(issueLine.IssueType)"
                                  @onclick="() => ToggleTypeMenu(issueLine.IssueId)"
                                  @onclick:stopPropagation="true"
                                  title="Click to change type">@GetIssueTypeLabel(issueLine.IssueType)</span>
                            @if (_typeMenuOpenForIssueId == issueLine.IssueId)
                            {
                                <div class="task-graph-type-menu" @onclick:stopPropagation="true">
                                    <button class="type-menu-item bug" @onclick="() => ChangeIssueType(issueLine.IssueId, IssueType.Bug)">Bug</button>
                                    <button class="type-menu-item task" @onclick="() => ChangeIssueType(issueLine.IssueId, IssueType.Task)">Task</button>
                                    <button class="type-menu-item feature" @onclick="() => ChangeIssueType(issueLine.IssueId, IssueType.Feature)">Feature</button>
                                    <button class="type-menu-item chore" @onclick="() => ChangeIssueType(issueLine.IssueId, IssueType.Chore)">Chore</button>
                                </div>
                            }
                        </div>
                        <span class="task-graph-issue-id">@issueLine.IssueId</span>
                        @if (isEditing && NavService?.PendingEdit != null)
                        {
                            <InlineIssueEditor Title="@NavService.PendingEdit.Title"
                                               CursorPosition="@NavService.PendingEdit.CursorPosition"
                                               Placeholder="Enter issue title..." />
                        }
                        else
                        {
                            <span class="task-graph-title">@issueLine.Title</span>
                        }
                        @if (issueLine.LinkedPr != null && !isEditing)
                        {
                            <a class="task-graph-pr-link" href="@issueLine.LinkedPr.Url" target="_blank" @onclick:stopPropagation="true">
                                #@issueLine.LinkedPr.Number
                            </a>
                        }
                        @if (agentStatus != null && !isEditing)
                        {
                            <span class="agent-status-badge @GetAgentStatusClass(agentStatus)">
                                <span class="agent-status-dot @(agentStatus.IsActive ? "agent-status-dot-active" : "")"></span>
                                @GetAgentStatusLabel(agentStatus)
                            </span>
                        }
                        @if (!isEditing && !string.IsNullOrEmpty(ProjectId))
                        {
                            <IssueRowActions IssueId="@issueLine.IssueId"
                                             ProjectId="@ProjectId"
                                             IsVisible="@isSelected"
                                             Disabled="@(agentStatus?.IsActive == true)"
                                             OnEditClick="HandleEditClick"
                                             OnRunAgentClick="HandleRunAgentClick" />
                        }
                    </div>
                </div>

                @* Show inline create below this issue if creating below selected *@
                @if (_isCreatingInline && !_inlineCreateAbove && issueLine.IssueId == _selectedIssueIdForCreate)
                {
                    var belowParentInfo = GetInheritedParentInfo(issueLine.IssueId, insertAbove: false);
                    <InlineIssueCreateInput ProjectId="@ProjectId"
                                            InsertIndex="@(index + 1)"
                                            InsertAbove="false"
                                            AdjacentIssueId="@GetAdjacentIssueId(index, false)"
                                            CanMoveUp="@CanMoveUp(index, false)"
                                            CanMoveDown="@CanMoveDown(index, false)"
                                            InheritedParentIssueId="@belowParentInfo.ParentId"
                                            InheritedParentSortOrder="@belowParentInfo.SortOrder"
                                            OnCancel="CancelInlineCreate"
                                            OnCreated="HandleInlineIssueCreated" />
                }
            }
            else if (line is TaskGraphSeparatorRenderLine)
            {
                <div class="task-graph-divider">
                    <div class="task-graph-graph-cell">
                        @((MarkupString)GenerateDividerSvg())
                    </div>
                    <div class="task-graph-divider-content">
                        <hr class="task-graph-divider-line" />
                        <span class="task-graph-divider-label">Issues</span>
                    </div>
                </div>
            }

            @* Insert new issue row when creating inline via NavService (not TaskGraphView's own inline creation) *@
            @if (!_isCreatingInline
                && NavService?.EditMode == KeyboardEditMode.CreatingNew
                && NavService?.PendingNewIssue != null
                && line is TaskGraphIssueRenderLine currentIssue
                && ShouldInsertNewIssueAfter(currentIssue.IssueId))
            {
                <div class="task-graph-row task-graph-row-selected task-graph-row-editing">
                    <div class="task-graph-graph-cell">
                        @((MarkupString)GenerateNewIssueSvg(currentIssue.Lane))
                    </div>
                    <div class="task-graph-content-cell">
                        <span class="task-graph-issue-type task">Task</span>
                        <span class="task-graph-issue-id task-graph-issue-id-new">NEW</span>
                        <InlineIssueEditor Title="@NavService.PendingNewIssue.Title"
                                           CursorPosition="EditCursorPosition.Start"
                                           Placeholder="Enter new issue title..." />
                    </div>
                </div>
            }
        }

        @* Handle new issue at the end of the list (not TaskGraphView's own inline creation) *@
        @if (!_isCreatingInline
            && NavService?.EditMode == KeyboardEditMode.CreatingNew
            && NavService?.PendingNewIssue != null
            && ShouldInsertNewIssueAtEnd())
        {
            <div class="task-graph-row task-graph-row-selected task-graph-row-editing">
                <div class="task-graph-graph-cell">
                    @((MarkupString)GenerateNewIssueSvg(0))
                </div>
                <div class="task-graph-content-cell">
                    <span class="task-graph-issue-type task">Task</span>
                    <span class="task-graph-issue-id task-graph-issue-id-new">NEW</span>
                    <InlineIssueEditor Title="@NavService.PendingNewIssue.Title"
                                       CursorPosition="EditCursorPosition.Start"
                                       Placeholder="Enter new issue title..." />
                </div>
            </div>
        }
    </div>
}

<style>
    .task-graph {
        display: flex;
        flex-direction: column;
    }

    .task-graph-row {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: center;
        min-height: 40px;
        cursor: pointer;
        transition: background-color 0.15s ease;
    }

    .task-graph-row:hover {
        background-color: var(--bg-secondary, rgba(255, 255, 255, 0.05));
    }

    .task-graph-row-selected {
        background-color: var(--bg-secondary, rgba(255, 255, 255, 0.1));
    }

    .task-graph-row-selected .task-graph-graph-cell svg circle[fill]:not([fill="none"]),
    .task-graph-row-selected .task-graph-graph-cell svg path[fill]:not([fill="none"]) {
        filter: drop-shadow(0 0 4px var(--color-ocean, #51A5C1));
    }

    /* Show issue row actions on hover */
    .task-graph-row:hover .issue-row-actions {
        opacity: 1;
    }

    /* Keep actions visible on selected row */
    .task-graph-row-selected .issue-row-actions {
        opacity: 1;
    }

    .task-graph-graph-cell {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        flex-shrink: 0;
    }

    .task-graph-graph-cell svg {
        display: block;
    }

    .task-graph-content-cell {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.25rem 0.75rem 0.25rem 0.5rem;
        overflow: hidden;
    }

    .task-graph-issue-id {
        flex-shrink: 0;
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono, monospace);
        background-color: var(--bg-tertiary, rgba(255, 255, 255, 0.08));
        color: var(--text-secondary, #a0a0a0);
        border: 1px solid var(--border-color, rgba(255, 255, 255, 0.1));
    }

    .task-graph-title {
        color: var(--text-primary, #eaeaea);
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        min-width: 0;
    }

    .task-graph-separator {
        height: 8px;
    }

    /* Issue type badge */
    .task-graph-issue-type {
        flex-shrink: 0;
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .task-graph-issue-type.bug {
        background-color: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid #ef4444;
    }

    .task-graph-issue-type.task {
        background-color: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
    }

    .task-graph-issue-type.feature {
        background-color: rgba(16, 185, 129, 0.2);
        color: #10b981;
        border: 1px solid #10b981;
    }

    .task-graph-issue-type.chore {
        background-color: rgba(107, 114, 128, 0.2);
        color: #6b7280;
        border: 1px solid #6b7280;
    }

    /* PR badge */
    .task-graph-pr-badge {
        flex-shrink: 0;
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono, monospace);
    }

    .task-graph-pr-badge.merged {
        background-color: rgba(139, 92, 246, 0.2);
        color: #8b5cf6;
        border: 1px solid #8b5cf6;
    }

    .task-graph-pr-badge.closed {
        background-color: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid #ef4444;
    }

    /* PR link on issues */
    .task-graph-pr-link {
        flex-shrink: 0;
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono, monospace);
        background-color: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
        text-decoration: none;
        transition: background-color 0.15s ease;
    }

    .task-graph-pr-link:hover {
        background-color: rgba(59, 130, 246, 0.4);
    }

    /* Load more button */
    .task-graph-load-more {
        cursor: pointer;
    }

    .task-graph-load-more-text {
        color: var(--color-ocean, #51A5C1);
        font-weight: 600;
        font-size: 14px;
    }

    /* Agent status badge */
    .agent-status-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
        flex-shrink: 0;
    }

    .agent-status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background-color: currentColor;
    }

    .agent-status-dot-active {
        animation: agent-pulse 1.5s ease-in-out infinite;
    }

    @@keyframes agent-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
    }

    .agent-status-running {
        background-color: rgba(16, 185, 129, 0.2);
        color: #10b981;
        border: 1px solid #10b981;
    }

    .agent-status-waiting {
        background-color: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
    }

    .agent-status-starting {
        background-color: rgba(245, 158, 11, 0.2);
        color: #f59e0b;
        border: 1px solid #f59e0b;
    }

    .agent-status-error {
        background-color: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid #ef4444;
    }

    .agent-status-inactive {
        background-color: rgba(107, 114, 128, 0.2);
        color: #6b7280;
        border: 1px solid #6b7280;
    }

    /* Divider row */
    .task-graph-divider {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: center;
        min-height: 40px;
    }

    .task-graph-divider-content {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 1rem 0.5rem 0.5rem;
    }

    .task-graph-divider-line {
        flex: 1;
        border: none;
        border-top: 1px solid var(--text-muted, #6c757d);
        margin: 0;
    }

    .task-graph-divider-label {
        flex-shrink: 0;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted, #6c757d);
        white-space: nowrap;
    }

    /* Editing row styles */
    .task-graph-row-editing {
        background-color: var(--bg-secondary, rgba(255, 255, 255, 0.1));
    }

    .task-graph-issue-id-new {
        background-color: rgba(81, 165, 193, 0.2);
        color: var(--color-ocean, #51A5C1);
        border-color: var(--color-ocean, #51A5C1);
    }

    /* Issue type wrapper for dropdown positioning */
    .task-graph-issue-type-wrapper {
        position: relative;
        flex-shrink: 0;
    }

    .task-graph-issue-type {
        cursor: pointer;
        transition: filter 0.15s ease;
    }

    .task-graph-issue-type:hover {
        filter: brightness(1.2);
    }

    /* Type change dropdown menu */
    .task-graph-type-menu {
        position: absolute;
        top: 100%;
        left: 0;
        z-index: 100;
        background: var(--bg-primary, #1a1a2e);
        border: 1px solid var(--border-color, rgba(255, 255, 255, 0.1));
        border-radius: 4px;
        padding: 4px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-width: 80px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        margin-top: 4px;
    }

    .type-menu-item {
        padding: 4px 8px;
        border: none;
        border-radius: 3px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        cursor: pointer;
        text-align: left;
        transition: filter 0.15s ease;
    }

    .type-menu-item:hover {
        filter: brightness(1.2);
    }

    .type-menu-item.bug {
        background-color: rgba(239, 68, 68, 0.2);
        color: #ef4444;
    }

    .type-menu-item.task {
        background-color: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
    }

    .type-menu-item.feature {
        background-color: rgba(16, 185, 129, 0.2);
        color: #10b981;
    }

    .type-menu-item.chore {
        background-color: rgba(107, 114, 128, 0.2);
        color: #6b7280;
    }
</style>

@code {
    [Parameter] public TaskGraphResponse? TaskGraph { get; set; }
    [Parameter] public EventCallback<string> OnIssueClick { get; set; }
    [Parameter] public EventCallback OnLoadMoreClick { get; set; }
    [Parameter] public EventCallback OnIssueTypeChanged { get; set; }
    [Parameter] public string? SelectedNodeId { get; set; }
    [Parameter] public IKeyboardNavigationService? NavService { get; set; }

    /// <summary>
    /// The project ID for creating issues. Required when EnableKeyboardControls is true.
    /// </summary>
    [Parameter] public string? ProjectId { get; set; }

    /// <summary>
    /// When true (default), enables keyboard controls for issue creation:
    /// - 'o': Create issue below selected
    /// - 'O' (Shift+o): Create issue above selected
    /// </summary>
    [Parameter] public bool EnableKeyboardControls { get; set; } = true;

    /// <summary>
    /// Called when an issue is created via inline keyboard creation.
    /// </summary>
    [Parameter] public EventCallback<string> OnIssueCreated { get; set; }

    /// <summary>
    /// Called when the edit button is clicked on an issue row.
    /// </summary>
    [Parameter] public EventCallback<string> OnEditClick { get; set; }

    /// <summary>
    /// Called when an agent is started on an issue via the inline run agent button.
    /// </summary>
    [Parameter] public EventCallback<(string IssueId, AgentPrompt? Prompt)> OnRunAgentClick { get; set; }

    private List<TaskGraphRenderLine> _renderLines = [];
    private int _maxLane;
    private string? _typeMenuOpenForIssueId;

    // Inline creation state
    private bool _isCreatingInline;
    private bool _inlineCreateAbove;
    private string? _selectedIssueIdForCreate;

    protected override void OnParametersSet()
    {
        _renderLines = TaskGraphLayoutService.ComputeLayout(TaskGraph);
        var hasMergedPrs = TaskGraph?.MergedPrs.Count > 0;
        _maxLane = _renderLines
            .OfType<TaskGraphIssueRenderLine>()
            .Select(l => Math.Max(l.Lane, l.ParentLane ?? 0))
            .DefaultIfEmpty(hasMergedPrs ? 1 : 0)  // Account for lane offset when PRs exist
            .Max();

        // Cancel inline create if selection changes
        if (_isCreatingInline && SelectedNodeId != $"issue-{_selectedIssueIdForCreate}")
        {
            _isCreatingInline = false;
            _selectedIssueIdForCreate = null;
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (!EnableKeyboardControls || string.IsNullOrEmpty(ProjectId)) return;
        if (_isCreatingInline) return; // Already creating, ignore

        // Get the selected issue ID from SelectedNodeId (format: "issue-{id}")
        if (SelectedNodeId?.StartsWith("issue-") != true) return;
        var selectedIssueId = SelectedNodeId[6..];

        // Find the selected issue in the render lines
        var selectedIndex = _renderLines.FindIndex(l =>
            l is TaskGraphIssueRenderLine irl && irl.IssueId == selectedIssueId);
        if (selectedIndex < 0) return;

        switch (e.Key)
        {
            case "o" when !e.ShiftKey:
                // Create below
                _isCreatingInline = true;
                _inlineCreateAbove = false;
                _selectedIssueIdForCreate = selectedIssueId;
                StateHasChanged();
                break;

            case "O" when e.ShiftKey:
            case "o" when e.ShiftKey:
                // Create above (Shift+O or Shift+o)
                _isCreatingInline = true;
                _inlineCreateAbove = true;
                _selectedIssueIdForCreate = selectedIssueId;
                StateHasChanged();
                break;
        }
    }

    private void CancelInlineCreate()
    {
        _isCreatingInline = false;
        _selectedIssueIdForCreate = null;
        StateHasChanged();
    }

    private async Task HandleInlineIssueCreated(string newIssueId)
    {
        _isCreatingInline = false;
        _selectedIssueIdForCreate = null;

        // Notify parent to refresh and select the new issue
        await OnIssueCreated.InvokeAsync(newIssueId);
    }

    /// <summary>
    /// Gets inherited parent info from the reference issue for sibling creation.
    /// When the reference issue has a parent, the new sibling should inherit that parent.
    /// For series-mode parents, computes an appropriate sort order between adjacent siblings.
    /// </summary>
    private (string? ParentId, string? SortOrder) GetInheritedParentInfo(string issueId, bool insertAbove)
    {
        if (TaskGraph == null) return (null, null);

        // Find the reference issue in the task graph nodes
        var node = TaskGraph.Nodes.FirstOrDefault(n => n.Issue.Id == issueId);
        if (node == null || node.Issue.ParentIssues.Count == 0)
        {
            return (null, null);
        }

        // Take the first parent
        var parentRef = node.Issue.ParentIssues[0];
        var parentId = parentRef.ParentIssue;
        var refSortOrder = parentRef.SortOrder;

        // Find all siblings under the same parent, sorted by sort order
        var siblings = TaskGraph.Nodes
            .Where(n => n.Issue.ParentIssues.Any(p => p.ParentIssue == parentId))
            .Select(n => new
            {
                n.Issue.Id,
                SortOrder = n.Issue.ParentIssues.First(p => p.ParentIssue == parentId).SortOrder ?? "0"
            })
            .OrderBy(s => s.SortOrder, StringComparer.Ordinal)
            .ToList();

        var refIndex = siblings.FindIndex(s => s.Id == issueId);
        if (refIndex < 0) return (parentId, refSortOrder);

        string? sortOrder;
        if (insertAbove)
        {
            // Creating above: midpoint between previous sibling and reference
            var prevSortOrder = refIndex > 0 ? siblings[refIndex - 1].SortOrder : null;
            sortOrder = LexOrderUtils.ComputeMidpoint(prevSortOrder, siblings[refIndex].SortOrder);
        }
        else
        {
            // Creating below: midpoint between reference and next sibling
            var nextSortOrder = refIndex < siblings.Count - 1 ? siblings[refIndex + 1].SortOrder : null;
            sortOrder = LexOrderUtils.ComputeMidpoint(siblings[refIndex].SortOrder, nextSortOrder);
        }

        return (parentId, sortOrder);
    }

    /// <summary>
    /// Gets the adjacent issue ID for parent/child relationship.
    /// When creating above: the issue below becomes the adjacent (for making new issue its parent or child)
    /// When creating below: the issue above becomes the adjacent
    /// </summary>
    private string? GetAdjacentIssueId(int currentIndex, bool insertAbove)
    {
        // The adjacent issue is the one that was selected (current row)
        var currentLine = _renderLines[currentIndex];
        if (currentLine is TaskGraphIssueRenderLine issueLine)
        {
            return issueLine.IssueId;
        }
        return null;
    }

    /// <summary>
    /// Returns true if TAB (move up lane / become parent) is allowed.
    /// TAB is allowed when there's an adjacent issue to become parent of.
    /// </summary>
    private bool CanMoveUp(int currentIndex, bool insertAbove)
    {
        // Can always make the new issue a parent of the adjacent issue
        return GetAdjacentIssueId(currentIndex, insertAbove) != null;
    }

    /// <summary>
    /// Returns true if Shift+TAB (move down lane / become child) is allowed.
    /// Shift+TAB is allowed when there's an adjacent issue to become child of.
    /// </summary>
    private bool CanMoveDown(int currentIndex, bool insertAbove)
    {
        // Can always make the new issue a child of the adjacent issue
        return GetAdjacentIssueId(currentIndex, insertAbove) != null;
    }

    private string GenerateIssueSvg(int index, TaskGraphIssueRenderLine issueLine, AgentStatusData? agentStatus)
    {
        var (color, isOutlineOnly) = ComputeTaskGraphNodeStyle(issueLine, agentStatus);

        return TimelineSvgRenderer.GenerateTaskGraphCircleSvg(
            nodeLane: issueLine.Lane,
            parentLane: issueLine.ParentLane,
            isFirstChild: issueLine.IsFirstChild,
            maxLanes: _maxLane + 1,
            nodeColor: color,
            isOutlineOnly: isOutlineOnly,
            isActionable: issueLine.Marker == TaskGraphMarkerType.Actionable,
            drawTopLine: issueLine.DrawTopLine,
            drawBottomLine: issueLine.DrawBottomLine,
            isSeriesChild: issueLine.IsSeriesChild,
            seriesConnectorFromLane: issueLine.SeriesConnectorFromLane,
            drawLane0Connector: issueLine.DrawLane0Connector,
            isLastLane0Connector: issueLine.IsLastLane0Connector,
            drawLane0PassThrough: issueLine.DrawLane0PassThrough);
    }

    private string GeneratePrSvg(TaskGraphPrRenderLine prLine)
    {
        var color = prLine.IsMerged ? "#8b5cf6" : "#ef4444"; // purple for merged, red for closed
        var isOutlineOnly = !prLine.HasDescription;

        return TimelineSvgRenderer.GenerateTaskGraphCircleSvg(
            nodeLane: 0,
            parentLane: null,
            isFirstChild: false,
            maxLanes: _maxLane + 1,
            nodeColor: color,
            isOutlineOnly: isOutlineOnly,
            isActionable: false,
            drawTopLine: prLine.DrawTopLine,
            drawBottomLine: prLine.DrawBottomLine,
            isSeriesChild: false,
            seriesConnectorFromLane: null);
    }

    private string GenerateLoadMoreSvg()
    {
        return TimelineSvgRenderer.GenerateTaskGraphLoadMoreSvg(_maxLane + 1);
    }

    private string GenerateDividerSvg()
    {
        return TimelineSvgRenderer.GenerateDividerRowSvg(_maxLane + 1);
    }

    private string GenerateNewIssueSvg(int lane)
    {
        // New issue uses task color (blue) and is placed in the same lane as the selected issue
        return TimelineSvgRenderer.GenerateTaskGraphCircleSvg(
            nodeLane: lane,
            parentLane: null,
            isFirstChild: false,
            maxLanes: _maxLane + 1,
            nodeColor: "#3b82f6", // Blue (task color)
            isOutlineOnly: true, // Outline only for new issue
            isActionable: lane == 0,
            drawTopLine: true,
            drawBottomLine: false,
            isSeriesChild: false,
            seriesConnectorFromLane: null);
    }

    private bool ShouldInsertNewIssueAfter(string issueId)
    {
        if (NavService?.PendingNewIssue == null) return false;

        // Only check for inserting below (above case is handled separately in the render loop)
        if (!NavService.PendingNewIssue.IsAbove &&
            NavService.PendingNewIssue.ReferenceIssueId == issueId)
        {
            return true;
        }

        return false;
    }

    private bool ShouldInsertNewIssueAtEnd()
    {
        if (NavService?.PendingNewIssue == null) return false;

        // Check if we should insert at the start (above first issue)
        if (NavService.PendingNewIssue.IsAbove)
        {
            var issueLines = _renderLines.OfType<TaskGraphIssueRenderLine>().ToList();
            if (issueLines.Count > 0 &&
                issueLines[0].IssueId == NavService.PendingNewIssue.ReferenceIssueId)
            {
                // Need to insert at the beginning, but there's no issue before it
                // This case is handled specially in the render loop
                return false;
            }
        }

        // Insert at end if reference issue is the last one and we're inserting below
        if (!NavService.PendingNewIssue.IsAbove)
        {
            var issueLines = _renderLines.OfType<TaskGraphIssueRenderLine>().ToList();
            if (issueLines.Count > 0 &&
                issueLines[^1].IssueId == NavService.PendingNewIssue.ReferenceIssueId)
            {
                return true;
            }
        }

        return false;
    }

    private static (string color, bool isOutlineOnly) ComputeTaskGraphNodeStyle(
        TaskGraphIssueRenderLine issueLine, AgentStatusData? agentStatus)
    {
        // Default color based on issue type
        var color = GetIssueTypeColor(issueLine.IssueType);
        var isOutlineOnly = !issueLine.HasDescription;

        // Agent status overrides color when active
        if (agentStatus is { IsActive: true })
        {
            color = agentStatus.Status switch
            {
                "Running" or "Starting" or "RunningHooks" => "#22c55e",       // Green - working
                "WaitingForInput" or "WaitingForPlanExecution" => "#eab308",   // Yellow - waiting
                "WaitingForQuestionAnswer" => "#f97316",                       // Orange - question
                "Error" => "#ef4444",                                          // Red - error
                _ => color                                                     // Use issue type color for unknown statuses
            };
            isOutlineOnly = false; // Active agents always have filled circles
        }

        return (color, isOutlineOnly);
    }

    private static string GetIssueTypeColor(IssueType type) => type switch
    {
        IssueType.Bug => "#ef4444",     // Red
        IssueType.Feature => "#10b981", // Green
        IssueType.Task => "#3b82f6",    // Blue
        IssueType.Chore => "#6b7280",   // Gray
        _ => "#6b7280"
    };

    private static string GetIssueTypeClass(IssueType type) => type switch
    {
        IssueType.Bug => "bug",
        IssueType.Feature => "feature",
        IssueType.Task => "task",
        IssueType.Chore => "chore",
        _ => "task"
    };

    private static string GetIssueTypeLabel(IssueType type) => type switch
    {
        IssueType.Bug => "Bug",
        IssueType.Feature => "Feat",
        IssueType.Task => "Task",
        IssueType.Chore => "Chore",
        _ => "Task"
    };

    private static string GetAgentStatusClass(AgentStatusData agentStatus)
    {
        if (!agentStatus.IsActive) return "agent-status-inactive";

        return agentStatus.Status switch
        {
            "Running" => "agent-status-running",
            "WaitingForInput" => "agent-status-waiting",
            "Starting" => "agent-status-starting",
            "Error" => "agent-status-error",
            _ => "agent-status-inactive"
        };
    }

    private static string GetAgentStatusLabel(AgentStatusData agentStatus)
    {
        return agentStatus.Status switch
        {
            "Running" => "Working",
            "WaitingForInput" => "Waiting",
            "Starting" => "Starting",
            "Error" => "Error",
            "Stopped" => "Stopped",
            _ => agentStatus.Status
        };
    }

    private async Task HandleIssueClick(string issueId)
    {
        await OnIssueClick.InvokeAsync(issueId);
    }

    private async Task HandleEditClick(string issueId)
    {
        await OnEditClick.InvokeAsync(issueId);
    }

    private async Task HandleRunAgentClick((string IssueId, AgentPrompt? Prompt) args)
    {
        await OnRunAgentClick.InvokeAsync(args);
    }

    private async Task HandleLoadMoreClick()
    {
        await OnLoadMoreClick.InvokeAsync();
    }

    private void HandlePrClick(string? url)
    {
        // PR clicks navigate to GitHub - handled by href on the row
        // This is a no-op but could be extended for internal PR handling
    }

    private void ToggleTypeMenu(string issueId)
    {
        if (_typeMenuOpenForIssueId == issueId)
        {
            _typeMenuOpenForIssueId = null;
        }
        else
        {
            _typeMenuOpenForIssueId = issueId;
        }
    }

    private async Task ChangeIssueType(string issueId, IssueType newType)
    {
        if (string.IsNullOrEmpty(ProjectId)) return;

        // Close the menu
        _typeMenuOpenForIssueId = null;

        // Update the issue type via API
        await IssueApi.UpdateIssueAsync(issueId, new UpdateIssueRequest
        {
            ProjectId = ProjectId,
            Type = newType
        });

        // Notify parent to refresh data
        await OnIssueTypeChanged.InvokeAsync();
    }
}
