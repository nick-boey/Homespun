@using Microsoft.AspNetCore.SignalR.Client
@using Homespun.Shared.Models.Fleece
@using Homespun.Shared.Models.Sessions
@using Homespun.Client.Services
@inject HttpGraphApiService GraphApi
@inject NavigationManager NavigationManager
@inject IKeyboardNavigationService NavService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="timeline-wrapper" @ref="_timelineWrapper">
    @if (_isLoading)
    {
        <div class="timeline-loading">
            <span class="spinner-border spinner-border-sm" role="status"></span>
            <span>Loading timeline...</span>
        </div>
    }
    else if (_error != null)
    {
        <div class="timeline-error">
            <span>Failed to load timeline: @_error</span>
        </div>
    }
    else if (_taskGraphData != null)
    {
        <div class="timeline-container">
            <TaskGraphView @ref="_taskGraphViewRef"
                TaskGraph="@_taskGraphData"
                ProjectId="@ProjectId"
                OnIssueClick="HandleTaskGraphIssueClick"
                OnLoadMoreClick="LoadMoreTaskGraphPRs"
                OnIssueCreated="HandleIssueCreated"
                OnIssueTypeChanged="HandleIssueChangedAsync"
                OnIssueStatusChanged="HandleIssueChangedAsync"
                OnEditClick="OnEditClick"
                OnRunAgentClick="OnRunAgentClick"
                OnOpenPanelClick="OnOpenPanelClick"
                SelectedNodeId="@GetKeyboardSelectedNodeId()"
                NavService="@NavService"
                MaxDepth="@_maxDepth"
                MaxDepthChanged="HandleMaxDepthChanged"
                ActiveSearchTerm="@ActiveSearchTerm" />
        </div>
    }
</div>

@if (NavService.EditMode != KeyboardEditMode.Viewing)
{
    <div class="keyboard-mode-indicator">-- INSERT --</div>
}

<style>
    .timeline-wrapper {
        width: 100%;
        min-height: 200px;
    }

    .timeline-container {
        display: flex;
        flex-direction: column;
        gap: 0;
    }

    .timeline-loading,
    .timeline-error {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        color: var(--text-secondary);
    }

    .timeline-error {
        color: var(--status-error);
    }

    .keyboard-mode-indicator {
        text-align: center;
        font-size: 12px;
        font-weight: 600;
        color: var(--color-ocean, #51A5C1);
        padding: 4px 0;
        letter-spacing: 0.05em;
    }
</style>

@code {
    [Parameter] public required string ProjectId { get; set; }
    [Parameter] public EventCallback<int> OnPullRequestClick { get; set; }
    [Parameter] public EventCallback<string> OnIssueClick { get; set; }
    [Parameter] public string? SelectedNodeId { get; set; }

    /// <summary>
    /// Called when an issue is created via inline keyboard controls.
    /// The parent should refresh data and select the new issue.
    /// </summary>
    [Parameter] public EventCallback<string> OnIssueCreated { get; set; }

    /// <summary>
    /// Called when the edit button is clicked on an issue row.
    /// </summary>
    [Parameter] public EventCallback<string> OnEditClick { get; set; }

    /// <summary>
    /// Called when an agent is started on an issue via the inline run agent button.
    /// </summary>
    [Parameter] public EventCallback<(string IssueId, AgentPrompt? Prompt)> OnRunAgentClick { get; set; }

    /// <summary>
    /// Called when the open panel button is clicked on an issue row (mobile only).
    /// </summary>
    [Parameter] public EventCallback<string> OnOpenPanelClick { get; set; }

    /// <summary>
    /// The active search term to highlight in issue titles.
    /// When set, matching issues get a highlight border and text matches are highlighted.
    /// </summary>
    [Parameter] public string? ActiveSearchTerm { get; set; }


    private HubConnection? _hubConnection;
    private HubConnection? _notificationHubConnection;
    private bool _isLoading = true;
    private string? _error;
    private TaskGraphResponse? _taskGraphData;
    private int _currentMaxPastPRs = 5;

    // Track ProjectId changes for navigation between projects
    private string? _previousProjectId;

    // Keyboard navigation
    private ElementReference _timelineWrapper;
    private TaskGraphView? _taskGraphViewRef;
    private List<TaskGraphIssueRenderLine> _issueRenderLines = [];
    private string? _previousSelectedIssueId;

    // Level depth controls
    private int _maxDepth = 3;
    private int _maxAvailableDepth = 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadTaskGraphAsync();
        InitializeKeyboardNavigation();

        // Set up SignalR connections for real-time updates (non-blocking)
        _ = SetupSignalRConnectionAsync();
        _ = SetupNotificationHubConnectionAsync();

        _previousProjectId = ProjectId;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_previousProjectId != null && _previousProjectId != ProjectId)
        {
            // ProjectId parameter changed â€” navigated to a different project via sidebar
            // Dispose old SignalR connections
            if (_hubConnection != null)
            {
                await _hubConnection.DisposeAsync();
                _hubConnection = null;
            }
            if (_notificationHubConnection != null)
            {
                await _notificationHubConnection.DisposeAsync();
                _notificationHubConnection = null;
            }

            // Reset all state for new project
            _taskGraphData = null;
            _currentMaxPastPRs = 5;
            _isLoading = true;
            _error = null;

            await LoadTaskGraphAsync();
            InitializeKeyboardNavigation();

            // Set up new SignalR connections for the new project
            _ = SetupSignalRConnectionAsync();
            _ = SetupNotificationHubConnectionAsync();
        }
        _previousProjectId = ProjectId;
    }

    private async Task SetupSignalRConnectionAsync()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/claudecode"))
                .WithAutomaticReconnect()
                .Build();

            _hubConnection.On<string, ClaudeSessionStatus, bool>("SessionStatusChanged", async (sessionId, status, _) =>
            {
                await InvokeAsync(async () =>
                {
                    await LoadTaskGraphAsync();
                    StateHasChanged();
                });
            });

            _hubConnection.On<ClaudeSession>("SessionStarted", async (session) =>
            {
                if (session.ProjectId == ProjectId)
                {
                    await InvokeAsync(async () =>
                    {
                        await LoadTaskGraphAsync();
                        StateHasChanged();
                    });
                }
            });

            _hubConnection.On<string>("SessionStopped", async (sessionId) =>
            {
                await InvokeAsync(async () =>
                {
                    await LoadTaskGraphAsync();
                    StateHasChanged();
                });
            });

            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up SignalR connection for timeline: {ex.Message}");
        }
    }

    /// <summary>
    /// Sets up a SignalR connection to NotificationHub for issue change events.
    /// When issues are created, updated, or deleted, the graph will be refreshed.
    /// </summary>
    private async Task SetupNotificationHubConnectionAsync()
    {
        try
        {
            _notificationHubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/notification"))
                .WithAutomaticReconnect()
                .Build();

            // Subscribe to issue change events (changeType is serialized as int)
            _notificationHubConnection.On<string, int, string>("IssuesChanged", async (projectId, changeType, issueId) =>
            {
                if (projectId == ProjectId)
                {
                    await InvokeAsync(async () =>
                    {
                        await RefreshAsync();
                    });
                }
            });

            await _notificationHubConnection.StartAsync();

            // Join the project group for targeted updates
            await _notificationHubConnection.InvokeAsync("JoinProjectGroup", ProjectId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to set up NotificationHub connection for timeline: {ex.Message}");
        }
    }

    /// <summary>
    /// Loads the task graph for displaying issues with actionable items on the left
    /// and blocking issues on the right.
    /// </summary>
    private async Task LoadTaskGraphAsync()
    {
        try
        {
            _taskGraphData = await GraphApi.GetTaskGraphDataAsync(ProjectId, _currentMaxPastPRs);

            // Compute max available depth from the data
            if (_taskGraphData?.Nodes.Count > 0)
            {
                _maxAvailableDepth = _taskGraphData.Nodes.Max(n => n.Lane);
            }
            else
            {
                _maxAvailableDepth = 0;
            }
            _isLoading = false;
            _error = null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load task graph: {ex.Message}");
            _error = ex.Message;
            _taskGraphData = null;
            _maxAvailableDepth = 0;
            _isLoading = false;
        }
    }

    /// <summary>
    /// Loads more past PRs in the task graph.
    /// </summary>
    private async Task LoadMoreTaskGraphPRs()
    {
        _currentMaxPastPRs += 5;
        await LoadTaskGraphAsync();
        StateHasChanged();
    }

    public async Task RefreshAsync()
    {
        await LoadTaskGraphAsync();
        StateHasChanged();
    }

    /// <summary>
    /// Gets the currently active IssueRowActions component for keyboard-driven agent start.
    /// </summary>
    public IssueRowActions? GetActiveIssueRowActions()
    {
        return _taskGraphViewRef?.GetActiveIssueRowActions();
    }

    private async Task HandleIssueCreated(string newIssueId)
    {
        // Refresh the task graph to show the new issue
        await LoadTaskGraphAsync();

        // Re-initialize keyboard navigation and select the newly created issue
        InitializeKeyboardNavigationWithSelection(newIssueId);

        StateHasChanged();

        // Notify parent component
        await OnIssueCreated.InvokeAsync(newIssueId);
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        if (_notificationHubConnection != null)
        {
            try
            {
                await _notificationHubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        NavService.OnStateChanged -= HandleNavStateChanged;
        NavService.OnIssueChanged -= HandleIssueChangedAsync;
        NavService.OnOpenEditRequested -= HandleOpenEditRequested;
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        // Don't handle keyboard when in edit mode - let the inline editor handle it
        if (NavService.EditMode != KeyboardEditMode.Viewing) return;

        switch (e.Key)
        {
            case "j":
            case "ArrowDown":
                NavService.MoveDown();
                break;
            case "k":
            case "ArrowUp":
                NavService.MoveUp();
                break;
            case "h":
            case "ArrowLeft":
                NavService.MoveToChild();
                break;
            case "l":
            case "ArrowRight":
                NavService.MoveToParent();
                break;
            case "i":
                NavService.StartEditingAtStart();
                break;
            case "a":
                NavService.StartEditingAtEnd();
                break;
            case "r":
                NavService.StartReplacingTitle();
                break;
            case "o":
                if (e.ShiftKey)
                    NavService.CreateIssueAbove();
                else
                    NavService.CreateIssueBelow();
                break;
            case "O":
                NavService.CreateIssueAbove();
                break;
            case "g":
                NavService.MoveToFirst();
                break;
            case "G":
                NavService.MoveToLast();
                break;
            case "Enter":
                NavService.OpenSelectedIssueForEdit();
                break;
            case "[":
                DecreaseDepth();
                break;
            case "]":
                IncreaseDepth();
                break;
            case "Tab":
                // Cycle issue type when in viewing mode (Tab is used differently in edit mode)
                _ = NavService.CycleIssueTypeAsync();
                break;
            case "s":
                _taskGraphViewRef?.OpenStatusMenu();
                break;
        }
    }

    private void DecreaseDepth()
    {
        if (_maxDepth > 0)
        {
            _maxDepth--;
            UpdateRenderLinesForDepth();
            StateHasChanged();
        }
    }

    private void IncreaseDepth()
    {
        if (_maxDepth < _maxAvailableDepth)
        {
            _maxDepth++;
            UpdateRenderLinesForDepth();
            StateHasChanged();
        }
    }

    private void HandleMaxDepthChanged(int newDepth)
    {
        _maxDepth = newDepth;
        UpdateRenderLinesForDepth();
        StateHasChanged();
    }

    private void UpdateRenderLinesForDepth()
    {
        if (_taskGraphData != null)
        {
            var allRenderLines = TaskGraphLayoutService.ComputeLayout(_taskGraphData, _maxDepth);
            _issueRenderLines = allRenderLines.OfType<TaskGraphIssueRenderLine>().ToList();
        }
    }

    private void HandleNavStateChanged()
    {
        InvokeAsync(async () =>
        {
            StateHasChanged();

            // Scroll the selected issue into view when selection changes via keyboard
            var currentSelectedId = NavService.SelectedIssueId;
            if (currentSelectedId != null && currentSelectedId != _previousSelectedIssueId)
            {
                _previousSelectedIssueId = currentSelectedId;
                await JSRuntime.InvokeVoidAsync("homespunInterop.scrollIssueIntoView", currentSelectedId);
            }
        });
    }

    private void HandleOpenEditRequested(string issueId)
    {
        InvokeAsync(() => OnEditClick.InvokeAsync(issueId));
    }

    private void InitializeKeyboardNavigation()
    {
        InitializeKeyboardNavigationWithSelection(null);
    }

    /// <summary>
    /// Initializes keyboard navigation and optionally selects a specific issue.
    /// If selectIssueId is null, selects the first actionable issue.
    /// </summary>
    /// <param name="selectIssueId">The issue ID to select, or null to select first actionable</param>
    private void InitializeKeyboardNavigationWithSelection(string? selectIssueId)
    {
        // Unsubscribe from previous subscriptions if any
        NavService.OnStateChanged -= HandleNavStateChanged;
        NavService.OnStateChanged += HandleNavStateChanged;
        NavService.OnIssueChanged -= HandleIssueChangedAsync;
        NavService.OnIssueChanged += HandleIssueChangedAsync;
        NavService.OnOpenEditRequested -= HandleOpenEditRequested;
        NavService.OnOpenEditRequested += HandleOpenEditRequested;

        // Set the project ID for API calls
        NavService.SetProjectId(ProjectId);

        // Build issue render lines from task graph data
        if (_taskGraphData != null)
        {
            NavService.SetTaskGraphNodes(_taskGraphData.Nodes);
            var allRenderLines = TaskGraphLayoutService.ComputeLayout(_taskGraphData, _maxDepth);
            _issueRenderLines = allRenderLines.OfType<TaskGraphIssueRenderLine>().ToList();
            NavService.Initialize(_issueRenderLines);

            // Select the specified issue, or fall back to first actionable
            if (selectIssueId != null)
            {
                NavService.SelectIssue(selectIssueId);
            }
            else
            {
                NavService.SelectFirstActionable();
            }
        }
    }

    private async Task HandleIssueChangedAsync()
    {
        // Remember current selection before refresh
        var currentSelection = NavService.SelectedIssueId;

        // Refresh the task graph when an issue is created or updated
        await LoadTaskGraphAsync();

        // Re-initialize with preserved selection
        InitializeKeyboardNavigationWithSelection(currentSelection);

        StateHasChanged();
    }

    private async Task HandleTaskGraphIssueClick(string issueId)
    {
        // Update keyboard navigation selection when clicking an issue
        NavService.SelectIssue(issueId);
        await OnIssueClick.InvokeAsync(issueId);
    }

    private string? GetKeyboardSelectedNodeId()
    {
        // Prefer keyboard selection over parameter if available
        if (NavService.SelectedIssueId != null)
        {
            return $"issue-{NavService.SelectedIssueId}";
        }
        return SelectedNodeId;
    }
}
