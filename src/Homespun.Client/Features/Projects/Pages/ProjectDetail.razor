@page "/projects/{Id}"
@page "/projects/{Id}/branches"
@page "/projects/{Id}/agents"
@page "/projects/{Id}/prompts"
@page "/projects/{Id}/secrets"
@page "/projects/{Id}/settings"
@implements IAsyncDisposable
@using Microsoft.AspNetCore.SignalR.Client
@inject HttpProjectApiService ProjectApi
@inject HttpPullRequestApiService PullRequestApi
@inject HttpFleeceSyncApiService FleeceSyncApi
@inject HttpGitHubInfoApiService GitHubInfoApi
@inject IBreadcrumbService BreadcrumbService
@inject HttpNotificationApiService NotificationApi
@inject ILogger<ProjectDetail> Logger
@inject NavigationManager NavigationManager

<PageTitle>@(_project?.Name ?? "Project")</PageTitle>

<div class="project-detail-page">
    @if (_project == null)
    {
        <p>Loading...</p>
    }
    else
    {
        <div class="project-sticky-header">
            <div class="flex justify-between items-center">
                <h1>@_project.Name</h1>
                <div class="flex items-center gap-2">
                    <BbSplitButton IconPosition="IconPosition.Start" OnClick="PullAsync">
                        <Icon>
                            <LucideIcon Name="cloud" class="h-4 w-4"/>
                        </Icon>
                        <ChildContent>Pull</ChildContent>
                        <DropdownContent>
                            <BbSplitButtonItem OnClick="SyncAllAsync">Sync</BbSplitButtonItem>
                        </DropdownContent>
                    </BbSplitButton>
                    <BbButton Variant="ButtonVariant.Outline" Size="ButtonSize.Small" Href="@($"projects/{Id}/edit")">
                        Edit Project
                    </BbButton>
                </div>
            </div>
        </div>

        @* Tab Navigation *@
        <ul class="nav nav-tabs mb-3">
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "issues" ? "active" : "")"
                   href="/projects/@Id"
                   @onclick="SwitchToIssuesTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="layout-list" Size="14" Class="me-1"/>
                    Issues
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "branches" ? "active" : "")"
                   href="/projects/@Id/branches"
                   @onclick="SwitchToBranchesTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="git-branch" Size="14" Class="me-1"/>
                    Branches
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "agents" ? "active" : "")"
                   href="/projects/@Id/agents"
                   @onclick="SwitchToAgentsTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="bot" Size="14" Class="me-1"/>
                    Agents
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "prompts" ? "active" : "")"
                   href="/projects/@Id/prompts"
                   @onclick="SwitchToPromptsTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="message-square-text" Size="14" Class="me-1"/>
                    Prompts
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "secrets" ? "active" : "")"
                   href="/projects/@Id/secrets"
                   @onclick="SwitchToSecretsTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="key-round" Size="14" Class="me-1"/>
                    Secrets
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(_activeTab == "settings" ? "active" : "")"
                   href="/projects/@Id/settings"
                   @onclick="SwitchToSettingsTab"
                   @onclick:preventDefault>
                    <LucideIcon Name="settings" Size="14" Class="me-1"/>
                    Settings
                </a>
            </li>
        </ul>

        @if (_activeTab == "issues")
        {
            <ProjectIssuesTab ProjectId="@Id"
                              Project="@_project"
                              RefreshTrigger="@_issuesRefreshTrigger"
                              OnDataChanged="OnIssuesDataChanged"/>
        }
        else if (_activeTab == "branches")
        {
            <CloneManagementPanel Project="@_project"
                                  OnDataChanged="OnIssuesDataChanged"/>
        }
        else if (_activeTab == "agents")
        {
            <SessionsPanel ProjectId="@Id" OnSessionStopped="OnIssuesDataChanged"/>
        }
        else if (_activeTab == "prompts")
        {
            <ProjectPromptsTab ProjectId="@Id"/>
        }
        else if (_activeTab == "secrets")
        {
            <ProjectSecretsTab ProjectId="@Id"/>
        }
        else if (_activeTab == "settings")
        {
            <ProjectSettingsTab Project="@_project"/>
        }

        @* Fleece Sync Conflict Modal *@
        <BbDialog Open="@_showFleeceConflictModal" OnOpenChange="v => { if (!v) HideFleeceConflictModal(); }">
            <BbDialogContent>
                <BbDialogHeader>
                    <BbDialogTitle>Sync Conflict</BbDialogTitle>
                </BbDialogHeader>
                <BbDialogBody>
                    <div class="alert alert-warning">
                        <strong>Unable to pull changes from @_project?.DefaultBranch</strong>
                    </div>
                    <p class="small text-muted">@_fleecePullConflict?.ErrorMessage</p>
                    <p>Choose how to resolve this conflict:</p>
                </BbDialogBody>
                <BbDialogFooter>
                    <BbButton Variant="ButtonVariant.Secondary" OnClick="HideFleeceConflictModal">Cancel</BbButton>
                    <BbButton OnClick="HandleFleeceConflictStash" Loading="@_isSyncingFleece" Variant="ButtonVariant.Secondary">Stash Changes</BbButton>
                    <BbButton OnClick="HandleFleeceConflictDiscard" Loading="@_isSyncingFleece" Variant="ButtonVariant.Destructive">Discard All Changes</BbButton>
                </BbDialogFooter>
            </BbDialogContent>
        </BbDialog>

        @* Non-Fleece Changes Modal *@
        <BbDialog Open="@_showNonFleeceChangesModal" OnOpenChange="v => { if (!v) HideNonFleeceChangesModal(); }">
            <BbDialogContent Class="sm:max-w-2xl">
                <BbDialogHeader>
                    <BbDialogTitle>Non-Fleece Changes Detected</BbDialogTitle>
                </BbDialogHeader>
                <BbDialogBody>
                    <div class="alert alert-warning">
                        <strong>Your local branch is behind the remote</strong>
                    </div>
                    <p>
                        The sync cannot complete because your local branch needs to pull changes from the remote,
                        but you have uncommitted changes outside the <code>.fleece/</code> folder that may cause conflicts.
                    </p>
                    @if (_nonFleeceChangedFiles != null && _nonFleeceChangedFiles.Count > 0)
                    {
                        <p><strong>Changed files outside .fleece/:</strong></p>
                        <div class="border rounded p-2" style="max-height: 200px; overflow-y: auto;">
                            <ul class="mb-0 small">
                                @foreach (var file in _nonFleeceChangedFiles)
                                {
                                    <li><code>@file</code></li>
                                }
                            </ul>
                        </div>
                    }
                    <p class="mt-3 text-muted small">
                        You can discard these non-fleece changes to allow the sync to complete.
                        Your <code>.fleece/</code> changes will be preserved.
                    </p>
                </BbDialogBody>
                <BbDialogFooter>
                    <BbButton Variant="ButtonVariant.Secondary" OnClick="HideNonFleeceChangesModal">Cancel</BbButton>
                    <BbButton OnClick="HandleDiscardNonFleeceChanges" Loading="@_isSyncingFleece" Variant="ButtonVariant.Destructive">Discard Non-Fleece Changes</BbButton>
                </BbDialogFooter>
            </BbDialogContent>
        </BbDialog>
    }
</div>

<style>
    .project-detail-page {
        outline: none;
        max-width: 100%;
        overflow-x: hidden;
    }

    /* ==========================================================================
       Sticky Header - Title and Toolbar
       ========================================================================== */
    .project-sticky-header {
        position: sticky;
        top: 0;
        z-index: 90;
        background: var(--bg-primary, #1a1a2e);
        padding-bottom: var(--spacing-sm, 8px);
        margin-bottom: var(--spacing-md, 16px);
        border-bottom: 1px solid var(--border-color, rgba(255, 255, 255, 0.1));
    }
</style>

@code {
    [Parameter] public string Id { get; set; } = "";

    private Project? _project;
    private string _activeTab = "issues";
    private string? _previousId;
    private bool _isSyncing;
    private int _issuesRefreshTrigger;

    // PR sync state
    private bool _isSyncingPRs;
    private bool _tokenMissing;
    private string? _syncError;
    private SyncResult? _lastSyncResult;

    // Fleece sync state
    private bool _isSyncingFleece;
    private FleeceIssueSyncResult? _lastFleeceSyncResult;
    private bool _showFleeceConflictModal;
    private PullResult? _fleecePullConflict;
    private bool _showNonFleeceChangesModal;
    private IReadOnlyList<string>? _nonFleeceChangedFiles;

    // SignalR
    private HubConnection? _hubConnection;

    protected override async Task OnInitializedAsync()
    {
        // Determine active tab from URL
        DetermineActiveTab();

        await LoadData();
        await SetupSignalRConnection();

        // Start sync after project is loaded
        if (_project != null)
        {
            _ = Task.Run(async () => { await InvokeAsync(async () => { await SyncPullRequestsAsync(); }); });
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_previousId != null && _previousId != Id)
        {
            // Id parameter changed â€” navigated to a different project
            if (_hubConnection != null)
            {
                await _hubConnection.DisposeAsync();
                _hubConnection = null;
            }

            // Reset state
            _lastSyncResult = null;
            _syncError = null;
            _activeTab = "issues";
            _issuesRefreshTrigger = 0;

            DetermineActiveTab();

            await LoadData();
            await SetupSignalRConnection();

            if (_project != null)
            {
                _ = Task.Run(async () => { await InvokeAsync(async () => { await SyncPullRequestsAsync(); }); });
            }
        }

        _previousId = Id;
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    private void DetermineActiveTab()
    {
        var uri = NavigationManager.Uri;
        if (uri.Contains("/settings"))
            _activeTab = "settings";
        else if (uri.Contains("/secrets"))
            _activeTab = "secrets";
        else if (uri.Contains("/prompts"))
            _activeTab = "prompts";
        else if (uri.Contains("/agents"))
            _activeTab = "agents";
        else if (uri.Contains("/branches"))
            _activeTab = "branches";
        else
            _activeTab = "issues";
    }

    private async Task LoadData()
    {
        _project = await ProjectApi.GetProjectAsync(Id);
        if (_project != null)
        {
            await BreadcrumbService.SetContextAsync(new BreadcrumbContext { ProjectId = Id });
        }
    }

    #region Tab Switching

    private void SwitchTab(string tab)
    {
        if (_activeTab == tab) return;
        _activeTab = tab;

        // Update the URL without causing a full navigation
        var newUrl = tab switch
        {
            "branches" => $"/projects/{Id}/branches",
            "agents" => $"/projects/{Id}/agents",
            "prompts" => $"/projects/{Id}/prompts",
            "secrets" => $"/projects/{Id}/secrets",
            "settings" => $"/projects/{Id}/settings",
            _ => $"/projects/{Id}"
        };
        NavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
    }

    private void SwitchToIssuesTab() => SwitchTab("issues");
    private void SwitchToBranchesTab() => SwitchTab("branches");
    private void SwitchToAgentsTab() => SwitchTab("agents");
    private void SwitchToPromptsTab() => SwitchTab("prompts");
    private void SwitchToSecretsTab() => SwitchTab("secrets");
    private void SwitchToSettingsTab() => SwitchTab("settings");

    #endregion

    #region SignalR

    private async Task SetupSignalRConnection()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri(HubConstants.NotificationHub))
                .Build();

            _hubConnection.On<string, SyncResult>("PullRequestsSynced", async (projectId, syncResult) =>
            {
                if (projectId == Id)
                {
                    Logger.LogInformation("Received PullRequestsSynced event for project {ProjectId}", projectId);
                    _lastSyncResult = syncResult;
                    await InvokeAsync(() =>
                    {
                        _issuesRefreshTrigger++;
                        StateHasChanged();
                    });
                }
            });

            await _hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection established for project {ProjectId}", Id);
        }
        catch (Exception ex)
        {
            Logger.LogWarning("SignalR connection failed (real-time updates unavailable): {Message}", ex.Message);
        }
    }

    #endregion

    #region Pull / Sync

    private async Task PullAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            var fleecePullTask = PullFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleecePullTask, prSyncTask);

            if (results[0] is string fleeceError)
                errors.Add($"Fleece pull: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Pull completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"pull-error-{_project.Id}"
                });
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    private async Task SyncAllAsync()
    {
        if (_project == null || _isSyncing)
            return;

        _isSyncing = true;
        StateHasChanged();

        var errors = new List<string>();

        try
        {
            var fleeceSyncTask = SyncFleeceInternalAsync();
            var prSyncTask = SyncPullRequestsInternalAsync();

            var results = await Task.WhenAll(fleeceSyncTask, prSyncTask);

            if (results[0] is string fleeceError)
                errors.Add($"Fleece sync: {fleeceError}");
            if (results[1] is string prError)
                errors.Add($"PR sync: {prError}");

            if (errors.Count > 0)
            {
                await NotificationApi.CreateNotificationAsync(new CreateNotificationRequest
                {
                    Type = NotificationType.Warning,
                    Title = "Sync completed with errors",
                    Message = string.Join("; ", errors),
                    ProjectId = _project.Id,
                    IsDismissible = true,
                    DeduplicationKey = $"sync-error-{_project.Id}"
                });
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        finally
        {
            _isSyncing = false;
            StateHasChanged();
        }
    }

    private async Task<string?> PullFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.PullFleeceOnlyAsync(_project.Id);

            if (result != null && !result.Success)
            {
                if (result.HasNonFleeceChanges)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null;
                }

                return result.ErrorMessage ?? "Unknown fleece pull error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to pull fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    private async Task<string?> SyncFleeceInternalAsync()
    {
        if (_project == null)
            return null;

        try
        {
            var result = await FleeceSyncApi.SyncAsync(_project.Id);

            if (result != null && !result.Success)
            {
                if (result.HasNonFleeceChanges && result.RequiresPullFirst)
                {
                    _nonFleeceChangedFiles = result.NonFleeceChangedFiles;
                    _showNonFleeceChangesModal = true;
                    return null;
                }

                return result.ErrorMessage ?? "Unknown fleece sync error";
            }

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync fleece issues for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    private async Task<string?> SyncPullRequestsInternalAsync()
    {
        if (_project == null)
            return null;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return null;

        try
        {
            var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
            if (!isConfigured)
            {
                Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
                return null;
            }

            var result = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (result.Errors.Count > 0)
            {
                var errorMessage = string.Join("; ", result.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, errorMessage);
                return errorMessage;
            }

            Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                _project.Id, result.Imported, result.Updated, result.Removed);

            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
            return ex.Message;
        }
    }

    private async Task SyncPullRequestsAsync()
    {
        if (_project == null || _isSyncingPRs)
            return;

        var hasGitHubConfig = !string.IsNullOrEmpty(_project.GitHubOwner) &&
                              !string.IsNullOrEmpty(_project.GitHubRepo);
        if (!hasGitHubConfig)
            return;

        var isConfigured = await GitHubInfoApi.IsConfiguredAsync();
        if (!isConfigured)
        {
            _tokenMissing = true;
            Logger.LogWarning("PR sync skipped for project {ProjectId}: GITHUB_TOKEN not configured", _project.Id);
            StateHasChanged();
            return;
        }

        _isSyncingPRs = true;
        _tokenMissing = false;
        _syncError = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting automatic PR sync for project {ProjectId} ({Owner}/{Repo})",
                _project.Id, _project.GitHubOwner, _project.GitHubRepo);

            _lastSyncResult = await PullRequestApi.SyncPullRequestsAsync(_project.Id);

            if (_lastSyncResult.Errors.Count > 0)
            {
                _syncError = string.Join("; ", _lastSyncResult.Errors);
                Logger.LogWarning("PR sync completed with errors for project {ProjectId}: {Errors}",
                    _project.Id, _syncError);
            }
            else
            {
                Logger.LogInformation("PR sync completed for project {ProjectId}: {Imported} imported, {Updated} updated, {Removed} removed",
                    _project.Id, _lastSyncResult.Imported, _lastSyncResult.Updated, _lastSyncResult.Removed);
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        catch (Exception ex)
        {
            _syncError = ex.Message;
            Logger.LogError(ex, "Failed to sync pull requests for project {ProjectId}", _project.Id);
        }
        finally
        {
            _isSyncingPRs = false;
            StateHasChanged();
        }
    }

    #endregion

    #region Fleece Conflict Handlers

    private void HideFleeceConflictModal()
    {
        _showFleeceConflictModal = false;
        _fleecePullConflict = null;
    }

    private void HideNonFleeceChangesModal()
    {
        _showNonFleeceChangesModal = false;
        _nonFleeceChangedFiles = null;
    }

    private async Task HandleDiscardNonFleeceChanges()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideNonFleeceChangesModal();

            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                return;
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictStash()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                return;
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    private async Task HandleFleeceConflictDiscard()
    {
        if (_project == null) return;

        _isSyncingFleece = true;
        StateHasChanged();

        try
        {
            HideFleeceConflictModal();

            _lastFleeceSyncResult = await FleeceSyncApi.SyncAsync(_project.Id);

            if (_lastFleeceSyncResult != null && !_lastFleeceSyncResult.Success)
            {
                return;
            }

            await LoadData();
            _issuesRefreshTrigger++;
        }
        finally
        {
            _isSyncingFleece = false;
            StateHasChanged();
        }
    }

    #endregion

    private async Task OnIssuesDataChanged()
    {
        await LoadData();
        _issuesRefreshTrigger++;
        StateHasChanged();
    }
}
