@page "/session/{SessionId}"
@using Homespun.ClaudeAgentSdk
@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.ClaudeCode.Hubs
@using Homespun.Features.ClaudeCode.Components.ToolResults
@using Homespun.Features.ClaudeCode.Components.SessionInfoPanel
@using Homespun.Features.Shared.Services
@using Homespun.Features.Navigation
@using Homespun.Features.SignalR
@using Homespun.Features.Fleece.Services
@using Homespun.Features.Projects
@using global::Fleece.Core.Models
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@implements IAsyncDisposable
@rendermode InteractiveServer
@inject IClaudeSessionService SessionService
@inject ISignalRUrlProvider SignalRUrlProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IMarkdownRenderingService MarkdownService
@inject IAgentPromptService AgentPromptService
@inject IBreadcrumbService BreadcrumbService
@inject IFleeceService FleeceService
@inject IProjectService ProjectService

<PageTitle>Session - Homespun</PageTitle>

<div class="session-page">
    @if (_session == null)
    {
        <div class="session-not-found">
            <h2>Session Not Found</h2>
            <p>The session you're looking for doesn't exist or has ended.</p>
            <a href="/agents" class="btn btn-primary">Back to Sessions</a>
        </div>
    }
    else
    {
        <div class="session-header">
            <div class="session-info">
                <h1>@(_issueTitle ?? "Claude Code Session")</h1>
                <div class="session-meta">
                    <span class="badge @GetModeBadgeClass(_session.Mode)">@_session.Mode</span>
                    <span class="badge @GetStatusBadgeClass(_session.Status)">@_session.Status.ToDisplayLabel()</span>
                    <code class="model-name">@_session.Model</code>
                </div>
            </div>
            <div class="session-actions">
                <button class="btn btn-outline-danger btn-sm" @onclick="StopSession"
                        disabled="@(_session.Status == ClaudeSessionStatus.Stopped)">
                    Stop Session
                </button>
            </div>
        </div>

        <div class="session-content">
        <div class="chat-container @(_sidePanelOpen ? "" : "expanded")">
            <div class="messages-area" @ref="_messagesContainer" @onscroll="HandleScroll">
                @if (_session.Messages.Count == 0 && _session.Status != ClaudeSessionStatus.Running)
                {
                    <div class="empty-state">
                        <p>Start the conversation by typing a message below.</p>
                    </div>
                }
                else
                {
                    @foreach (var displayItem in GetDisplayItems())
                    {
                        @if (displayItem is ClaudeMessage message)
                        {
                            @* Check if context was cleared before this message *@
                            @if (ShouldShowContextSeparator(message))
                            {
                                var separatorTime = GetContextSeparatorTime(message);
                                <div class="context-separator">
                                    <span class="separator-text">Context Cleared</span>
                                    <span class="separator-time">@separatorTime.ToLocalTime().ToString("HH:mm:ss")</span>
                                </div>
                            }

                            var messageClass = message.Role == ClaudeMessageRole.User ? "user-message" : "assistant-message";
                            <div class="message @messageClass">
                                <div class="message-header">
                                    <span class="message-role">@(message.Role == ClaudeMessageRole.User ? "You" : "Claude")</span>
                                    <span class="message-time">@message.CreatedAt.ToLocalTime().ToString("HH:mm:ss")</span>
                                </div>
                                <div class="message-content">
                                    @foreach (var content in message.Content.ToList())
                                    {
                                        <div class="content-block @GetContentBlockClass(content.Type) @(content.IsStreaming ? "streaming" : "")">
                                            @switch (content.Type)
                                            {
                                                case ClaudeContentType.Text:
                                                    <div class="text-content markdown-content">
                                                        @((MarkupString)MarkdownService.RenderToHtml(content.Text))
                                                        @if (content.IsStreaming)
                                                        {
                                                            <span class="streaming-cursor">‚ñå</span>
                                                        }
                                                    </div>
                                                    break;

                                                case ClaudeContentType.Thinking:
                                                    <details class="thinking-block" open="@content.IsStreaming">
                                                        <summary>
                                                            @if (content.IsStreaming)
                                                            {
                                                                <span>Thinking</span>
                                                                <span class="streaming-dots">...</span>
                                                            }
                                                            else
                                                            {
                                                                <span>Thinking...</span>
                                                            }
                                                        </summary>
                                                        <div class="thinking-content">
                                                            @content.Text
                                                            @if (content.IsStreaming)
                                                            {
                                                                <span class="streaming-cursor">‚ñå</span>
                                                            }
                                                        </div>
                                                    </details>
                                                    break;
                                            }
                                        </div>
                                    }
                                </div>
                            </div>
                        }
                        else if (displayItem is ToolExecutionGroup toolGroup)
                        {
                            @* Check if context was cleared before any message in this group *@
                            @foreach (var originalMsg in toolGroup.OriginalMessages)
                            {
                                @if (ShouldShowContextSeparator(originalMsg))
                                {
                                    var separatorTime = GetContextSeparatorTime(originalMsg);
                                    <div class="context-separator">
                                        <span class="separator-text">Context Cleared</span>
                                        <span class="separator-time">@separatorTime.ToLocalTime().ToString("HH:mm:ss")</span>
                                    </div>
                                    break; @* Only show one separator per group *@
                                }
                            }

                            <ToolExecutionGroupDisplay Group="toolGroup" />
                        }
                    }

                    @if (_session.Status == ClaudeSessionStatus.Running)
                    {
                        <div class="processing-indicator">
                            <div class="spinner-border spinner-border-sm" role="status"></div>
                            <span>Processing...</span>
                        </div>
                    }

                    @if (_pendingQuestion != null)
                    {
                        <div class="question-container">
                            <div class="question-header">
                                <span class="question-icon">‚ùì</span>
                                <span class="question-title">Claude has a question for you</span>
                            </div>
                            @foreach (var question in _pendingQuestion.Questions)
                            {
                                <div class="question-item">
                                    <div class="question-text">
                                        <span class="question-header-tag">@question.Header</span>
                                        @question.Question
                                    </div>
                                    <div class="question-options">
                                        @foreach (var option in question.Options)
                                        {
                                            var isSelected = _questionAnswers.TryGetValue(question.Question, out var answer) &&
                                                (question.MultiSelect
                                                    ? answer.Split(", ").Contains(option.Label)
                                                    : answer == option.Label);
                                            <button class="question-option @(isSelected ? "selected" : "")"
                                                    @onclick="() => SelectOption(question, option)"
                                                    title="@option.Description">
                                                @if (question.MultiSelect)
                                                {
                                                    <span class="option-checkbox">@(isSelected ? "‚òë" : "‚òê")</span>
                                                }
                                                @option.Label
                                            </button>
                                        }
                                        @* Other option for custom input *@
                                        <button class="question-option other-option @(IsOtherSelected(question.Question) ? "selected" : "")"
                                                @onclick="() => SelectOther(question)">
                                            Other...
                                        </button>
                                    </div>
                                    @if (IsOtherSelected(question.Question))
                                    {
                                        var questionKey = question.Question;
                                        <div class="custom-answer-input">
                                            <input type="text"
                                                   placeholder="Enter your custom answer..."
                                                   value="@GetCustomAnswer(questionKey)"
                                                   @oninput="@(e => UpdateCustomAnswer(questionKey, e.Value?.ToString() ?? string.Empty))" />
                                        </div>
                                    }
                                </div>
                            }
                            <div class="question-actions">
                                <button class="btn btn-primary" @onclick="SubmitAnswers" disabled="@(!CanSubmitAnswers())">
                                    Submit Answers
                                </button>
                            </div>
                        </div>
                    }

                    @if (_session.Status == ClaudeSessionStatus.WaitingForPlanExecution && !string.IsNullOrEmpty(_session.PlanContent))
                    {
                        <div class="action-panel">
                            <div class="action-panel-header">
                                <span class="action-panel-header-icon">üìã</span>
                                <span class="action-panel-header-title">Plan Ready for Implementation</span>
                            </div>
                            <div class="action-panel-description">
                                Choose how to proceed with the implementation:
                            </div>
                            <div class="action-panel-options">
                                <button class="action-panel-btn action-panel-btn-primary"
                                        @onclick="ExecutePlanWithClearContext"
                                        title="Clear conversation context and start fresh implementation">
                                    <span class="action-panel-btn-icon">üîÑ</span>
                                    Clear Context & Start Implementation
                                </button>
                                <button class="action-panel-btn"
                                        @onclick="ExecutePlanKeepContext"
                                        title="Continue with existing conversation context">
                                    <span class="action-panel-btn-icon">‚ñ∂Ô∏è</span>
                                    Continue with Context
                                </button>
                            </div>
                        </div>
                    }
                }

                @* Scroll to bottom button *@
                @if (_showScrollToBottomButton)
                {
                    <button class="scroll-to-bottom-btn" @onclick="ScrollToBottomClick" title="Scroll to bottom">
                        <span class="scroll-arrow">‚Üì</span>
                    </button>
                }
            </div>

            <div class="input-area">
                <div class="input-controls">
                    <select class="permission-select"
                            @bind="_selectedPermissionMode"
                            disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                        <option value="@PermissionMode.BypassPermissions">Bypass permissions</option>
                        <option value="@PermissionMode.AcceptEdits">Accept edits</option>
                        <option value="@PermissionMode.Plan">Plan</option>
                        <option value="@PermissionMode.Default">Default</option>
                    </select>
                    <select class="model-select"
                            @bind="_selectedModel"
                            disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                        <option value="opus">Opus</option>
                        <option value="sonnet">Sonnet</option>
                        <option value="haiku">Haiku</option>
                    </select>
                    <select class="prompt-select"
                            value="@_selectedPromptId"
                            @onchange="OnPromptSelected"
                            disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped)">
                        <option value="">(Select a prompt...)</option>
                        @foreach (var prompt in _availablePrompts)
                        {
                            <option value="@prompt.Id">@prompt.Name</option>
                        }
                    </select>
                    <button class="btn btn-outline-secondary btn-sm clear-context-btn"
                            @onclick="ClearContext"
                            disabled="@(_session.Status == ClaudeSessionStatus.Running || _session.Status == ClaudeSessionStatus.Stopped || _session.Messages.Count == 0)"
                            title="Clear context and start fresh (keeps message history)">
                        Clear Context
                    </button>
                </div>
                <div class="input-row">
                    <textarea @bind="_inputMessage"
                              @bind:event="oninput"
                              @onkeydown="HandleKeyDown"
                              placeholder="@GetInputPlaceholder()"
                              rows="3"
                              disabled="@(_session.Status == ClaudeSessionStatus.Stopped)">
                    </textarea>
                    <div class="button-group">
                        @if (_session.Status == ClaudeSessionStatus.Running)
                        {
                            <button class="btn btn-danger stop-button"
                                    @onclick="StopSession"
                                    disabled="@_isStopping"
                                    title="Stop the current execution (Escape)">
                                @if (_isStopping)
                                {
                                    <span class="spinner-border spinner-border-sm" role="status"></span>
                                }
                                else
                                {
                                    <span class="stop-icon">&#9632;</span>
                                }
                                Stop
                            </button>
                            @if (!string.IsNullOrWhiteSpace(_inputMessage))
                            {
                                <button class="btn btn-secondary queue-button"
                                        @onclick="QueueMessage"
                                        disabled="@(_pendingMessages.Count >= MaxQueuedMessages)"
                                        title="Queue this message to send after current processing completes">
                                    Queue @(_pendingMessages.Count > 0 ? $"({_pendingMessages.Count + 1})" : "")
                                </button>
                            }
                        }
                        else
                        {
                            <button class="btn btn-primary send-button"
                                    @onclick="SendMessage"
                                    disabled="@(string.IsNullOrWhiteSpace(_inputMessage) || _session.Status == ClaudeSessionStatus.Stopped)">
                                Send
                            </button>
                        }
                    </div>
                </div>
                @if (_pendingMessages.Count > 0)
                {
                    <div class="queued-messages-indicator">
                        <span class="badge bg-secondary">@_pendingMessages.Count message@(_pendingMessages.Count > 1 ? "s" : "") queued</span>
                        <button class="btn btn-link btn-sm" @onclick="ClearQueue">Clear queue</button>
                    </div>
                }
            </div>
        </div>

        <SessionInfoPanel Session="_session" @bind-IsOpen="_sidePanelOpen" IssueTitle="@_issueTitle" />
        </div>

        @if (_session.TotalCostUsd > 0)
        {
            <div class="session-stats">
                <span>Cost: $@_session.TotalCostUsd.ToString("F6")</span>
                <span>Duration: @FormatDuration(_session.TotalDurationMs)</span>
            </div>
        }

        @if (IsDebugBuild)
        {
            <!-- Debug Panel -->
            <details class="debug-panel">
                <summary @onclick="ToggleDebugMode" @onclick:preventDefault @onclick:stopPropagation>
                    <span>Debug SignalR Events</span>
                    @if (_debugMode)
                    {
                        <span class="debug-count">(@_debugLog.Count events)</span>
                    }
                </summary>
                @if (_debugMode)
                {
                    <div class="debug-controls">
                        <button class="btn btn-outline-secondary btn-sm" @onclick="ClearDebugLog">Clear Log</button>
                    </div>
                    <div class="debug-log">
                        @if (_debugLog.Count == 0)
                        {
                            <div class="debug-empty">No events logged yet. Interact with the session to see SignalR events.</div>
                        }
                        else
                        {
                            @foreach (var entry in _debugLog.ToList().AsEnumerable().Reverse().Take(50))
                            {
                                <div class="debug-entry @(entry.EventType == "ERROR" ? "error" : "")">
                                    <span class="debug-time">@entry.Timestamp.ToString("HH:mm:ss.fff")</span>
                                    <span class="debug-type">@entry.EventType</span>
                                    <span class="debug-message">@entry.Message</span>
                                </div>
                            }
                        }
                    </div>
                }
            </details>
        }
    }
</div>

<style>
    .session-page {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px);
        max-width: 1600px;
        margin: 0 auto;
        padding: var(--spacing-lg);
    }

    .session-not-found {
        text-align: center;
        padding: var(--spacing-xl);
    }

    .session-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: var(--spacing-lg);
        padding-bottom: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
    }

    .session-info h1 {
        margin: 0 0 var(--spacing-sm) 0;
        font-size: 1.5rem;
    }

    .session-meta {
        display: flex;
        gap: var(--spacing-sm);
        align-items: center;
    }

    .model-name {
        font-size: 0.875rem;
        padding: 0.25rem 0.5rem;
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
    }

    .session-content {
        display: flex;
        flex: 1;
        gap: var(--spacing-md);
        overflow: hidden;
        position: relative;
    }

    .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-color);
        overflow: hidden;
        min-width: 0;
    }

    .chat-container.expanded {
        max-width: 100%;
    }

    .messages-area {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-md);
    }

    .empty-state {
        text-align: center;
        color: var(--text-muted);
        padding: var(--spacing-xl);
    }

    .message {
        margin-bottom: var(--spacing-md);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
    }

    .user-message {
        background: var(--bg-tertiary);
        margin-left: 20%;
    }

    .assistant-message {
        background: var(--bg-primary);
        margin-right: 10%;
        border: 1px solid var(--border-color);
    }

    /* Tool execution group - consolidated bubble for grouped tool calls */
    .tool-group {
        background: var(--bg-primary);
        margin-right: 10%;
        margin-bottom: var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        overflow: hidden;
    }

    .tool-group-header {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-secondary);
    }

    .tool-group-icon {
        font-size: 1rem;
    }

    .tool-group-streaming {
        margin-left: auto;
    }

    .tool-execution-list {
        display: flex;
        flex-direction: column;
    }

    .tool-execution-row {
        border-bottom: 1px solid var(--border-color);
    }

    .tool-execution-row:last-child {
        border-bottom: none;
    }

    .tool-execution-row.error {
        border-left: 3px solid var(--status-error);
    }

    .tool-execution-row .running-summary {
        cursor: default;
    }

    .tool-execution-row .running-summary .tool-summary {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        color: var(--text-muted);
        font-style: italic;
    }

    .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: var(--spacing-sm);
        font-size: 0.875rem;
    }

    .message-role {
        font-weight: 600;
    }

    .message-time {
        color: var(--text-muted);
    }

    .content-block {
        margin-bottom: var(--spacing-sm);
    }

    .content-block:last-child {
        margin-bottom: 0;
    }

    .text-content {
        white-space: pre-wrap;
        word-break: break-word;
    }

    .thinking-block {
        background: var(--bg-secondary);
        padding: var(--spacing-sm);
        border-radius: var(--radius-sm);
        font-size: 0.875rem;
    }

    .thinking-block summary {
        cursor: pointer;
        color: var(--text-muted);
    }

    .thinking-content {
        margin-top: var(--spacing-sm);
        white-space: pre-wrap;
        color: var(--text-secondary);
    }

    .tool-use-block {
        background: var(--bg-tertiary);
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-sm);
        font-size: 0.875rem;
    }

    .tool-header {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
    }

    .tool-header .tool-icon {
        font-size: 1rem;
    }

    .tool-header .tool-name {
        font-weight: 500;
        color: var(--text-secondary);
    }

    .tool-header .tool-streaming-indicator {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        margin-left: var(--spacing-sm);
    }

    .tool-header .tool-status {
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    /* Tool Result Block Styles */
    .tool-result-block {
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
        font-family: monospace;
        font-size: 0.875rem;
        overflow: hidden;
    }

    .tool-result-block.error {
        border-left: 3px solid var(--status-error);
    }

    .tool-result-block details {
        margin: 0;
    }

    .tool-result-summary {
        padding: var(--spacing-sm) var(--spacing-md);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        background: var(--bg-tertiary);
        user-select: none;
        list-style: none;
    }

    .tool-result-summary::-webkit-details-marker {
        display: none;
    }

    .tool-result-summary:hover {
        background: var(--bg-secondary);
    }

    .tool-result-summary .tool-icon {
        font-size: 1rem;
        flex-shrink: 0;
    }

    .tool-result-summary .tool-name {
        font-weight: 600;
        color: var(--text-primary);
        flex-shrink: 0;
    }

    .tool-result-summary .tool-summary {
        flex: 1;
        color: var(--text-secondary);
        font-size: 0.8125rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .tool-result-summary .error-badge {
        background: var(--status-error);
        color: white;
        padding: 0.125rem 0.375rem;
        border-radius: var(--radius-sm);
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        flex-shrink: 0;
    }

    .tool-result-details {
        border-top: 1px solid var(--border-color);
        background: var(--bg-primary);
        max-height: 400px;
        overflow-y: auto;
    }

    .tool-result-block details[open] .tool-result-summary {
        border-bottom: 1px solid var(--border-color);
    }

    /* Read Tool Styles */
    .read-result .file-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-xs) var(--spacing-sm);
        background: var(--bg-tertiary);
        font-size: 0.8125rem;
    }

    .read-result .file-path {
        font-family: monospace;
        color: var(--text-primary);
    }

    .read-result .line-count {
        color: var(--text-muted);
    }

    .read-result .code-content {
        max-height: 350px;
        overflow: auto;
    }

    .read-result .code-block {
        margin: 0;
        padding: var(--spacing-sm);
        font-size: 0.8125rem;
        line-height: 1.5;
        white-space: pre-wrap;
        word-break: break-word;
    }

    /* Write Tool Styles */
    .write-result {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
        padding: var(--spacing-sm);
    }

    .write-result .operation-icon {
        font-size: 1.25rem;
    }

    .write-result .operation-details {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .write-result .file-path {
        font-family: monospace;
        font-size: 0.875rem;
    }

    .write-result .lines-written {
        color: var(--text-muted);
        font-size: 0.8125rem;
    }

    .write-result .operation-message pre {
        margin: var(--spacing-xs) 0 0;
        padding: var(--spacing-sm);
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        max-height: 150px;
        overflow: auto;
    }

    .write-result.created {
        border-left: 3px solid var(--status-success);
        padding-left: calc(var(--spacing-sm) - 3px);
    }

    .write-result.updated, .write-result.edited, .write-result.written {
        border-left: 3px solid var(--status-info);
        padding-left: calc(var(--spacing-sm) - 3px);
    }

    .write-result.deleted {
        border-left: 3px solid var(--status-error);
        padding-left: calc(var(--spacing-sm) - 3px);
    }

    /* Bash Tool Styles */
    .bash-result .command-line {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-xs) var(--spacing-sm);
        background: var(--bg-tertiary);
        font-family: monospace;
        font-size: 0.8125rem;
    }

    .bash-result .prompt {
        color: var(--status-success);
        font-weight: bold;
    }

    .bash-result .output {
        margin: 0;
        padding: var(--spacing-sm);
        font-size: 0.8125rem;
        max-height: 300px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
    }

    .bash-result .error-output {
        color: var(--status-error);
        background: rgba(218, 26, 50, 0.1);
    }

    .bash-result .exit-code {
        padding: var(--spacing-xs) var(--spacing-sm);
        background: var(--bg-tertiary);
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    /* Agent Tool Styles */
    .agent-result {
        padding: var(--spacing-sm);
    }

    .agent-result h6 {
        margin: 0 0 var(--spacing-xs);
        font-size: 0.75rem;
        color: var(--text-muted);
        text-transform: uppercase;
    }

    .agent-result .summary-section p {
        margin: 0;
        font-size: 0.875rem;
    }

    .agent-result .detailed-output {
        margin-top: var(--spacing-sm);
    }

    .agent-result .detailed-output summary {
        cursor: pointer;
        font-size: 0.8125rem;
        color: var(--text-muted);
    }

    .agent-result .detailed-output pre {
        margin: var(--spacing-xs) 0 0;
        padding: var(--spacing-sm);
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        max-height: 250px;
        overflow: auto;
    }

    .agent-result .files-affected {
        margin-top: var(--spacing-sm);
    }

    .agent-result .files-affected ul {
        margin: 0;
        padding-left: var(--spacing-lg);
    }

    .agent-result .files-affected li {
        font-size: 0.8125rem;
    }

    /* Grep Tool Styles */
    .grep-result {
        padding: var(--spacing-sm);
    }

    .grep-result .search-pattern {
        margin-bottom: var(--spacing-xs);
        font-size: 0.8125rem;
    }

    .grep-result .search-pattern .label {
        color: var(--text-muted);
        margin-right: var(--spacing-xs);
    }

    .grep-result .match-count {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-sm);
    }

    .grep-result .matches-list {
        max-height: 250px;
        overflow-y: auto;
    }

    .grep-result .match-item {
        padding: var(--spacing-xs) 0;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.8125rem;
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-xs);
    }

    .grep-result .match-item:last-child {
        border-bottom: none;
    }

    .grep-result .match-file {
        color: var(--color-lagoon);
    }

    .grep-result .match-line {
        color: var(--text-muted);
    }

    .grep-result .match-content {
        color: var(--text-secondary);
        flex-basis: 100%;
        padding-left: var(--spacing-sm);
        white-space: pre-wrap;
        word-break: break-word;
    }

    .grep-result .more-matches {
        padding: var(--spacing-xs);
        color: var(--text-muted);
        font-size: 0.75rem;
        font-style: italic;
    }

    /* Glob Tool Styles */
    .glob-result {
        padding: var(--spacing-sm);
    }

    .glob-result .glob-pattern {
        margin-bottom: var(--spacing-xs);
        font-size: 0.8125rem;
    }

    .glob-result .glob-pattern .label {
        color: var(--text-muted);
        margin-right: var(--spacing-xs);
    }

    .glob-result .file-count {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-sm);
    }

    .glob-result .files-list {
        max-height: 250px;
        overflow-y: auto;
    }

    .glob-result .file-item {
        padding: var(--spacing-xs) 0;
        font-size: 0.8125rem;
    }

    .glob-result .more-files {
        padding: var(--spacing-xs);
        color: var(--text-muted);
        font-size: 0.75rem;
        font-style: italic;
    }

    /* Web Tool Styles */
    .web-result {
        padding: var(--spacing-sm);
    }

    .web-result .web-url {
        margin-bottom: var(--spacing-sm);
        font-size: 0.8125rem;
    }

    .web-result .web-url .label {
        color: var(--text-muted);
        margin-right: var(--spacing-xs);
    }

    .web-result .web-url a {
        color: var(--color-lagoon);
        word-break: break-all;
    }

    .web-result .web-content pre {
        margin: 0;
        padding: var(--spacing-sm);
        background: var(--bg-tertiary);
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        max-height: 300px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
    }

    .web-result.error .web-content pre {
        color: var(--status-error);
    }

    /* Generic Result Styles */
    .generic-result {
        margin: 0;
        padding: var(--spacing-sm);
        font-size: 0.8125rem;
        max-height: 300px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
    }

    .processing-indicator {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
        color: var(--text-muted);
    }

    /* Streaming content indicators */
    .streaming-cursor {
        animation: blink 1s step-end infinite;
        color: var(--color-lagoon);
    }

    .streaming-dots {
        animation: dots 1.5s ease-in-out infinite;
    }

    .content-block.streaming {
        border-left: 2px solid var(--color-lagoon);
        padding-left: var(--spacing-sm);
    }

    @@keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    @@keyframes dots {
        0%, 20% { content: '.'; }
        40% { content: '..'; }
        60%, 100% { content: '...'; }
    }

    .input-area {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        padding: var(--spacing-md);
        border-top: 1px solid var(--border-color);
        background: var(--bg-primary);
    }

    .input-controls {
        display: flex;
        gap: var(--spacing-sm);
        flex-wrap: wrap;
        align-items: center;
    }

    .input-row {
        display: flex;
        gap: var(--spacing-sm);
        align-items: flex-start;
    }

    .permission-select,
    .model-select,
    .prompt-select {
        flex-shrink: 0;
        padding: var(--spacing-sm);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
        font-size: 0.875rem;
        cursor: pointer;
    }

    .permission-select {
        min-width: 140px;
    }

    .model-select {
        min-width: 100px;
    }

    .prompt-select {
        min-width: 160px;
    }

    .permission-select:focus,
    .model-select:focus,
    .prompt-select:focus {
        outline: none;
        border-color: var(--primary);
    }

    .permission-select:disabled,
    .model-select:disabled,
    .prompt-select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .clear-context-btn {
        margin-left: auto;
    }

    .input-row textarea {
        flex: 1;
        resize: none;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        padding: var(--spacing-sm);
        font-family: inherit;
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    .input-row textarea:focus {
        outline: none;
        border-color: var(--color-lagoon);
    }

    .button-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
        align-self: flex-end;
    }

    .send-button,
    .stop-button,
    .queue-button {
        min-width: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
    }

    .stop-button {
        animation: pulse-glow 1.5s ease-in-out infinite;
    }

    .stop-button .stop-icon {
        font-size: 0.75rem;
    }

    .stop-button:disabled {
        animation: none;
    }

    @@keyframes pulse-glow {
        0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4); }
        50% { box-shadow: 0 0 0 4px rgba(220, 53, 69, 0); }
    }

    .queue-button {
        font-size: 0.8125rem;
    }

    .queued-messages-indicator {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-xs) 0;
        font-size: 0.875rem;
    }

    .queued-messages-indicator .btn-link {
        padding: 0;
        font-size: 0.8125rem;
    }

    /* Context separator styles */
    .context-separator {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        padding: var(--spacing-md);
        margin: var(--spacing-md) 0;
        color: var(--text-muted);
        font-size: 0.875rem;
    }

    .context-separator::before,
    .context-separator::after {
        content: '';
        flex: 1;
        height: 1px;
        background: var(--border-color);
    }

    .context-separator .separator-text {
        font-weight: 500;
        color: var(--text-secondary);
    }

    .context-separator .separator-time {
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    /* Scroll to bottom button */
    .messages-area {
        position: relative;
    }

    .scroll-to-bottom-btn {
        position: sticky;
        bottom: var(--spacing-md);
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.2s ease;
    }

    .scroll-to-bottom-btn:hover {
        background: var(--bg-tertiary);
        border-color: var(--color-lagoon);
    }

    .scroll-to-bottom-btn .scroll-arrow {
        font-size: 1.25rem;
        line-height: 1;
    }

    .session-stats {
        display: flex;
        gap: var(--spacing-lg);
        padding: var(--spacing-sm) 0;
        font-size: 0.875rem;
        color: var(--text-muted);
    }

    /* Question Container Styles */
    .question-container {
        background: var(--bg-tertiary);
        border: 2px solid var(--status-question);
        border-radius: var(--radius-lg);
        padding: var(--spacing-lg);
        margin: var(--spacing-md) 0;
    }

    .question-header {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-md);
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
    }

    .question-icon {
        font-size: 1.25rem;
    }

    .question-title {
        color: var(--status-question);
    }

    .question-item {
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        padding: var(--spacing-md);
        margin-bottom: var(--spacing-md);
    }

    .question-item:last-child {
        margin-bottom: 0;
    }

    .question-text {
        font-size: 0.9375rem;
        margin-bottom: var(--spacing-sm);
        color: var(--text-primary);
    }

    .question-header-tag {
        display: inline-block;
        background: var(--status-question);
        color: white;
        padding: 0.125rem 0.5rem;
        border-radius: var(--radius-sm);
        font-size: 0.75rem;
        font-weight: 600;
        margin-right: var(--spacing-xs);
        text-transform: uppercase;
    }

    .question-options {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-sm);
        margin-top: var(--spacing-sm);
    }

    .question-option {
        padding: var(--spacing-sm) var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-primary);
        color: var(--text-primary);
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.15s ease;
    }

    .question-option:hover {
        border-color: var(--status-question);
        background: var(--bg-tertiary);
    }

    .question-option.selected {
        border-color: var(--status-question);
        background: var(--status-question);
        color: white;
    }

    .question-option.other-option {
        border-style: dashed;
        font-style: italic;
    }

    .option-checkbox {
        margin-right: var(--spacing-xs);
    }

    .custom-answer-input {
        margin-top: var(--spacing-sm);
    }

    .custom-answer-input input {
        width: 100%;
        padding: var(--spacing-sm);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.875rem;
    }

    .custom-answer-input input:focus {
        outline: none;
        border-color: var(--status-question);
    }

    .question-actions {
        margin-top: var(--spacing-md);
        display: flex;
        justify-content: flex-end;
    }

    /* Debug Panel Styles */
    .debug-panel {
        margin-top: var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-secondary);
    }

    .debug-panel summary {
        padding: var(--spacing-sm) var(--spacing-md);
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .debug-panel summary:hover {
        color: var(--text-primary);
    }

    .debug-count {
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    .debug-controls {
        padding: var(--spacing-sm) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
    }

    .debug-log {
        max-height: 300px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 0.75rem;
    }

    .debug-empty {
        padding: var(--spacing-md);
        color: var(--text-muted);
        text-align: center;
    }

    .debug-entry {
        padding: var(--spacing-xs) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        gap: var(--spacing-sm);
    }

    .debug-entry:last-child {
        border-bottom: none;
    }

    .debug-entry.error {
        background: rgba(220, 53, 69, 0.1);
        color: var(--status-error);
    }

    .debug-time {
        color: var(--text-muted);
        min-width: 100px;
    }

    .debug-type {
        font-weight: 600;
        min-width: 180px;
        color: var(--color-lagoon);
    }

    .debug-entry.error .debug-type {
        color: var(--status-error);
    }

    .debug-message {
        flex: 1;
        word-break: break-word;
    }

    /* ===== Mobile responsive styles ===== */
    @@media (max-width: 768px) {
        .session-page {
            padding: var(--spacing-sm);
            height: calc(100vh - 80px);
        }

        .session-header {
            margin-bottom: var(--spacing-sm);
            padding-bottom: var(--spacing-sm);
        }

        .session-info h1 {
            font-size: 1.125rem;
            line-height: 1.3;
        }

        .session-content {
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .user-message {
            margin-left: 5%;
        }

        .assistant-message,
        .tool-result-message {
            margin-right: 2%;
        }
    }
</style>

@code {
    [Parameter] public string SessionId { get; set; } = string.Empty;

    private ClaudeSession? _session;
    private string _inputMessage = string.Empty;
    private PermissionMode _selectedPermissionMode = PermissionMode.BypassPermissions;
    private string _selectedModel = "sonnet";
    private string _selectedPromptId = string.Empty;
    private IReadOnlyList<AgentPrompt> _availablePrompts = [];
    private bool _showScrollToBottomButton = false;
    private bool _isNearBottom = true;
    private ElementReference _messagesContainer;
    private HubConnection? _hubConnection;
    private string? _signalRError;

    // Side panel state
    private bool _sidePanelOpen = true;

    // Issue title for header display
    private string? _issueTitle;

    // Question handling
    private PendingQuestion? _pendingQuestion;
    private Dictionary<string, string> _questionAnswers = new();
    private Dictionary<string, string> _customAnswers = new();  // For "Other" text input

    // Stop button state
    private bool _isStopping = false;

    // Message queue for mid-execution prompts
    private Queue<string> _pendingMessages = new();
    private const int MaxQueuedMessages = 5;

    // Debug log entry class (needs to be accessible in both Debug and Release for Razor compilation)
    private class DebugLogEntry
    {
        public DateTime Timestamp { get; init; }
        public required string EventType { get; init; }
        public required string Message { get; init; }
    }

    // IsDebugBuild property for conditional rendering
#if DEBUG
    private static bool IsDebugBuild => true;
    // Debug mode for SignalR event logging
    private bool _debugMode = false;
    private List<DebugLogEntry> _debugLog = new();
    private const int MaxDebugLogEntries = 100;

    private void LogDebug(string eventType, string message)
    {
        if (_debugMode)
        {
            _debugLog.Add(new DebugLogEntry
            {
                Timestamp = DateTime.Now,
                EventType = eventType,
                Message = message
            });
            // Keep log size bounded
            while (_debugLog.Count > MaxDebugLogEntries)
            {
                _debugLog.RemoveAt(0);
            }
        }
    }

    private void ToggleDebugMode()
    {
        _debugMode = !_debugMode;
        if (!_debugMode)
        {
            _debugLog.Clear();
        }
        StateHasChanged();
    }

    private void ClearDebugLog()
    {
        _debugLog.Clear();
        StateHasChanged();
    }
#else
    private static bool IsDebugBuild => false;
    // Stubs for Release builds (never used since IsDebugBuild is false)
    private bool _debugMode => false;
    private List<DebugLogEntry> _debugLog => new();
    private static void LogDebug(string eventType, string message) { }
    private void ToggleDebugMode() { }
    private void ClearDebugLog() { }
#endif

    /// <summary>
    /// Gets the assistant message for the current turn (the one that comes after the last real user message).
    /// Creates a new assistant message if one doesn't exist for the current turn.
    /// Note: Tool result messages (role=user but only ToolResult content) are NOT turn boundaries.
    /// </summary>
    private ClaudeMessage? GetOrCreateCurrentTurnAssistantMessage()
    {
        if (_session == null) return null;

        // Find the index of the last REAL user message (not a tool_result message)
        // A real user message has text content, while tool_result messages only have ToolResult content
        var lastUserMessageIndex = -1;
        for (int i = _session.Messages.Count - 1; i >= 0; i--)
        {
            var msg = _session.Messages[i];
            if (msg.Role == ClaudeMessageRole.User && IsRealUserMessage(msg))
            {
                lastUserMessageIndex = i;
                break;
            }
        }

        // Look for an assistant message AFTER the last real user message
        ClaudeMessage? currentAssistantMessage = null;
        if (lastUserMessageIndex >= 0)
        {
            for (int i = lastUserMessageIndex + 1; i < _session.Messages.Count; i++)
            {
                if (_session.Messages[i].Role == ClaudeMessageRole.Assistant)
                {
                    currentAssistantMessage = _session.Messages[i];
                    break;
                }
            }
        }
        else
        {
            // No user message yet, so any assistant message is for the current turn (initial response)
            currentAssistantMessage = _session.Messages.LastOrDefault(m => m.Role == ClaudeMessageRole.Assistant);
        }

        // If no assistant message for this turn exists, create one
        if (currentAssistantMessage == null)
        {
            currentAssistantMessage = new ClaudeMessage
            {
                SessionId = SessionId,
                Role = ClaudeMessageRole.Assistant,
                Content = []
            };
            _session.Messages.Add(currentAssistantMessage);
            LogDebug("CreateMessage", "Created new assistant message for current turn");
        }

        return currentAssistantMessage;
    }

    /// <summary>
    /// Determines if a user message is a "real" user message (with text input) vs a tool_result message.
    /// Tool result messages have role=user but only contain ToolResult content blocks.
    /// </summary>
    private static bool IsRealUserMessage(ClaudeMessage message)
    {
        if (message.Role != ClaudeMessageRole.User) return false;

        // If the message has no content, treat it as a real user message (edge case)
        if (message.Content.Count == 0) return true;

        // If all content blocks are ToolResult, this is NOT a real user message
        var hasOnlyToolResults = message.Content.All(c => c.Type == ClaudeContentType.ToolResult);
        return !hasOnlyToolResults;
    }

    /// <summary>
    /// Transforms the flat message list into a list of display items (ClaudeMessage or ToolExecutionGroup).
    /// Groups consecutive tool use/result message pairs into consolidated ToolExecutionGroup objects.
    /// Non-tool content (text, thinking) from assistant messages with tools is split into a separate message.
    /// </summary>
    private List<object> GetDisplayItems()
    {
        if (_session == null) return [];

        var messages = _session.Messages.ToList();
        var displayItems = new List<object>();
        var currentToolGroup = new List<ToolExecution>();
        var currentGroupMessages = new List<ClaudeMessage>();
        DateTime currentGroupTimestamp = DateTime.UtcNow;

        void FlushToolGroup()
        {
            if (currentToolGroup.Count > 0)
            {
                displayItems.Add(new ToolExecutionGroup
                {
                    Executions = new List<ToolExecution>(currentToolGroup),
                    Timestamp = currentGroupTimestamp,
                    OriginalMessages = new List<ClaudeMessage>(currentGroupMessages)
                });
                currentToolGroup.Clear();
                currentGroupMessages.Clear();
            }
        }

        for (int i = 0; i < messages.Count; i++)
        {
            var msg = messages[i];

            if (msg.Role == ClaudeMessageRole.Assistant)
            {
                // Check if this assistant message has any tool use blocks
                var toolUseBlocks = msg.Content.Where(c => c.Type == ClaudeContentType.ToolUse).ToList();
                var nonToolBlocks = msg.Content.Where(c => c.Type != ClaudeContentType.ToolUse).ToList();

                if (toolUseBlocks.Count > 0)
                {
                    // If there are non-tool blocks (text/thinking), emit them as a regular message first
                    if (nonToolBlocks.Any(c => c.Type == ClaudeContentType.Text || c.Type == ClaudeContentType.Thinking))
                    {
                        // Flush any existing tool group before the text
                        FlushToolGroup();

                        // Create a synthetic message with only the non-tool content
                        var textMessage = new ClaudeMessage
                        {
                            Id = msg.Id,
                            SessionId = msg.SessionId,
                            Role = msg.Role,
                            CreatedAt = msg.CreatedAt,
                            IsStreaming = msg.IsStreaming
                        };
                        foreach (var block in nonToolBlocks)
                        {
                            textMessage.Content.Add(block);
                        }
                        displayItems.Add(textMessage);
                    }

                    // Track the timestamp for the group
                    if (currentToolGroup.Count == 0)
                    {
                        currentGroupTimestamp = msg.CreatedAt;
                    }
                    currentGroupMessages.Add(msg);

                    // Add all tool use blocks to the current group
                    foreach (var toolUse in toolUseBlocks)
                    {
                        currentToolGroup.Add(new ToolExecution { ToolUse = toolUse });
                    }
                }
                else
                {
                    // No tool use blocks - flush any pending tool group and emit as regular message
                    FlushToolGroup();
                    displayItems.Add(msg);
                }
            }
            else if (msg.Role == ClaudeMessageRole.User)
            {
                if (!IsRealUserMessage(msg))
                {
                    // This is a tool result message - pair results with pending tool uses
                    currentGroupMessages.Add(msg);
                    foreach (var resultContent in msg.Content.Where(c => c.Type == ClaudeContentType.ToolResult))
                    {
                        // Find the matching tool use by ToolUseId
                        var matchingExecution = currentToolGroup
                            .FirstOrDefault(e => e.ToolResult == null && e.ToolUse.ToolUseId == resultContent.ToolUseId);

                        if (matchingExecution != null)
                        {
                            matchingExecution.ToolResult = resultContent;
                        }
                        else
                        {
                            // Fallback: match by position (first unmatched tool use)
                            var unmatchedExecution = currentToolGroup.FirstOrDefault(e => e.ToolResult == null);
                            if (unmatchedExecution != null)
                            {
                                unmatchedExecution.ToolResult = resultContent;
                            }
                            else
                            {
                                // No matching tool use found - create a standalone execution
                                currentToolGroup.Add(new ToolExecution
                                {
                                    ToolUse = new ClaudeMessageContent
                                    {
                                        Type = ClaudeContentType.ToolUse,
                                        ToolName = resultContent.ParsedToolResult?.ToolName ?? resultContent.ToolName ?? "Tool",
                                        ToolUseId = resultContent.ToolUseId
                                    },
                                    ToolResult = resultContent
                                });
                            }
                        }
                    }
                }
                else
                {
                    // Real user message - flush tool group and emit
                    FlushToolGroup();
                    displayItems.Add(msg);
                }
            }
        }

        // Flush any remaining tool group
        FlushToolGroup();

        return displayItems;
    }

    /// <summary>
    /// Scrolls the messages container to the bottom.
    /// </summary>
    private async Task ScrollToBottom()
    {
        try
        {
            // Fixed: Use correct CSS selector (.messages-area instead of .messages-container)
            await JSRuntime.InvokeVoidAsync("eval",
                $"document.querySelector('.messages-area')?.scrollTo({{ top: document.querySelector('.messages-area')?.scrollHeight || 0, behavior: 'smooth' }})");
        }
        catch
        {
            // Ignore scroll errors
        }
    }

    /// <summary>
    /// Scrolls to bottom when button is clicked.
    /// </summary>
    private async Task ScrollToBottomClick()
    {
        await ScrollToBottom();
        _showScrollToBottomButton = false;
        _isNearBottom = true;
    }

    /// <summary>
    /// Handles scroll events to show/hide the scroll-to-bottom button.
    /// </summary>
    private async Task HandleScroll()
    {
        try
        {
            // Check if user is near the bottom (within 100px threshold)
            var isNear = await JSRuntime.InvokeAsync<bool>("eval",
                "(function() { var el = document.querySelector('.messages-area'); return el ? (el.scrollHeight - el.scrollTop - el.clientHeight < 100) : true; })()");

            _isNearBottom = isNear;
            _showScrollToBottomButton = !isNear;
        }
        catch
        {
            // Ignore scroll tracking errors
        }
    }

    /// <summary>
    /// Scrolls to bottom only if user is near the bottom (auto-scroll behavior).
    /// </summary>
    private async Task AutoScrollToBottomIfNearEnd()
    {
        if (_isNearBottom)
        {
            await ScrollToBottom();
        }
    }

    private async Task LoadIssueTitleAsync()
    {
        if (_session == null || string.IsNullOrEmpty(_session.EntityId) || string.IsNullOrEmpty(_session.ProjectId))
            return;

        // Don't try to load issue for worktree entities
        if (_session.EntityId.StartsWith("worktree:"))
            return;

        try
        {
            var project = await ProjectService.GetByIdAsync(_session.ProjectId);
            if (project != null)
            {
                var issue = await FleeceService.GetIssueAsync(project.LocalPath, _session.EntityId);
                _issueTitle = issue?.Title;
            }
        }
        catch
        {
            // Silently fail - we'll just show the default header
            _issueTitle = null;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await BreadcrumbService.SetContextAsync(new BreadcrumbContext { SessionId = SessionId });

        _session = SessionService.GetSession(SessionId);

        // Load available prompts
        _availablePrompts = AgentPromptService.GetAllPrompts();

        if (_session != null)
        {
            // CRITICAL: Ensure all content is marked as not streaming for immediate display
            // This is essential for JSONL-loaded sessions and for sessions where we want
            // complete messages to display without streaming artifacts
            foreach (var message in _session.Messages)
            {
                message.IsStreaming = false;
                foreach (var content in message.Content)
                {
                    content.IsStreaming = false;
                }
            }

            // Initialize pending question from session if present
            _pendingQuestion = _session.PendingQuestion;
            if (_pendingQuestion != null)
            {
                // Initialize answers with first option for non-multiselect questions
                foreach (var q in _pendingQuestion.Questions)
                {
                    if (q.Options.Count > 0 && !q.MultiSelect)
                    {
                        _questionAnswers[q.Question] = q.Options[0].Label;
                    }
                }
            }

            // Set initial model from session
            _selectedModel = _session.Model;

            // Load issue title for header display
            await LoadIssueTitleAsync();

            // Trigger render BEFORE SignalR setup to show messages immediately
            StateHasChanged();

            try
            {
                await SetupSignalR();
            }
            catch (Exception ex)
            {
                // SignalR connection failed - this can happen when accessing via external hostname
                // that the container can't resolve. Continue without real-time updates.
                _signalRError = $"Real-time updates unavailable: {ex.Message}";
                Console.WriteLine($"SignalR connection failed: {ex.Message}");
            }
        }
    }

    private async Task SetupSignalR()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(SignalRUrlProvider.GetHubUrl("/hubs/claudecode"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<ClaudeMessage>("MessageReceived", (message) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("MessageReceived", $"Role: {message.Role}, ContentBlocks: {message.Content.Count}");

                    if (_session == null) return;

                    // For user messages, check by ID
                    if (message.Role == ClaudeMessageRole.User)
                    {
                        var existingUser = _session.Messages.FirstOrDefault(m => m.Id == message.Id);
                        if (existingUser == null)
                        {
                            _session.Messages.Add(message);
                        }
                    }
                    else if (message.Role == ClaudeMessageRole.Assistant)
                    {
                        // For assistant messages, check if we already have one for this turn
                        // (created by streaming events). If so, don't add duplicate.
                        // Note: tool_result messages (role=user but only ToolResult content) are NOT turn boundaries.
                        var lastUserIndex = -1;
                        for (int i = _session.Messages.Count - 1; i >= 0; i--)
                        {
                            var msg = _session.Messages[i];
                            if (msg.Role == ClaudeMessageRole.User && IsRealUserMessage(msg))
                            {
                                lastUserIndex = i;
                                break;
                            }
                        }

                        ClaudeMessage? existingAssistant = null;
                        if (lastUserIndex >= 0)
                        {
                            for (int i = lastUserIndex + 1; i < _session.Messages.Count; i++)
                            {
                                if (_session.Messages[i].Role == ClaudeMessageRole.Assistant)
                                {
                                    existingAssistant = _session.Messages[i];
                                    break;
                                }
                            }
                        }

                        if (existingAssistant == null)
                        {
                            // No existing assistant message for this turn, add the new one
                            _session.Messages.Add(message);
                        }
                        else
                        {
                            // Assistant message exists from streaming - merge the final content
                            // This ensures any content that wasn't fully streamed gets updated
                            foreach (var content in existingAssistant.Content)
                            {
                                content.IsStreaming = false; // Mark all as not streaming
                            }
                            // Update the message with final content from server
                            // The server message has the authoritative content blocks
                            existingAssistant.Content.Clear();
                            foreach (var content in message.Content)
                            {
                                existingAssistant.Content.Add(content);
                            }
                        }
                    }
                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"MessageReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in MessageReceived: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent>("ContentBlockReceived", (content) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("ContentBlockReceived", $"Type: {content.Type}, Index: {content.Index}, TextLen: {content.Text?.Length ?? 0}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();
                    if (currentMessage != null)
                    {
                        // Check if we already have a block with this index
                        var existingBlock = content.Index >= 0
                            ? currentMessage.Content.FirstOrDefault(c => c.Index == content.Index)
                            : null;

                        if (existingBlock == null)
                        {
                            // No existing block, add this complete block
                            content.IsStreaming = false; // Ensure it's not marked as streaming
                            currentMessage.Content.Add(content);
                        }
                        else
                        {
                            // Block exists - update with complete content
                            existingBlock.Text = content.Text;
                            existingBlock.ToolInput = content.ToolInput;
                            existingBlock.ToolName = content.ToolName;
                            existingBlock.ToolUseId = content.ToolUseId;
                            existingBlock.IsStreaming = false;
                        }
                    }
                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"ContentBlockReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in ContentBlockReceived: {ex.Message}");
                }
            });
        });

        // Handle streaming content events - now with index tracking for robust block management
        _hubConnection.On<ClaudeMessageContent, int>("StreamingContentStarted", (content, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentStarted", $"Type: {content.Type}, Index: {index}");
                    Console.WriteLine($"[SignalR] StreamingContentStarted: Type={content.Type}, Index={index}");

                    // Get or create the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Add the streaming content block with its index
                    if (currentMessage != null)
                    {
                        // Check if we already have a block with this index
                        var existingBlock = index >= 0
                            ? currentMessage.Content.FirstOrDefault(c => c.Index == index)
                            : currentMessage.Content.FirstOrDefault(c => c.IsStreaming && c.Type == content.Type);

                        if (existingBlock == null)
                        {
                            content.Index = index;
                            currentMessage.Content.Add(content);
                        }
                    }
                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentStarted: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentStarted: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent, string, int>("StreamingContentDelta", (content, delta, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentDelta", $"Type: {content.Type}, Index: {index}, DeltaLen: {delta.Length}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Find and update the streaming content block by index (more robust than type matching)
                    var streamingBlock = index >= 0
                        ? currentMessage?.Content.FirstOrDefault(c => c.IsStreaming && c.Index == index)
                        : currentMessage?.Content.LastOrDefault(c => c.IsStreaming && c.Type == content.Type);

                    if (streamingBlock != null)
                    {
                        // Apply the delta
                        switch (content.Type)
                        {
                            case ClaudeContentType.Text:
                            case ClaudeContentType.Thinking:
                                streamingBlock.Text = (streamingBlock.Text ?? "") + delta;
                                break;
                            case ClaudeContentType.ToolUse:
                                streamingBlock.ToolInput = (streamingBlock.ToolInput ?? "") + delta;
                                break;
                        }
                    }
                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentDelta: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentDelta: {ex.Message}");
                }
            });
        });

        _hubConnection.On<ClaudeMessageContent, int>("StreamingContentStopped", (content, index) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("StreamingContentStopped", $"Type: {content.Type}, Index: {index}");
                    Console.WriteLine($"[SignalR] StreamingContentStopped: Type={content.Type}, Index={index}");

                    // Get the assistant message for the current turn
                    var currentMessage = GetOrCreateCurrentTurnAssistantMessage();

                    // Mark the content block as no longer streaming (find by index for robustness)
                    var streamingBlock = index >= 0
                        ? currentMessage?.Content.FirstOrDefault(c => c.IsStreaming && c.Index == index)
                        : currentMessage?.Content.LastOrDefault(c => c.IsStreaming && c.Type == content.Type);

                    if (streamingBlock != null)
                    {
                        streamingBlock.IsStreaming = false;
                    }
                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"StreamingContentStopped: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in StreamingContentStopped: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string, ClaudeSessionStatus>("SessionStatusChanged", (sessionId, status) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionStatusChanged", $"Status: {status}");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.Status = status;

                        // When execution completes and we have queued messages, send the next one
                        if (status == ClaudeSessionStatus.WaitingForInput && _pendingMessages.Count > 0)
                        {
                            var nextMessage = _pendingMessages.Dequeue();
                            _inputMessage = nextMessage;
                            StateHasChanged();
                            // Small delay to ensure UI updates, then send
                            await Task.Delay(100);
                            await SendMessage();
                        }
                        else
                        {
                            StateHasChanged();
                        }
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionStatusChanged: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionStatusChanged: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string>("SessionStopped", (sessionId) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionStopped", $"SessionId: {sessionId}");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.Status = ClaudeSessionStatus.Stopped;
                        StateHasChanged();
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionStopped: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionStopped: {ex.Message}");
                }
            });
        });

        _hubConnection.On<string, decimal, long>("SessionResultReceived", (sessionId, cost, duration) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionResultReceived", $"Cost: ${cost:F6}, Duration: {duration}ms");

                    if (_session != null && _session.Id == sessionId)
                    {
                        _session.TotalCostUsd = cost;
                        _session.TotalDurationMs = duration;
                        StateHasChanged();
                    }
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionResultReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionResultReceived: {ex.Message}");
                }
            });
        });

        // Handle session state sync - sent when joining a session to catch up on any missed events
        _hubConnection.On<ClaudeSession>("SessionState", (session) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("SessionState", $"Messages: {session.Messages.Count}, Status: {session.Status}");

                    if (_session != null && session.Id == _session.Id)
                    {
                        // Only replace messages if server has more than we do
                        // This avoids a flash for JSONL-loaded sessions that already have messages
                        if (session.Messages.Count > _session.Messages.Count)
                        {
                            _session.Messages.Clear();
                            foreach (var msg in session.Messages)
                            {
                                // Ensure loaded messages are not marked as streaming
                                msg.IsStreaming = false;
                                foreach (var content in msg.Content)
                                {
                                    content.IsStreaming = false;
                                }
                                _session.Messages.Add(msg);
                            }
                        }
                        _session.Status = session.Status;
                        _session.TotalCostUsd = session.TotalCostUsd;
                        _session.TotalDurationMs = session.TotalDurationMs;
                        _session.PlanContent = session.PlanContent;
                        _session.PlanFilePath = session.PlanFilePath;
                        _pendingQuestion = session.PendingQuestion;
                        Console.WriteLine($"[SignalR] SessionState received: {session.Messages.Count} messages, status: {session.Status}");
                    }
                    StateHasChanged();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"SessionState: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in SessionState: {ex.Message}");
                }
            });
        });

        // Handle question received from Claude
        _hubConnection.On<PendingQuestion>("QuestionReceived", (question) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("QuestionReceived", $"Questions: {question.Questions.Count}");
                    Console.WriteLine($"[SignalR] QuestionReceived: {question.Questions.Count} questions");

                    _pendingQuestion = question;
                    _questionAnswers.Clear();
                    _customAnswers.Clear();

                    // Initialize answers with first option for non-multiselect questions
                    foreach (var q in question.Questions)
                    {
                        if (q.Options.Count > 0 && !q.MultiSelect)
                        {
                            _questionAnswers[q.Question] = q.Options[0].Label;
                        }
                    }

                    if (_session != null)
                    {
                        _session.Status = ClaudeSessionStatus.WaitingForQuestionAnswer;
                        _session.PendingQuestion = question;
                    }

                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"QuestionReceived: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in QuestionReceived: {ex.Message}");
                }
            });
        });

        // Handle question answered confirmation
        _hubConnection.On("QuestionAnswered", () =>
        {
            _ = InvokeAsync(() =>
            {
                try
                {
                    LogDebug("QuestionAnswered", "Question was answered");
                    _pendingQuestion = null;
                    _questionAnswers.Clear();
                    _customAnswers.Clear();

                    if (_session != null)
                    {
                        _session.PendingQuestion = null;
                    }

                    StateHasChanged();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"QuestionAnswered: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in QuestionAnswered: {ex.Message}");
                }
                return Task.CompletedTask;
            });
        });

        // Handle context cleared event
        _hubConnection.On<string>("ContextCleared", (sessionId) =>
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    LogDebug("ContextCleared", $"Context cleared for session {sessionId}");
                    Console.WriteLine($"[SignalR] ContextCleared for session {sessionId}");

                    if (_session != null)
                    {
                        // Add a context clear marker to the session
                        _session.ContextClearMarkers.Add(DateTime.UtcNow);
                    }

                    StateHasChanged();
                    await AutoScrollToBottomIfNearEnd();
                }
                catch (Exception ex)
                {
                    LogDebug("ERROR", $"ContextCleared: {ex.Message}");
                    Console.WriteLine($"[SignalR] Error in ContextCleared: {ex.Message}");
                }
            });
        });

        await _hubConnection.StartAsync();
        await _hubConnection.SendAsync("JoinSession", SessionId);
        // Server sends SessionState after JoinSession, which we now handle above
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_inputMessage) || _session == null)
            return;

        var message = _inputMessage;
        _inputMessage = string.Empty;

        try
        {
            // Pass the selected model to the service
            await SessionService.SendMessageAsync(SessionId, message, _selectedPermissionMode, _selectedModel);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles keyboard events in the textarea.
    /// Enter creates a newline (default behavior).
    /// Ctrl+Enter or Meta+Enter (Cmd on Mac) submits the message or queues it when running.
    /// Escape stops the current execution when running.
    /// </summary>
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_session == null) return;

        // Escape key stops the current execution
        if (e.Key == "Escape" && _session.Status == ClaudeSessionStatus.Running)
        {
            await StopSession();
            return;
        }

        // Ctrl+Enter or Meta+Enter (Cmd+Enter on Mac)
        if (e.Key == "Enter" && (e.CtrlKey || e.MetaKey))
        {
            if (_session.Status == ClaudeSessionStatus.Running)
            {
                // When running, queue the message instead of sending
                QueueMessage();
            }
            else
            {
                await SendMessage();
            }
        }
    }

    private async Task StopSession()
    {
        if (_session == null || _isStopping) return;

        _isStopping = true;
        StateHasChanged();

        try
        {
            await SessionService.StopSessionAsync(SessionId);
            _session.Status = ClaudeSessionStatus.Stopped;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error stopping session: {ex.Message}");
        }
        finally
        {
            _isStopping = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Queues a message to be sent after the current execution completes.
    /// </summary>
    private void QueueMessage()
    {
        if (string.IsNullOrWhiteSpace(_inputMessage) || _pendingMessages.Count >= MaxQueuedMessages)
            return;

        _pendingMessages.Enqueue(_inputMessage);
        _inputMessage = string.Empty;
        StateHasChanged();
    }

    /// <summary>
    /// Clears all queued messages.
    /// </summary>
    private void ClearQueue()
    {
        _pendingMessages.Clear();
        StateHasChanged();
    }

    /// <summary>
    /// Gets the appropriate placeholder text based on session state.
    /// </summary>
    private string GetInputPlaceholder()
    {
        if (_session?.Status == ClaudeSessionStatus.Running)
        {
            return "Type a message to queue... (Ctrl+Enter to queue, Escape to stop)";
        }
        return "Type a message... (Ctrl+Enter to send)";
    }

    /// <summary>
    /// Handles prompt selection from the dropdown.
    /// Clears the current input and populates with the rendered prompt template.
    /// </summary>
    private void OnPromptSelected(ChangeEventArgs e)
    {
        if (_session == null) return;

        var promptId = e.Value?.ToString();
        if (string.IsNullOrEmpty(promptId))
        {
            _selectedPromptId = string.Empty;
            return;
        }

        var prompt = _availablePrompts.FirstOrDefault(p => p.Id == promptId);
        if (prompt == null) return;

        // Build context for template rendering from session metadata
        // In a real scenario, this would come from the session's associated entity
        var context = new PromptContext
        {
            Title = "Session Task",
            Id = _session.EntityId,
            Description = "",
            Branch = "",
            Type = _session.Mode.ToString()
        };

        // Render the template with placeholders replaced
        var renderedPrompt = AgentPromptService.RenderTemplate(prompt.InitialMessage, context);

        // Clear and populate the input
        _inputMessage = renderedPrompt ?? string.Empty;

        // Reset the dropdown to the default option
        _selectedPromptId = string.Empty;
    }

    /// <summary>
    /// Clears the conversation context and adds a separator.
    /// Old messages remain visible but the AI will start fresh.
    /// </summary>
    private async Task ClearContext()
    {
        if (_session == null || _session.Messages.Count == 0) return;

        // Add a context clear marker
        _session.ContextClearMarkers.Add(DateTime.UtcNow);

        // Optionally notify the backend to clear context
        try
        {
            await SessionService.ClearContextAsync(SessionId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error clearing context: {ex.Message}");
            // Continue anyway - the UI will show the separator
        }

        StateHasChanged();
    }

    /// <summary>
    /// Determines if a context separator should be shown before a message.
    /// </summary>
    private bool ShouldShowContextSeparator(ClaudeMessage message)
    {
        if (_session == null || _session.ContextClearMarkers.Count == 0) return false;

        // Get the message index
        var messageIndex = _session.Messages.IndexOf(message);
        if (messageIndex <= 0) return false;

        // Check if any context clear marker falls between the previous message and this one
        var prevMessage = _session.Messages[messageIndex - 1];
        return _session.ContextClearMarkers.Any(marker =>
            marker > prevMessage.CreatedAt && marker <= message.CreatedAt);
    }

    /// <summary>
    /// Gets the context separator timestamp for display.
    /// </summary>
    private DateTime GetContextSeparatorTime(ClaudeMessage message)
    {
        if (_session == null) return DateTime.UtcNow;

        var messageIndex = _session.Messages.IndexOf(message);
        if (messageIndex <= 0) return DateTime.UtcNow;

        var prevMessage = _session.Messages[messageIndex - 1];
        return _session.ContextClearMarkers
            .Where(marker => marker > prevMessage.CreatedAt && marker <= message.CreatedAt)
            .FirstOrDefault();
    }

    private static string GetModeBadgeClass(SessionMode mode) => mode switch
    {
        SessionMode.Plan => "bg-status-info",
        SessionMode.Build => "bg-status-success",
        _ => "bg-basalt-light"
    };

    private static string GetStatusBadgeClass(ClaudeSessionStatus status) => status.ToBadgeClass();

    private static string GetContentBlockClass(ClaudeContentType type) => type switch
    {
        ClaudeContentType.Text => "text-block",
        ClaudeContentType.Thinking => "thinking-block",
        ClaudeContentType.ToolUse => "tool-use-block",
        ClaudeContentType.ToolResult => "tool-result-block",
        _ => ""
    };

    private static string GetToolIcon(string toolName) => toolName.ToLowerInvariant() switch
    {
        "read" => "üìñ",
        "write" => "‚úèÔ∏è",
        "edit" => "üìù",
        "bash" => "üíª",
        "task" => "ü§ñ",
        "explore" => "üî≠",
        "grep" => "üîç",
        "glob" => "üìÅ",
        "webfetch" => "üåê",
        "websearch" => "üîé",
        _ => "üîß"
    };

    private static string FormatDuration(long ms)
    {
        if (ms < 1000) return $"{ms}ms";
        if (ms < 60000) return $"{ms / 1000.0:F1}s";
        return $"{ms / 60000.0:F1}m";
    }

    // Question handling methods
    private void SelectOption(UserQuestion question, QuestionOption option)
    {
        // Clear custom answer if selecting a regular option
        _customAnswers.Remove(question.Question);

        if (question.MultiSelect)
        {
            // Toggle selection for multi-select
            var current = _questionAnswers.GetValueOrDefault(question.Question, "");
            var selected = current.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();

            if (selected.Contains(option.Label))
            {
                selected.Remove(option.Label);
            }
            else
            {
                selected.Add(option.Label);
            }

            _questionAnswers[question.Question] = string.Join(", ", selected);
        }
        else
        {
            // Single select - replace
            _questionAnswers[question.Question] = option.Label;
        }
    }

    private void SelectOther(UserQuestion question)
    {
        // Mark this question as using "Other"
        _customAnswers[question.Question] = _customAnswers.GetValueOrDefault(question.Question, "");
        // Clear regular selection for single-select
        if (!question.MultiSelect)
        {
            _questionAnswers.Remove(question.Question);
        }
    }

    private bool IsOtherSelected(string question)
    {
        return _customAnswers.ContainsKey(question);
    }

    private string GetCustomAnswer(string question)
    {
        return _customAnswers.GetValueOrDefault(question, "");
    }

    private void UpdateCustomAnswer(string question, string value)
    {
        _customAnswers[question] = value;
        // Update the actual answer
        _questionAnswers[question] = value;
    }

    private bool CanSubmitAnswers()
    {
        if (_pendingQuestion == null) return false;

        foreach (var question in _pendingQuestion.Questions)
        {
            if (!_questionAnswers.TryGetValue(question.Question, out var answer) || string.IsNullOrWhiteSpace(answer))
            {
                return false;
            }
        }
        return true;
    }

    private async Task SubmitAnswers()
    {
        if (_pendingQuestion == null || _hubConnection == null || !CanSubmitAnswers())
            return;

        try
        {
            var answersJson = System.Text.Json.JsonSerializer.Serialize(_questionAnswers);
            await _hubConnection.SendAsync("AnswerQuestion", SessionId, answersJson);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error submitting answers: {ex.Message}");
        }
    }

    private async Task ExecutePlanWithClearContext()
    {
        if (_session == null || _hubConnection == null) return;

        try
        {
            await _hubConnection.SendAsync("ExecutePlan", SessionId, true);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error executing plan: {ex.Message}");
        }
    }

    private async Task ExecutePlanKeepContext()
    {
        if (_session == null || _hubConnection == null) return;

        try
        {
            await _hubConnection.SendAsync("ExecutePlan", SessionId, false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error executing plan: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null)
        {
            try
            {
                if (_hubConnection.State == HubConnectionState.Connected)
                {
                    await _hubConnection.SendAsync("LeaveSession", SessionId);
                }
            }
            catch
            {
                // Ignore errors when leaving session - connection may already be closed
            }

            await _hubConnection.DisposeAsync();
        }
    }
}
