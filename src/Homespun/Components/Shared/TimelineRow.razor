@using Homespun.Features.Gitgraph.Data
@using Homespun.Features.Gitgraph.Services

@if (Node.NodeType == GraphNodeType.SectionDivider)
{
    <div class="timeline-divider-row">
        <div class="timeline-graph-cell">
            @((MarkupString)SvgContent)
        </div>
        <div class="timeline-divider-content">
            <hr class="timeline-divider-line" />
            <span class="timeline-divider-label">@Node.Title</span>
        </div>
    </div>
}
else
{
    <div class="timeline-row @(IsSelected ? "timeline-row-selected" : "")"
         @onclick="HandleClick"
         @onmouseenter="HandleMouseEnter"
         @onmouseleave="HandleMouseLeave">
        <div class="timeline-graph-cell">
            @((MarkupString)SvgContent)
        </div>
        <div class="timeline-content-cell">
            <span class="timeline-title">@Node.Title</span>
            @if (AgentStatus != null)
            {
                <span class="agent-status-badge @GetAgentStatusClass()">
                    <span class="agent-status-dot @(AgentStatus.IsActive ? "agent-status-dot-active" : "")"></span>
                    <span>@GetAgentStatusLabel()</span>
                </span>
            }
            @if (!string.IsNullOrEmpty(Node.Tag))
            {
                <span class="timeline-tag" style="background-color: @(Node.Color ?? "#6b7280")20; border-color: @(Node.Color ?? "#6b7280"); color: @(Node.Color ?? "#6b7280");">
                    @Node.Tag
                </span>
            }
        </div>
    </div>
}

@code {
    [Parameter] public required IGraphNode Node { get; set; }
    [Parameter] public required RowLaneInfo LaneInfo { get; set; }
    [Parameter] public required int MaxLanes { get; set; }
    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public bool IsLoadMore { get; set; }
    [Parameter] public AgentStatusData? AgentStatus { get; set; }
    [Parameter] public IReadOnlyDictionary<int, string>? LaneColors { get; set; }
    [Parameter] public EventCallback<IGraphNode> OnNodeClick { get; set; }
    [Parameter] public EventCallback<(IGraphNode Node, ElementReference Element)> OnNodeHover { get; set; }
    [Parameter] public EventCallback OnNodeLeave { get; set; }

    private string SvgContent = "";

    protected override void OnParametersSet()
    {
        if (Node.NodeType == GraphNodeType.SectionDivider)
        {
            // Divider rows only show a vertical line in lane 0
            SvgContent = TimelineSvgRenderer.GenerateDividerRowSvg(
                maxLanes: MaxLanes,
                laneColors: LaneColors
            );
        }
        else if (LaneInfo.IsFlatOrphan)
        {
            // Flat orphan issues show diamond in lane 0 with no connecting lines
            var (effectiveColor, isOutlineOnly, showErrorCross) = ComputeEffectiveNodeStyle();
            SvgContent = TimelineSvgRenderer.GenerateFlatOrphanRowSvg(
                maxLanes: MaxLanes,
                nodeColor: effectiveColor,
                isOutlineOnly: isOutlineOnly,
                showErrorCross: showErrorCross
            );
        }
        else
        {
            var isIssue = Node.NodeType == GraphNodeType.Issue || Node.NodeType == GraphNodeType.OrphanIssue;
            var (effectiveColor, isOutlineOnly, showErrorCross) = ComputeEffectiveNodeStyle();

            SvgContent = TimelineSvgRenderer.GenerateRowSvg(
                nodeLane: LaneInfo.NodeLane,
                activeLanes: LaneInfo.ActiveLanes,
                connectorFromLane: LaneInfo.ConnectorFromLane,
                maxLanes: MaxLanes,
                nodeColor: effectiveColor,
                isIssue: isIssue,
                isLoadMore: IsLoadMore,
                laneColors: LaneColors,
                isFirstRowInLane: LaneInfo.IsFirstRowInLane,
                isLastRowInLane: LaneInfo.IsLastRowInLane,
                lanesEndingThisRow: LaneInfo.LanesEndingAtThisRow,
                isOutlineOnly: isIssue && isOutlineOnly,
                showErrorCross: isIssue && showErrorCross
            );
        }
    }

    private async Task HandleClick()
    {
        await OnNodeClick.InvokeAsync(Node);
    }

    private async Task HandleMouseEnter()
    {
        // TODO: Implement tooltip hover
    }

    private async Task HandleMouseLeave()
    {
        await OnNodeLeave.InvokeAsync();
    }

    /// <summary>
    /// Computes the effective node color, fill style, and error cross based on agent status and description presence.
    /// Agent status overrides the base issue color. When an agent is active, the diamond is always filled.
    /// When no agent is active, fill depends on whether the issue has a description.
    /// </summary>
    private (string Color, bool IsOutlineOnly, bool ShowErrorCross) ComputeEffectiveNodeStyle()
    {
        var baseColor = Node.Color ?? "#6b7280";

        // Check if agent status should override the color
        if (AgentStatus != null && AgentStatus.IsActive)
        {
            var agentColor = AgentStatus.Status switch
            {
                "Running" or "Starting" or "RunningHooks" => "#22c55e",       // Green - working
                "WaitingForInput" or "WaitingForPlanExecution" => "#eab308",   // Yellow - waiting
                "WaitingForQuestionAnswer" => "#f97316",                       // Orange - question
                "Error" => "#ef4444",                                          // Red - error
                _ => baseColor                                                 // Use base color for unknown statuses
            };

            var isError = AgentStatus.Status == "Error";

            // Agent active â†’ always filled, with error cross if error state
            return (agentColor, false, isError);
        }

        // No active agent: color from base, fill based on description
        var isOutlineOnly = Node.HasDescription == false; // false when HasDescription is explicitly false, not when null
        return (baseColor, isOutlineOnly, false);
    }

    private string GetAgentStatusClass()
    {
        if (AgentStatus == null || !AgentStatus.IsActive) return "agent-status-inactive";

        return AgentStatus.Status switch
        {
            "Running" => "agent-status-running",
            "WaitingForInput" => "agent-status-waiting",
            "Starting" => "agent-status-starting",
            "Error" => "agent-status-error",
            _ => "agent-status-inactive"
        };
    }

    private string GetAgentStatusLabel()
    {
        if (AgentStatus == null) return "";

        return AgentStatus.Status switch
        {
            "Running" => "Working",
            "WaitingForInput" => "Waiting",
            "Starting" => "Starting",
            "Error" => "Error",
            "Stopped" => "Stopped",
            _ => AgentStatus.Status
        };
    }
}
