@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.Gitgraph.Services
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@inject IGraphService GraphService
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

<div class="gitgraph-wrapper">
    @if (_isLoading)
    {
        <div class="gitgraph-loading">
            <span class="spinner-border spinner-border-sm" role="status"></span>
            <span>Loading graph...</span>
        </div>
    }
    else if (_isRefreshing)
    {
        <div class="gitgraph-refreshing">
            <span class="spinner-border spinner-border-sm" role="status"></span>
            <span>Updating...</span>
        </div>
    }
    @if (_error != null)
    {
        <div class="gitgraph-error">
            <span>Failed to load graph: @_error</span>
        </div>
    }
    <div @ref="_containerRef" id="@_containerId" class="gitgraph-container"></div>
</div>

<style>
    .gitgraph-container {
        width: 100%;
        min-height: 400px;
        overflow-x: auto;
        overflow-y: visible;
    }

    .gitgraph-container svg {
        font-family: inherit;
    }

    .gitgraph-loading,
    .gitgraph-refreshing,
    .gitgraph-error {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        color: var(--text-secondary);
        font-size: 0.85rem;
    }

    .gitgraph-refreshing {
        position: absolute;
        top: 0;
        right: 0;
        background: var(--bg-secondary);
        border-radius: 0 0 0 4px;
        opacity: 0.9;
    }

    .gitgraph-wrapper {
        position: relative;
    }

    .gitgraph-error {
        color: var(--status-error);
    }

    /* Node styles */
    .gitgraph-container .node-pr {
        cursor: pointer;
    }

    .gitgraph-container .node-issue {
        cursor: pointer;
    }

    .gitgraph-container .node-selected circle,
    .gitgraph-container .node-selected path {
        filter: drop-shadow(0 0 4px var(--color-ocean));
        stroke-width: 3;
    }

    /* Commit message styles */
    .gitgraph-container text {
        fill: var(--text-primary);
    }

    /* Branch label styles - outline only, no background */
    .gitgraph-container .branch-label rect {
        fill: transparent !important;
        stroke-width: 1px;
    }

    .gitgraph-container .branch-label text {
        fill: inherit;
    }
</style>

@code {
    [Parameter] public required string ProjectId { get; set; }
    [Parameter] public EventCallback<int> OnPullRequestClick { get; set; }
    [Parameter] public EventCallback<string> OnIssueClick { get; set; }
    [Parameter] public string? SelectedNodeId { get; set; }

    private ElementReference _containerRef;
    private string _containerId = $"gitgraph-{Guid.NewGuid():N}";
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<GitgraphVisualization>? _dotNetRef;
    private HubConnection? _hubConnection;
    private bool _isLoading = true;
    private bool _isRefreshing = false;
    private string? _error;
    private GitgraphJsonData? _graphData;
    private int _currentMaxPastPRs = 5;
    private DateTime? _cacheTimestamp;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "./Components/Shared/GitgraphVisualization.razor.js");
                _dotNetRef = DotNetObjectReference.Create(this);

                // First, load and render with cached data (fast)
                await LoadAndRenderGraph(useCache: true);

                // Set up SignalR connection for real-time agent status updates
                await SetupSignalRConnectionAsync();

                // Then, refresh with fresh data asynchronously in the background
                _ = RefreshWithFreshDataAsync();
            }
            catch (Exception ex)
            {
                _error = ex.Message;
                _isLoading = false;
                StateHasChanged();
            }
        }
    }

    private async Task SetupSignalRConnectionAsync()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/claudecode"))
                .WithAutomaticReconnect()
                .Build();

            // Listen for session status changes to refresh the graph
            _hubConnection.On<string, ClaudeSessionStatus>("SessionStatusChanged", async (sessionId, status) =>
            {
                // Refresh the graph when any session status changes
                await InvokeAsync(async () =>
                {
                    await LoadAndRenderGraph();
                });
            });

            // Listen for session started events
            _hubConnection.On<ClaudeSession>("SessionStarted", async (session) =>
            {
                // Refresh graph when a new session starts for this project
                if (session.ProjectId == ProjectId)
                {
                    await InvokeAsync(async () =>
                    {
                        await LoadAndRenderGraph();
                    });
                }
            });

            // Listen for session stopped events
            _hubConnection.On<string>("SessionStopped", async (sessionId) =>
            {
                // Refresh graph when a session stops
                await InvokeAsync(async () =>
                {
                    await LoadAndRenderGraph();
                });
            });

            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            // Log but don't fail - real-time updates are nice to have but not critical
            Console.WriteLine($"Failed to set up SignalR connection for graph: {ex.Message}");
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Update selection when SelectedNodeId changes
        if (_jsModule != null && !_isLoading)
        {
            await _jsModule.InvokeVoidAsync("highlightNode", _containerId, SelectedNodeId);
        }
    }

    private async Task LoadAndRenderGraph(bool useCache = true)
    {
        try
        {
            _graphData = await GraphService.BuildGraphJsonAsync(ProjectId, _currentMaxPastPRs, useCache);
            _cacheTimestamp = GraphService.GetCacheTimestamp(ProjectId);

            if (_jsModule != null)
            {
                await _jsModule.InvokeVoidAsync("initializeGraph",
                    _containerId,
                    _graphData,
                    _dotNetRef);

                if (SelectedNodeId != null)
                {
                    await _jsModule.InvokeVoidAsync("highlightNode", _containerId, SelectedNodeId);
                }
            }

            _isLoading = false;
            _error = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            _isLoading = false;
        }

        StateHasChanged();
    }

    /// <summary>
    /// Refreshes the graph with fresh data from GitHub in the background.
    /// This is called after the initial cached render to update the graph with latest PR data.
    /// </summary>
    private async Task RefreshWithFreshDataAsync()
    {
        if (_isRefreshing) return;

        try
        {
            _isRefreshing = true;
            await InvokeAsync(StateHasChanged);

            // Get fresh data from GitHub (bypasses cache)
            var freshData = await GraphService.BuildGraphJsonWithFreshDataAsync(ProjectId, _currentMaxPastPRs);

            // Only re-render if the data has changed
            if (!IsGraphDataEqual(_graphData, freshData))
            {
                _graphData = freshData;
                _cacheTimestamp = GraphService.GetCacheTimestamp(ProjectId);

                if (_jsModule != null)
                {
                    await _jsModule.InvokeVoidAsync("initializeGraph",
                        _containerId,
                        _graphData,
                        _dotNetRef);

                    if (SelectedNodeId != null)
                    {
                        await _jsModule.InvokeVoidAsync("highlightNode", _containerId, SelectedNodeId);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            // Log but don't show error - we already have cached data displayed
            Console.WriteLine($"Failed to refresh graph with fresh data: {ex.Message}");
        }
        finally
        {
            _isRefreshing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Compares two graph data objects to check if they are equal.
    /// Used to avoid unnecessary re-renders when the data hasn't changed.
    /// </summary>
    private static bool IsGraphDataEqual(GitgraphJsonData? a, GitgraphJsonData? b)
    {
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;

        // Compare commit counts first (quick check)
        if (a.Commits.Count != b.Commits.Count) return false;
        if (a.Branches.Count != b.Branches.Count) return false;

        // Compare commit hashes (more thorough check)
        var aHashes = a.Commits.Select(c => c.Hash).OrderBy(h => h).ToList();
        var bHashes = b.Commits.Select(c => c.Hash).OrderBy(h => h).ToList();

        return aHashes.SequenceEqual(bHashes);
    }

    [JSInvokable]
    public async Task LoadMorePastPRs()
    {
        // Increase the limit by 5
        _currentMaxPastPRs += 5;
        // Use cache when loading more past PRs for faster response
        await LoadAndRenderGraph(useCache: true);
    }

    [JSInvokable]
    public async Task HandleNodeClick(string nodeType, string nodeId, int? prNumber, string? issueId)
    {
        if (nodeType.Contains("PullRequest") && prNumber.HasValue)
        {
            await OnPullRequestClick.InvokeAsync(prNumber.Value);
        }
        else if (nodeType.Contains("Issue") && issueId != null)
        {
            await OnIssueClick.InvokeAsync(issueId);
        }
    }

    public async Task RefreshAsync()
    {
        if (_jsModule != null)
        {
            // When explicitly refreshing, get fresh data from GitHub
            await RefreshWithFreshDataAsync();
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Dispose SignalR connection
        if (_hubConnection != null)
        {
            try
            {
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        // Dispose JS module
        if (_jsModule != null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("dispose", _containerId);
                await _jsModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        _dotNetRef?.Dispose();
    }
}
