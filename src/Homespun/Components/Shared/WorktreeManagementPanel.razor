@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.Git
@using Homespun.Features.GitHub
@using Homespun.Features.Projects
@using Homespun.Features.PullRequests
@using Homespun.Features.PullRequests.Data
@using Homespun.Features.PullRequests.Data.Entities

@inject IGitWorktreeService GitWorktreeService
@inject IClaudeSessionStore SessionStore
@inject IClaudeSessionService SessionService
@inject IAgentStartupTracker StartupTracker
@inject IGitHubService GitHubService
@inject IRebaseAgentService RebaseAgentService
@inject PullRequestDataService PullRequestDataService
@inject PullRequestWorkflowService PullRequestWorkflowService
@inject NavigationManager NavigationManager
@inject ILogger<WorktreeManagementPanel> Logger

<div class="worktree-management-panel">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h4 class="mb-0">Worktrees &amp; Branches</h4>
        <div class="btn-group">
            <button class="btn btn-outline-secondary btn-sm" @onclick="RefreshDataAsync" disabled="@_isLoading">
                @if (_isLoading)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="FetchAllAsync" disabled="@_isFetching">
                @if (_isFetching)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-cloud-download"></i> Fetch
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="PruneWorktreesAsync" disabled="@_isPruning" title="Clean up stale worktree references">
                @if (_isPruning)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-trash"></i> Prune
            </button>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            @_errorMessage
            <button type="button" class="btn-close" @onclick="() => _errorMessage = null"></button>
        </div>
    }

    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="alert alert-success alert-dismissible fade show" role="alert">
            @_successMessage
            <button type="button" class="btn-close" @onclick="() => _successMessage = null"></button>
        </div>
    }

    @* Active Worktrees Section *@
    <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
            <span>Active Worktrees</span>
            <span class="badge bg-secondary">@_worktrees.Count(w => !w.IsBare)</span>
        </div>
        <div class="card-body p-0">
            @if (_worktrees.Count == 0)
            {
                <div class="text-muted p-3">No active worktrees</div>
            }
            else
            {
                <div class="list-group list-group-flush">
                    @foreach (var worktree in _worktrees.Where(w => !w.IsBare))
                    {
                        var branchName = GetShortBranchName(worktree.Branch);
                        var branchInfo = _branches.FirstOrDefault(b => b.ShortName == branchName);
                        var session = GetSessionForWorktree(worktree);
                        var prInfo = GetPullRequestForBranch(branchName);
                        var status = GetWorktreeStatus(worktree.Path);

                        <div class="list-group-item worktree-item">
                            <div class="d-flex justify-content-between align-items-start">
                                <div class="worktree-info flex-grow-1">
                                    <div class="d-flex align-items-center gap-2 mb-1 flex-wrap">
                                        <strong class="branch-name">@branchName</strong>
                                        @if (IsDefaultBranch(branchName))
                                        {
                                            <span class="badge bg-primary">default</span>
                                        }
                                        @if (branchInfo?.IsMerged == true)
                                        {
                                            <span class="badge bg-success">merged</span>
                                        }
                                        @if (prInfo != null)
                                        {
                                            <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                               target="_blank"
                                               class="badge bg-info text-decoration-none">
                                                PR #@prInfo.GitHubPRNumber
                                            </a>
                                        }
                                        @* Branch mismatch tag *@
                                        @if (!worktree.IsOnCorrectBranch)
                                        {
                                            <span class="badge bg-danger" title="Expected branch: @worktree.ExpectedBranch">
                                                Wrong Branch
                                            </span>
                                        }
                                        @* Git status badges *@
                                        @if (status != null && status.HasChanges)
                                        {
                                            @if (status.ModifiedCount > 0)
                                            {
                                                <span class="badge bg-warning text-dark" title="Modified files">M: @status.ModifiedCount</span>
                                            }
                                            @if (status.StagedCount > 0)
                                            {
                                                <span class="badge bg-success" title="Staged files">S: @status.StagedCount</span>
                                            }
                                            @if (status.UntrackedCount > 0)
                                            {
                                                <span class="badge bg-secondary" title="Untracked files">U: @status.UntrackedCount</span>
                                            }
                                        }
                                    </div>
                                    <div class="text-muted small">
                                        <code class="worktree-path">@worktree.Path</code>
                                    </div>
                                    @if (branchInfo != null)
                                    {
                                        <div class="text-muted small mt-1">
                                            @if (branchInfo.AheadCount > 0 || branchInfo.BehindCount > 0)
                                            {
                                                @if (branchInfo.AheadCount > 0)
                                                {
                                                    <span class="text-success me-2">+@branchInfo.AheadCount ahead</span>
                                                }
                                                @if (branchInfo.BehindCount > 0)
                                                {
                                                    <span class="text-danger">-@branchInfo.BehindCount behind</span>
                                                }
                                            }
                                            @if (!string.IsNullOrEmpty(branchInfo.LastCommitMessage))
                                            {
                                                <div class="commit-message mt-1">@TruncateMessage(branchInfo.LastCommitMessage)</div>
                                            }
                                        </div>
                                    }
                                </div>
                                <div class="worktree-actions d-flex align-items-center gap-1">
                                    @if (!IsDefaultBranch(branchName))
                                    {
                                        @if (!worktree.IsOnCorrectBranch)
                                        {
                                            <button class="btn btn-sm btn-warning"
                                                    @onclick="() => FixBranchAsync(worktree)"
                                                    disabled="@_operationInProgress"
                                                    title="Checkout the correct branch: @worktree.ExpectedBranch">
                                                Fix Branch
                                            </button>
                                        }

                                        <AgentControlPanel
                                            EntityId="@GetWorktreeEntityId(worktree)"
                                            WorktreePath="@worktree.Path"
                                            ProjectId="@Project.Id"
                                            Model="@(Project.DefaultModel ?? "sonnet")"
                                            SystemPrompt="@($"You are working on branch: {branchName}")"
                                            Compact="true"
                                            Disabled="@_operationInProgress" />

                                        @if (branchInfo?.BehindCount > 0)
                                        {
                                            <button class="btn btn-sm btn-outline-secondary"
                                                    @onclick="() => PullLatestAsync(worktree)"
                                                    disabled="@_operationInProgress"
                                                    title="Pull latest changes">
                                                Pull
                                            </button>
                                            <button class="btn btn-sm btn-outline-warning"
                                                    @onclick="() => StartRebaseAgentAsync(worktree)"
                                                    disabled="@(_operationInProgress || session != null || StartupTracker.IsStarting(GetWorktreeEntityId(worktree)))"
                                                    title="Start rebase agent to rebase onto @Project.DefaultBranch">
                                                <i class="bi bi-arrow-repeat"></i> Rebase
                                            </button>
                                        }

                                        <button class="btn btn-sm btn-outline-danger"
                                                @onclick="() => ShowDeleteWorktreeConfirmation(worktree, branchInfo)"
                                                disabled="@_operationInProgress"
                                                title="Delete worktree">
                                            Delete
                                        </button>
                                    }
                                </div>
                            </div>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    @* Lost Worktrees Section *@
    @if (_lostWorktrees.Any())
    {
        <div class="card mb-3 border-warning">
            <div class="card-header d-flex justify-content-between align-items-center bg-warning bg-opacity-25">
                <span><i class="bi bi-exclamation-triangle me-1"></i> Lost Worktrees</span>
                <span class="badge bg-warning text-dark">@_lostWorktrees.Count</span>
            </div>
            <div class="card-body p-0">
                <div class="list-group list-group-flush">
                    @foreach (var lost in _lostWorktrees)
                    {
                        <div class="list-group-item worktree-item">
                            <div class="d-flex justify-content-between align-items-start">
                                <div class="worktree-info flex-grow-1">
                                    <div class="d-flex align-items-center gap-2 mb-1">
                                        <strong class="branch-name">@lost.FolderName</strong>
                                        <span class="badge bg-warning text-dark">Lost</span>
                                        @if (lost.CanRepair)
                                        {
                                            <span class="badge bg-info" title="Can be repaired to branch: @lost.MatchingBranchName">
                                                <i class="bi bi-arrow-right"></i> @lost.MatchingBranchName
                                            </span>
                                        }
                                        @if (lost.Status != null && lost.Status.HasChanges)
                                        {
                                            @if (lost.Status.ModifiedCount > 0)
                                            {
                                                <span class="badge bg-danger" title="Modified files - may lose work!">M: @lost.Status.ModifiedCount</span>
                                            }
                                            @if (lost.Status.StagedCount > 0)
                                            {
                                                <span class="badge bg-success" title="Staged files">S: @lost.Status.StagedCount</span>
                                            }
                                            @if (lost.Status.UntrackedCount > 0)
                                            {
                                                <span class="badge bg-secondary" title="Untracked files">U: @lost.Status.UntrackedCount</span>
                                            }
                                        }
                                    </div>
                                    <div class="text-muted small">
                                        <code class="worktree-path">@lost.Path</code>
                                    </div>
                                </div>
                                <div class="worktree-actions">
                                    @if (lost.CanRepair)
                                    {
                                        <button class="btn btn-sm btn-outline-success me-1"
                                                @onclick="() => RepairLostWorktreeAsync(lost)"
                                                disabled="@_operationInProgress"
                                                title="Reattach to branch @lost.MatchingBranchName">
                                            Repair
                                        </button>
                                    }
                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => ShowDeleteLostWorktreeConfirmation(lost)"
                                            disabled="@_operationInProgress"
                                            title="Delete folder permanently">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    @* Local Branches Without Worktrees - Split into Open PRs and others *@
    @{
        var branchesWithoutWorktrees = _branches.Where(b => !b.HasWorktree && !IsDefaultBranch(b.ShortName)).ToList();
        var branchesWithPRs = branchesWithoutWorktrees.Where(b => GetPullRequestForBranch(b.ShortName) != null).ToList();
        var branchesWithoutPRs = branchesWithoutWorktrees.Where(b => GetPullRequestForBranch(b.ShortName) == null).ToList();
    }

    @* Open PRs Panel *@
    @if (branchesWithPRs.Any())
    {
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Open PRs</span>
                <span class="badge bg-info">@branchesWithPRs.Count</span>
            </div>
            <div class="card-body p-0">
                <div class="list-group list-group-flush">
                    @foreach (var branch in branchesWithPRs)
                    {
                        var prInfo = GetPullRequestForBranch(branch.ShortName);

                        <div class="list-group-item branch-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="branch-info">
                                    <div class="d-flex align-items-center gap-2">
                                        <strong>@branch.ShortName</strong>
                                        @if (branch.IsMerged)
                                        {
                                            <span class="badge bg-success">merged</span>
                                        }
                                        @if (!branch.HasRemote)
                                        {
                                            <span class="badge bg-secondary" title="No remote tracking branch">local only</span>
                                        }
                                        @if (prInfo != null)
                                        {
                                            <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                               target="_blank"
                                               class="badge bg-info text-decoration-none">
                                                PR #@prInfo.GitHubPRNumber
                                            </a>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(branch.LastCommitMessage))
                                    {
                                        <div class="text-muted small">@TruncateMessage(branch.LastCommitMessage)</div>
                                    }
                                </div>
                                <div class="branch-actions">
                                    <button class="btn btn-sm btn-outline-primary me-1"
                                            @onclick="() => CreateWorktreeForBranchAsync(branch.ShortName)"
                                            disabled="@_operationInProgress"
                                            title="Create worktree for this branch">
                                        Start
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => ShowDeleteBranchConfirmation(branch)"
                                            disabled="@_operationInProgress"
                                            title="Delete branch">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    @* Local Branches Without PRs *@
    @if (branchesWithoutPRs.Any())
    {
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Local Branches (No Worktree)</span>
                <span class="badge bg-secondary">@branchesWithoutPRs.Count</span>
            </div>
            <div class="card-body p-0">
                <div class="list-group list-group-flush">
                    @foreach (var branch in branchesWithoutPRs)
                    {
                        <div class="list-group-item branch-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="branch-info">
                                    <div class="d-flex align-items-center gap-2">
                                        <strong>@branch.ShortName</strong>
                                        @if (branch.IsMerged)
                                        {
                                            <span class="badge bg-success">merged</span>
                                        }
                                        @if (!branch.HasRemote)
                                        {
                                            <span class="badge bg-secondary" title="No remote tracking branch">local only</span>
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(branch.LastCommitMessage))
                                    {
                                        <div class="text-muted small">@TruncateMessage(branch.LastCommitMessage)</div>
                                    }
                                </div>
                                <div class="branch-actions">
                                    <button class="btn btn-sm btn-outline-primary me-1"
                                            @onclick="() => CreateWorktreeForBranchAsync(branch.ShortName)"
                                            disabled="@_operationInProgress"
                                            title="Create worktree for this branch">
                                        Start
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => ShowDeleteBranchConfirmation(branch)"
                                            disabled="@_operationInProgress"
                                            title="Delete branch">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    @* Remote Branches Section *@
    @if (_remoteBranches.Any())
    {
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Remote Branches (Not Local)</span>
                <span class="badge bg-secondary">@_remoteBranches.Count</span>
            </div>
            <div class="card-body p-0">
                <div class="list-group list-group-flush">
                    @foreach (var remoteBranch in _remoteBranches)
                    {
                        <div class="list-group-item branch-item">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="branch-info">
                                    <strong>origin/@remoteBranch</strong>
                                </div>
                                <div class="branch-actions">
                                    <button class="btn btn-sm btn-outline-primary me-1"
                                            @onclick="() => CreateWorktreeFromRemoteAsync(remoteBranch)"
                                            disabled="@_operationInProgress"
                                            title="Create local worktree from remote branch">
                                        Checkout
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => DeleteRemoteBranchAsync(remoteBranch)"
                                            disabled="@_operationInProgress"
                                            title="Delete remote branch">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }
</div>

@* Delete Confirmation Modal *@
@if (_showDeleteConfirmation)
{
    <div class="modal-backdrop fade show" style="background-color: rgba(0,0,0,0.5);"></div>
    <div class="modal fade show d-block" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">@_deleteModalTitle</h5>
                    <button type="button" class="btn-close" @onclick="HideDeleteConfirmation"></button>
                </div>
                <div class="modal-body">
                    @if (_deleteTargetLostWorktree != null)
                    {
                        <p>Are you sure you want to delete the folder <strong>@_deleteTargetName</strong>?</p>
                        @if (_deleteLostWorktreeHasChanges)
                        {
                            <div class="alert alert-danger">
                                <strong>Warning:</strong> This folder contains <strong>uncommitted changes</strong>. Deleting it will permanently lose these changes.
                            </div>
                        }
                        <p class="text-muted mb-0">This will permanently delete the folder and all its contents.</p>
                    }
                    else if (_deleteTargetIsMerged)
                    {
                        <p>Are you sure you want to delete <strong>@_deleteTargetName</strong>?</p>
                        <p class="text-muted mb-0">This branch has been merged and is safe to delete.</p>
                    }
                    else
                    {
                        <div class="alert alert-warning">
                            <strong>Warning:</strong> This branch has <strong>not been merged</strong> into the default branch.
                        </div>
                        <p>Are you sure you want to delete <strong>@_deleteTargetName</strong>?</p>
                        <p class="text-danger mb-0">You may lose uncommitted or unpushed changes.</p>
                    }

                    @if (_deleteIncludesWorktree)
                    {
                        <hr />
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="deleteWorktreeOnly" @bind="_deleteWorktreeOnly">
                            <label class="form-check-label" for="deleteWorktreeOnly">
                                Delete worktree only (keep branch)
                            </label>
                        </div>
                    }

                    @if (_hasRemoteBranch && !_deleteWorktreeOnly)
                    {
                        <div class="form-check mt-2">
                            <input class="form-check-input" type="checkbox" id="deleteRemote" @bind="_deleteRemoteBranch">
                            <label class="form-check-label" for="deleteRemote">
                                Also delete remote branch
                            </label>
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="HideDeleteConfirmation">Cancel</button>
                    <button type="button" class="btn btn-danger" @onclick="ExecuteDeleteAsync" disabled="@_operationInProgress">
                        @if (_operationInProgress)
                        {
                            <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                        }
                        Delete
                    </button>
                </div>
            </div>
        </div>
    </div>
}

<style>
    .worktree-management-panel {
        font-size: 0.875rem;
    }

    .worktree-item, .branch-item {
        padding: var(--spacing-sm) var(--spacing-md);
    }

    .branch-name {
        font-family: var(--font-family-mono, monospace);
    }

    .worktree-path {
        font-size: 0.75rem;
        word-break: break-all;
    }

    .commit-message {
        font-style: italic;
        max-width: 400px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .worktree-actions, .branch-actions {
        flex-shrink: 0;
        white-space: nowrap;
    }

    .list-group-item:hover {
        background-color: var(--bg-hover, #f8f9fa);
    }
</style>

@code {
    [Parameter] public required Project Project { get; set; }
    [Parameter] public EventCallback OnDataChanged { get; set; }

    private List<WorktreeInfo> _worktrees = [];
    private List<BranchInfo> _branches = [];
    private List<string> _remoteBranches = [];
    private List<PullRequest> _pullRequests = [];
    private List<LostWorktreeInfo> _lostWorktrees = [];
    private Dictionary<string, WorktreeStatus> _worktreeStatuses = new();
    private bool _isLoading;
    private bool _isFetching;
    private bool _isPruning;
    private bool _operationInProgress;
    private string? _errorMessage;
    private string? _successMessage;

    // Delete confirmation state
    private bool _showDeleteConfirmation;
    private string _deleteModalTitle = "Confirm Delete";
    private string _deleteTargetName = "";
    private bool _deleteTargetIsMerged;
    private bool _deleteIncludesWorktree;
    private bool _deleteWorktreeOnly;
    private bool _deleteRemoteBranch;
    private bool _hasRemoteBranch;
    private bool _deleteLostWorktreeHasChanges;
    private WorktreeInfo? _deleteTargetWorktree;
    private BranchInfo? _deleteTargetBranch;
    private LostWorktreeInfo? _deleteTargetLostWorktree;

    protected override async Task OnInitializedAsync()
    {
        await RefreshDataAsync();
    }

    private async Task RefreshDataAsync()
    {
        _isLoading = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Load worktrees
            _worktrees = await GitWorktreeService.ListWorktreesAsync(Project.LocalPath);

            // Load local branches with their info
            _branches = await GitWorktreeService.ListLocalBranchesAsync(Project.LocalPath);

            // Check merge status for each branch
            foreach (var branch in _branches.Where(b => !IsDefaultBranch(b.ShortName)))
            {
                branch.IsMerged = await GitWorktreeService.IsBranchMergedAsync(
                    Project.LocalPath,
                    branch.ShortName,
                    Project.DefaultBranch);
            }

            // Load remote-only branches
            _remoteBranches = await GitWorktreeService.ListRemoteOnlyBranchesAsync(Project.LocalPath);

            // Load pull requests for this project
            _pullRequests = await PullRequestDataService.GetByProjectIdAsync(Project.Id);

            // Load lost worktrees
            _lostWorktrees = await GitWorktreeService.FindLostWorktreeFoldersAsync(Project.LocalPath);

            // Load git status for all worktrees (in parallel for performance)
            _worktreeStatuses.Clear();
            var statusTasks = _worktrees.Where(w => !w.IsBare).Select(async w =>
            {
                try
                {
                    var status = await GitWorktreeService.GetWorktreeStatusAsync(w.Path);
                    return (w.Path, status);
                }
                catch
                {
                    return (w.Path, new WorktreeStatus());
                }
            });

            var statuses = await Task.WhenAll(statusTasks);
            foreach (var (path, status) in statuses)
            {
                _worktreeStatuses[path] = status;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load worktree data for project {ProjectId}", Project.Id);
            _errorMessage = $"Failed to load data: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task FetchAllAsync()
    {
        _isFetching = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.FetchAllAsync(Project.LocalPath);
            if (success)
            {
                _successMessage = "Fetched latest changes from remote";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = "Failed to fetch from remote";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fetch: {ex.Message}";
        }
        finally
        {
            _isFetching = false;
            StateHasChanged();
        }
    }

    private async Task PruneWorktreesAsync()
    {
        _isPruning = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            await GitWorktreeService.PruneWorktreesAsync(Project.LocalPath);
            _successMessage = "Pruned stale worktree references";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to prune: {ex.Message}";
        }
        finally
        {
            _isPruning = false;
            StateHasChanged();
        }
    }

    private WorktreeStatus? GetWorktreeStatus(string worktreePath)
    {
        return _worktreeStatuses.GetValueOrDefault(worktreePath);
    }

    private async Task FixBranchAsync(WorktreeInfo worktree)
    {
        if (string.IsNullOrEmpty(worktree.ExpectedBranch))
        {
            _errorMessage = "No expected branch to fix";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.CheckoutBranchAsync(worktree.Path, worktree.ExpectedBranch);
            if (success)
            {
                _successMessage = $"Checked out branch {worktree.ExpectedBranch}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to checkout branch {worktree.ExpectedBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fix branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task PullLatestAsync(WorktreeInfo worktree)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.PullLatestAsync(worktree.Path);
            if (success)
            {
                _successMessage = $"Pulled latest changes for {GetShortBranchName(worktree.Branch)}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = "Failed to pull latest changes";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to pull: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateWorktreeForBranchAsync(string branchName)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var worktreePath = await GitWorktreeService.CreateWorktreeAsync(
                Project.LocalPath,
                branchName,
                createBranch: false);

            if (!string.IsNullOrEmpty(worktreePath))
            {
                _successMessage = $"Created worktree for {branchName}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create worktree for {branchName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to create worktree: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateWorktreeFromRemoteAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Use the dedicated method that creates the worktree without checking out in main
            var worktreePath = await GitWorktreeService.CreateWorktreeFromRemoteBranchAsync(
                Project.LocalPath,
                remoteBranch);

            if (!string.IsNullOrEmpty(worktreePath))
            {
                _successMessage = $"Created worktree for {remoteBranch}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create worktree for {remoteBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to checkout remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task DeleteRemoteBranchAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.DeleteRemoteBranchAsync(Project.LocalPath, remoteBranch);
            if (success)
            {
                _successMessage = $"Deleted remote branch origin/{remoteBranch}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to delete remote branch {remoteBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task RepairLostWorktreeAsync(LostWorktreeInfo lost)
    {
        if (!lost.CanRepair || string.IsNullOrEmpty(lost.MatchingBranchName))
        {
            _errorMessage = "Cannot repair: no matching branch found";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.RepairWorktreeAsync(
                Project.LocalPath,
                lost.Path,
                lost.MatchingBranchName);

            if (success)
            {
                _successMessage = $"Repaired worktree for branch {lost.MatchingBranchName}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to repair worktree for {lost.FolderName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to repair worktree: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private void ShowDeleteLostWorktreeConfirmation(LostWorktreeInfo lost)
    {
        _deleteModalTitle = "Delete Lost Worktree";
        _deleteTargetName = lost.FolderName;
        _deleteTargetIsMerged = false;
        _deleteIncludesWorktree = false;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = false;
        _deleteLostWorktreeHasChanges = lost.Status?.HasChanges ?? false;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = null;
        _deleteTargetLostWorktree = lost;
        _showDeleteConfirmation = true;
    }

    private async Task DeleteLostWorktreeAsync(LostWorktreeInfo lost)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.DeleteWorktreeFolderAsync(lost.Path);
            if (success)
            {
                _successMessage = $"Deleted folder {lost.FolderName}";
                HideDeleteConfirmation();
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to delete folder {lost.FolderName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete folder: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartSessionAsync(WorktreeInfo worktree, SessionMode mode)
    {
        var entityId = GetWorktreeEntityId(worktree);
        var branchName = GetShortBranchName(worktree.Branch);

        StartupTracker.MarkAsStarting(entityId);
        StateHasChanged();

        try
        {
            var session = await SessionService.StartSessionAsync(
                entityId,
                Project.Id,
                worktree.Path,
                mode,
                Project.DefaultModel ?? "sonnet",
                systemPrompt: $"You are working on branch: {branchName}");

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start session for worktree {WorktreePath}", worktree.Path);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start session: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task StopSessionAsync(ClaudeSession session)
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            await SessionService.StopSessionAsync(session.Id);
            _successMessage = "Session stopped";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to stop session: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartRebaseAgentAsync(WorktreeInfo worktree)
    {
        var branchName = GetShortBranchName(worktree.Branch);
        var entityId = $"rebase-{branchName}";

        StartupTracker.MarkAsStarting(entityId);
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Get recently merged PRs for context
            var recentMergedPRs = await PullRequestWorkflowService.GetMergedPullRequestsWithTimeAsync(Project.Id);
            var recentPRInfos = recentMergedPRs
                .Take(10)
                .Select(pr => pr.PullRequest)
                .ToList();

            var session = await RebaseAgentService.StartRebaseAgentAsync(
                Project.Id,
                worktree.Path,
                branchName,
                Project.DefaultBranch,
                Project.DefaultModel ?? "sonnet",
                recentPRInfos);

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start rebase agent for worktree {WorktreePath}", worktree.Path);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start rebase agent: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private void ShowDeleteWorktreeConfirmation(WorktreeInfo worktree, BranchInfo? branchInfo)
    {
        var branchName = GetShortBranchName(worktree.Branch);
        _deleteModalTitle = "Delete Worktree";
        _deleteTargetName = branchName;
        _deleteTargetIsMerged = branchInfo?.IsMerged ?? false;
        _deleteIncludesWorktree = true;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branchInfo?.Upstream != null;
        _deleteTargetWorktree = worktree;
        _deleteTargetBranch = branchInfo;
        _showDeleteConfirmation = true;
    }

    private void ShowDeleteBranchConfirmation(BranchInfo branch)
    {
        _deleteModalTitle = "Delete Branch";
        _deleteTargetName = branch.ShortName;
        _deleteTargetIsMerged = branch.IsMerged;
        _deleteIncludesWorktree = false;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branch.Upstream != null;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = branch;
        _showDeleteConfirmation = true;
    }

    private void HideDeleteConfirmation()
    {
        _showDeleteConfirmation = false;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = null;
        _deleteTargetLostWorktree = null;
        _deleteLostWorktreeHasChanges = false;
    }

    private async Task ExecuteDeleteAsync()
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Handle lost worktree deletion
            if (_deleteTargetLostWorktree != null)
            {
                await DeleteLostWorktreeAsync(_deleteTargetLostWorktree);
                return;
            }

            var branchName = _deleteTargetBranch?.ShortName ?? GetShortBranchName(_deleteTargetWorktree?.Branch);

            // Stop any active session first
            if (_deleteTargetWorktree != null)
            {
                var session = GetSessionForWorktree(_deleteTargetWorktree);
                if (session != null)
                {
                    await SessionService.StopSessionAsync(session.Id);
                }

                // Remove the worktree
                var worktreeRemoved = await GitWorktreeService.RemoveWorktreeAsync(
                    Project.LocalPath,
                    _deleteTargetWorktree.Path);

                if (!worktreeRemoved)
                {
                    _errorMessage = "Failed to remove worktree";
                    return;
                }
            }

            // Delete the branch if not worktree-only
            if (!_deleteWorktreeOnly && !string.IsNullOrEmpty(branchName))
            {
                var forceDelete = !_deleteTargetIsMerged;
                var branchDeleted = await GitWorktreeService.DeleteLocalBranchAsync(
                    Project.LocalPath,
                    branchName,
                    force: forceDelete);

                if (!branchDeleted)
                {
                    _errorMessage = $"Failed to delete local branch {branchName}";
                    return;
                }

                // Delete remote branch if requested
                if (_deleteRemoteBranch)
                {
                    var remoteDeleted = await GitWorktreeService.DeleteRemoteBranchAsync(
                        Project.LocalPath,
                        branchName);

                    if (!remoteDeleted)
                    {
                        _errorMessage = $"Failed to delete remote branch {branchName}";
                        return;
                    }
                }
            }

            _successMessage = _deleteWorktreeOnly
                ? $"Removed worktree for {branchName}"
                : $"Deleted {branchName}" + (_deleteRemoteBranch ? " (local and remote)" : " (local)");

            HideDeleteConfirmation();
            await RefreshDataAsync();
            await OnDataChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Delete failed: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private ClaudeSession? GetSessionForWorktree(WorktreeInfo worktree)
    {
        var entityId = GetWorktreeEntityId(worktree);
        return SessionStore.GetByEntityId(entityId);
    }

    private string GetWorktreeEntityId(WorktreeInfo worktree)
    {
        // Use the branch name as the entity ID for session tracking
        var branchName = GetShortBranchName(worktree.Branch);
        return $"worktree:{branchName}";
    }

    private PullRequest? GetPullRequestForBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return null;
        return _pullRequests.FirstOrDefault(pr => pr.BranchName == branchName);
    }

    private static string GetShortBranchName(string? branch)
    {
        if (string.IsNullOrEmpty(branch)) return "unknown";
        return branch.Replace("refs/heads/", "");
    }

    private bool IsDefaultBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return false;
        return branchName == Project.DefaultBranch;
    }

    private static string TruncateMessage(string? message, int maxLength = 60)
    {
        if (string.IsNullOrEmpty(message)) return "";
        return message.Length <= maxLength ? message : message[..(maxLength - 3)] + "...";
    }

    private static string GetSessionStatusBadgeClass(ClaudeSessionStatus status) => status switch
    {
        ClaudeSessionStatus.Running => "bg-success",
        ClaudeSessionStatus.WaitingForInput => "bg-info",
        ClaudeSessionStatus.Starting => "bg-warning text-dark",
        ClaudeSessionStatus.Stopped => "bg-secondary",
        ClaudeSessionStatus.Error => "bg-danger",
        _ => "bg-secondary"
    };
}
