@using Homespun.Features.ClaudeCode.Data
@using Homespun.Features.ClaudeCode.Services
@using Homespun.Features.Git
@using Homespun.Features.GitHub
@using Homespun.Features.Projects
@using Homespun.Features.PullRequests
@using Homespun.Features.PullRequests.Data
@using Homespun.Features.PullRequests.Data.Entities

@inject IGitWorktreeService GitWorktreeService
@inject IClaudeSessionStore SessionStore
@inject IClaudeSessionService SessionService
@inject IAgentStartupTracker StartupTracker
@inject IGitHubService GitHubService
@inject IRebaseAgentService RebaseAgentService
@inject PullRequestDataService PullRequestDataService
@inject PullRequestWorkflowService PullRequestWorkflowService
@inject NavigationManager NavigationManager
@inject ILogger<WorktreeManagementPanel> Logger

<div class="worktree-management-panel">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h4 class="mb-0">Worktrees &amp; Branches</h4>
        <div class="btn-group">
            <button class="btn btn-outline-secondary btn-sm" @onclick="RefreshDataAsync" disabled="@_isLoading">
                @if (_isLoading)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="FetchAllAsync" disabled="@_isFetching">
                @if (_isFetching)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-cloud-download"></i> Fetch
            </button>
            <button class="btn btn-outline-secondary btn-sm" @onclick="PruneWorktreesAsync" disabled="@_isPruning" title="Clean up stale worktree references">
                @if (_isPruning)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                }
                <i class="bi bi-trash"></i> Prune
            </button>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            @_errorMessage
            <button type="button" class="btn-close" @onclick="() => _errorMessage = null"></button>
        </div>
    }

    @if (!string.IsNullOrEmpty(_successMessage))
    {
        <div class="alert alert-success alert-dismissible fade show" role="alert">
            @_successMessage
            <button type="button" class="btn-close" @onclick="() => _successMessage = null"></button>
        </div>
    }

    @* Active Worktrees Section *@
    <div class="section-header d-flex justify-content-between align-items-center">
        <span>Active Worktrees</span>
        <span class="badge bg-secondary">@_worktrees.Count(w => !w.IsBare)</span>
    </div>
    @if (_worktrees.Count(w => !w.IsBare) == 0)
    {
        <div class="text-muted p-3">No active worktrees</div>
    }
    else
    {
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th>Path</th>
                    <th>Status</th>
                    <th>Last Commit</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var worktree in _worktrees.Where(w => !w.IsBare))
                {
                    var branchName = GetShortBranchName(worktree.Branch);
                    var branchInfo = _branches.FirstOrDefault(b => b.ShortName == branchName);
                    var session = GetSessionForWorktree(worktree);
                    var prInfo = GetPullRequestForBranch(branchName);
                    var status = GetWorktreeStatus(worktree.Path);
                    var deleteKey = $"worktree:{branchName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@branchName</strong>
                            <span class="badges">
                                @if (IsDefaultBranch(branchName))
                                {
                                    <span class="badge bg-primary">default</span>
                                }
                                @if (branchInfo?.IsMerged == true)
                                {
                                    <span class="badge bg-success">merged</span>
                                }
                                @if (prInfo != null)
                                {
                                    <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                       target="_blank"
                                       class="badge bg-info text-decoration-none">
                                        PR #@prInfo.GitHubPRNumber
                                    </a>
                                }
                                @if (!worktree.IsOnCorrectBranch)
                                {
                                    <span class="badge bg-danger" title="Expected branch: @worktree.ExpectedBranch">
                                        Wrong Branch
                                    </span>
                                }
                                @if (status != null && status.HasChanges)
                                {
                                    @if (status.ModifiedCount > 0)
                                    {
                                        <span class="badge bg-warning text-dark" title="Modified files">M: @status.ModifiedCount</span>
                                    }
                                    @if (status.StagedCount > 0)
                                    {
                                        <span class="badge bg-success" title="Staged files">S: @status.StagedCount</span>
                                    }
                                    @if (status.UntrackedCount > 0)
                                    {
                                        <span class="badge bg-secondary" title="Untracked files">U: @status.UntrackedCount</span>
                                    }
                                }
                            </span>
                        </td>
                        <td><code class="worktree-path">@worktree.Path</code></td>
                        <td class="status-col">
                            @if (session != null)
                            {
                                <span class="badge @GetSessionStatusBadgeClass(session.Status)">
                                    @session.Status
                                </span>
                            }
                            @if (StartupTracker.IsStarting(GetWorktreeEntityId(worktree)))
                            {
                                <span class="badge bg-warning text-dark">
                                    <span class="spinner-border spinner-border-sm me-1" role="status" style="width: 0.6rem; height: 0.6rem;"></span>
                                    Starting...
                                </span>
                            }
                            @if (branchInfo != null && (branchInfo.AheadCount > 0 || branchInfo.BehindCount > 0))
                            {
                                <span class="sync-info">
                                    @if (branchInfo.AheadCount > 0)
                                    {
                                        <span class="text-success">+@branchInfo.AheadCount</span>
                                    }
                                    @if (branchInfo.BehindCount > 0)
                                    {
                                        <span class="text-danger">-@branchInfo.BehindCount</span>
                                    }
                                </span>
                            }
                        </td>
                        <td class="commit-col">
                            @if (!string.IsNullOrEmpty(branchInfo?.LastCommitMessage))
                            {
                                <span class="commit-message" title="@branchInfo.LastCommitMessage">@TruncateMessage(branchInfo.LastCommitMessage)</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                @if (IsDefaultBranch(branchName))
                                {
                                    @if (session != null)
                                    {
                                        <a href="/session/@session.Id" class="btn btn-sm btn-primary me-1" title="Open chat">
                                            Chat
                                        </a>
                                        <button class="btn btn-sm btn-outline-danger me-1"
                                                @onclick="() => StopSessionAsync(session)"
                                                disabled="@_operationInProgress"
                                                title="Stop session">
                                            Stop
                                        </button>
                                    }
                                    else if (!StartupTracker.IsStarting(GetWorktreeEntityId(worktree)))
                                    {
                                        <button class="btn btn-sm btn-success"
                                                @onclick="() => StartMainBranchSessionAsync(worktree)"
                                                disabled="@_operationInProgress"
                                                title="Start a new agent session on the main branch">
                                            <i class="bi bi-robot me-1"></i>Run Agent
                                        </button>
                                    }
                                }
                                else
                                {
                                    @if (!worktree.IsOnCorrectBranch)
                                    {
                                        <button class="btn btn-sm btn-warning me-1"
                                                @onclick="() => FixBranchAsync(worktree)"
                                                disabled="@_operationInProgress"
                                                title="Checkout the correct branch: @worktree.ExpectedBranch">
                                            Fix Branch
                                        </button>
                                    }

                                    <AgentControlPanel
                                        EntityId="@GetWorktreeEntityId(worktree)"
                                        WorktreePath="@worktree.Path"
                                        ProjectId="@Project.Id"
                                        Model="@(Project.DefaultModel ?? "sonnet")"
                                        SystemPrompt="@($"You are working on branch: {branchName}")"
                                        Compact="true"
                                        Disabled="@_operationInProgress" />

                                    @if (branchInfo?.BehindCount > 0)
                                    {
                                        <button class="btn btn-sm btn-outline-secondary me-1"
                                                @onclick="() => PullLatestAsync(worktree)"
                                                disabled="@_operationInProgress"
                                                title="Pull latest changes">
                                            Pull
                                        </button>
                                        <button class="btn btn-sm btn-outline-warning me-1"
                                                @onclick="() => StartRebaseAgentAsync(worktree)"
                                                disabled="@(_operationInProgress || session != null || StartupTracker.IsStarting(GetWorktreeEntityId(worktree)))"
                                                title="Start rebase agent to rebase onto @Project.DefaultBranch">
                                            <i class="bi bi-arrow-repeat"></i> Rebase
                                        </button>
                                    }

                                    <button class="btn btn-sm btn-outline-danger"
                                            @onclick="() => ShowDeleteWorktreeConfirmation(worktree, branchInfo)"
                                            disabled="@_operationInProgress"
                                            title="Delete worktree">
                                        Delete
                                    </button>
                                }
                            }
                            else
                            {
                                @* Inline delete confirmation *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-options">
                                        @if (_deleteIncludesWorktree)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteWorktreeOnly">
                                                <span class="form-check-label">Keep branch</span>
                                            </label>
                                        }
                                        @if (_hasRemoteBranch && !_deleteWorktreeOnly)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteRemoteBranch">
                                                <span class="form-check-label">Delete remote</span>
                                            </label>
                                        }
                                    </div>
                                    <div class="inline-confirm-actions">
                                        @if (!_deleteTargetIsMerged)
                                        {
                                            <span class="badge bg-warning text-dark me-1" title="This branch has not been merged">unmerged</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Lost Worktrees Section *@
    @if (_lostWorktrees.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center bg-warning bg-opacity-25">
            <span><i class="bi bi-exclamation-triangle me-1"></i> Lost Worktrees</span>
            <span class="badge bg-warning text-dark">@_lostWorktrees.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Folder</th>
                    <th>Path</th>
                    <th>Status</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var lost in _lostWorktrees)
                {
                    var deleteKey = $"lost:{lost.FolderName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@lost.FolderName</strong>
                            <span class="badges">
                                <span class="badge bg-warning text-dark">Lost</span>
                                @if (lost.CanRepair)
                                {
                                    <span class="badge bg-info" title="Can be repaired to branch: @lost.MatchingBranchName">
                                        <i class="bi bi-arrow-right"></i> @lost.MatchingBranchName
                                    </span>
                                }
                                @if (lost.Status != null && lost.Status.HasChanges)
                                {
                                    @if (lost.Status.ModifiedCount > 0)
                                    {
                                        <span class="badge bg-danger" title="Modified files - may lose work!">M: @lost.Status.ModifiedCount</span>
                                    }
                                    @if (lost.Status.StagedCount > 0)
                                    {
                                        <span class="badge bg-success" title="Staged files">S: @lost.Status.StagedCount</span>
                                    }
                                    @if (lost.Status.UntrackedCount > 0)
                                    {
                                        <span class="badge bg-secondary" title="Untracked files">U: @lost.Status.UntrackedCount</span>
                                    }
                                }
                            </span>
                        </td>
                        <td><code class="worktree-path">@lost.Path</code></td>
                        <td class="status-col">
                            @if (lost.Status != null && lost.Status.HasChanges)
                            {
                                <span class="badge bg-danger">Has changes</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                @if (lost.CanRepair)
                                {
                                    <button class="btn btn-sm btn-outline-success me-1"
                                            @onclick="() => RepairLostWorktreeAsync(lost)"
                                            disabled="@_operationInProgress"
                                            title="Reattach to branch @lost.MatchingBranchName">
                                        Repair
                                    </button>
                                }
                                <button class="btn btn-sm btn-outline-danger"
                                        @onclick="() => ShowDeleteLostWorktreeConfirmation(lost)"
                                        disabled="@_operationInProgress"
                                        title="Delete folder permanently">
                                    Delete
                                </button>
                            }
                            else
                            {
                                @* Inline delete confirmation for lost worktrees *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-actions">
                                        @if (_deleteLostWorktreeHasChanges)
                                        {
                                            <span class="badge bg-danger me-1" title="Has uncommitted changes">has changes</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Local Branches Without Worktrees *@
    @{
        var branchesWithoutWorktrees = _branches.Where(b => !b.HasWorktree && !IsDefaultBranch(b.ShortName)).ToList();
    }
    @if (branchesWithoutWorktrees.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center">
            <span>Local Branches (No Worktree)</span>
            <span class="badge bg-secondary">@branchesWithoutWorktrees.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th>Last Commit</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var branch in branchesWithoutWorktrees)
                {
                    var prInfo = GetPullRequestForBranch(branch.ShortName);
                    var deleteKey = $"branch:{branch.ShortName}";

                    <tr class="@(IsDeleteTarget(deleteKey) ? "table-danger" : "")">
                        <td>
                            <strong class="branch-name">@branch.ShortName</strong>
                            <span class="badges">
                                @if (branch.IsMerged)
                                {
                                    <span class="badge bg-success">merged</span>
                                }
                                @if (prInfo != null)
                                {
                                    <a href="https://github.com/@Project.GitHubOwner/@Project.GitHubRepo/pull/@prInfo.GitHubPRNumber"
                                       target="_blank"
                                       class="badge bg-info text-decoration-none">
                                        PR #@prInfo.GitHubPRNumber
                                    </a>
                                }
                            </span>
                        </td>
                        <td class="commit-col">
                            @if (!string.IsNullOrEmpty(branch.LastCommitMessage))
                            {
                                <span class="commit-message" title="@branch.LastCommitMessage">@TruncateMessage(branch.LastCommitMessage)</span>
                            }
                        </td>
                        <td class="actions-col">
                            @if (!IsDeleteTarget(deleteKey))
                            {
                                <button class="btn btn-sm btn-outline-primary me-1"
                                        @onclick="() => CreateWorktreeForBranchAsync(branch.ShortName)"
                                        disabled="@_operationInProgress"
                                        title="Create worktree for this branch">
                                    Start
                                </button>
                                <button class="btn btn-sm btn-outline-danger"
                                        @onclick="() => ShowDeleteBranchConfirmation(branch)"
                                        disabled="@_operationInProgress"
                                        title="Delete branch">
                                    Delete
                                </button>
                            }
                            else
                            {
                                @* Inline delete confirmation *@
                                <div class="inline-confirm">
                                    <div class="inline-confirm-options">
                                        @if (_hasRemoteBranch)
                                        {
                                            <label class="form-check form-check-inline">
                                                <input class="form-check-input" type="checkbox" @bind="_deleteRemoteBranch">
                                                <span class="form-check-label">Delete remote</span>
                                            </label>
                                        }
                                    </div>
                                    <div class="inline-confirm-actions">
                                        @if (!_deleteTargetIsMerged)
                                        {
                                            <span class="badge bg-warning text-dark me-1" title="This branch has not been merged">unmerged</span>
                                        }
                                        <button class="btn btn-sm btn-danger me-1"
                                                @onclick="ExecuteDeleteAsync"
                                                disabled="@_operationInProgress">
                                            @if (_operationInProgress)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                            }
                                            Confirm
                                        </button>
                                        <button class="btn btn-sm btn-outline-secondary"
                                                @onclick="HideDeleteConfirmation">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }

    @* Remote Branches Section *@
    @if (_remoteBranches.Any())
    {
        <div class="section-header d-flex justify-content-between align-items-center">
            <span>Remote Branches (Not Local)</span>
            <span class="badge bg-secondary">@_remoteBranches.Count</span>
        </div>
        <table class="table table-sm wt-table">
            <thead>
                <tr>
                    <th>Branch</th>
                    <th class="actions-col">Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var remoteBranch in _remoteBranches)
                {
                    <tr>
                        <td><strong class="branch-name">origin/@remoteBranch</strong></td>
                        <td class="actions-col">
                            <button class="btn btn-sm btn-outline-primary me-1"
                                    @onclick="() => CreateWorktreeFromRemoteAsync(remoteBranch)"
                                    disabled="@_operationInProgress"
                                    title="Create local worktree from remote branch">
                                Checkout
                            </button>
                            <button class="btn btn-sm btn-outline-danger"
                                    @onclick="() => DeleteRemoteBranchAsync(remoteBranch)"
                                    disabled="@_operationInProgress"
                                    title="Delete remote branch">
                                Delete
                            </button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
</div>

<style>
    .worktree-management-panel {
        font-size: 0.875rem;
    }

    .section-header {
        padding: 0.5rem 0.75rem;
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color, #dee2e6);
        border-bottom: none;
        border-radius: var(--border-radius, 0.375rem) var(--border-radius, 0.375rem) 0 0;
        font-weight: 600;
        margin-top: 1rem;
    }

    .section-header:first-of-type {
        margin-top: 0;
    }

    .wt-table {
        margin-bottom: 1rem;
        border: 1px solid var(--border-color, #dee2e6);
        border-top: none;
        border-radius: 0 0 var(--border-radius, 0.375rem) var(--border-radius, 0.375rem);
        overflow: hidden;
    }

    .wt-table thead th {
        user-select: none;
        -webkit-user-select: none;
        font-weight: 600;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.02em;
        background-color: var(--bg-secondary);
        color: var(--text-secondary);
        border-bottom-width: 1px;
    }

    .branch-name {
        font-family: var(--font-family-mono, monospace);
        font-size: 0.85rem;
    }

    .badges {
        margin-left: 0.5rem;
    }

    .badges .badge {
        font-size: 0.7rem;
        margin-right: 0.25rem;
    }

    .worktree-path {
        font-size: 0.75rem;
        word-break: break-all;
    }

    .commit-col {
        max-width: 300px;
    }

    .commit-message {
        font-style: italic;
        color: var(--text-muted, #6c757d);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
        max-width: 100%;
    }

    .status-col {
        white-space: nowrap;
    }

    .sync-info {
        font-size: 0.8rem;
        margin-left: 0.25rem;
    }

    .actions-col {
        white-space: nowrap;
        text-align: right;
    }

    .wt-table tbody tr:hover {
        background-color: var(--bg-hover, #f8f9fa);
    }

    .wt-table tbody tr.table-danger:hover {
        background-color: var(--bs-table-danger-bg, #f8d7da);
    }

    .inline-confirm {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: flex-end;
    }

    .inline-confirm-options {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .inline-confirm-options .form-check {
        margin-bottom: 0;
        font-size: 0.8rem;
    }

    .inline-confirm-actions {
        display: flex;
        align-items: center;
    }
</style>

@code {
    [Parameter] public required Project Project { get; set; }
    [Parameter] public EventCallback OnDataChanged { get; set; }

    private List<WorktreeInfo> _worktrees = [];
    private List<BranchInfo> _branches = [];
    private List<string> _remoteBranches = [];
    private List<PullRequest> _pullRequests = [];
    private List<LostWorktreeInfo> _lostWorktrees = [];
    private Dictionary<string, WorktreeStatus> _worktreeStatuses = new();
    private bool _isLoading;
    private bool _isFetching;
    private bool _isPruning;
    private bool _operationInProgress;
    private string? _errorMessage;
    private string? _successMessage;

    // Delete confirmation state
    private string? _deleteTargetKey;
    private string _deleteTargetName = "";
    private bool _deleteTargetIsMerged;
    private bool _deleteIncludesWorktree;
    private bool _deleteWorktreeOnly;
    private bool _deleteRemoteBranch;
    private bool _hasRemoteBranch;
    private bool _deleteLostWorktreeHasChanges;
    private WorktreeInfo? _deleteTargetWorktree;
    private BranchInfo? _deleteTargetBranch;
    private LostWorktreeInfo? _deleteTargetLostWorktree;

    private bool IsDeleteTarget(string key) => _deleteTargetKey == key;

    protected override async Task OnInitializedAsync()
    {
        await RefreshDataAsync();
    }

    private async Task RefreshDataAsync()
    {
        _isLoading = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Load worktrees
            _worktrees = await GitWorktreeService.ListWorktreesAsync(Project.LocalPath);

            // Load local branches with their info
            _branches = await GitWorktreeService.ListLocalBranchesAsync(Project.LocalPath);

            // Check merge status for each branch
            foreach (var branch in _branches.Where(b => !IsDefaultBranch(b.ShortName)))
            {
                branch.IsMerged = await GitWorktreeService.IsBranchMergedAsync(
                    Project.LocalPath,
                    branch.ShortName,
                    Project.DefaultBranch);
            }

            // Load remote-only branches
            _remoteBranches = await GitWorktreeService.ListRemoteOnlyBranchesAsync(Project.LocalPath);

            // Load pull requests for this project
            _pullRequests = await PullRequestDataService.GetByProjectIdAsync(Project.Id);

            // Load lost worktrees
            _lostWorktrees = await GitWorktreeService.FindLostWorktreeFoldersAsync(Project.LocalPath);

            // Load git status for all worktrees (in parallel for performance)
            _worktreeStatuses.Clear();
            var statusTasks = _worktrees.Where(w => !w.IsBare).Select(async w =>
            {
                try
                {
                    var status = await GitWorktreeService.GetWorktreeStatusAsync(w.Path);
                    return (w.Path, status);
                }
                catch
                {
                    return (w.Path, new WorktreeStatus());
                }
            });

            var statuses = await Task.WhenAll(statusTasks);
            foreach (var (path, status) in statuses)
            {
                _worktreeStatuses[path] = status;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load worktree data for project {ProjectId}", Project.Id);
            _errorMessage = $"Failed to load data: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task FetchAllAsync()
    {
        _isFetching = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.FetchAllAsync(Project.LocalPath);
            if (success)
            {
                _successMessage = "Fetched latest changes from remote";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = "Failed to fetch from remote";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fetch: {ex.Message}";
        }
        finally
        {
            _isFetching = false;
            StateHasChanged();
        }
    }

    private async Task PruneWorktreesAsync()
    {
        _isPruning = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            await GitWorktreeService.PruneWorktreesAsync(Project.LocalPath);
            _successMessage = "Pruned stale worktree references";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to prune: {ex.Message}";
        }
        finally
        {
            _isPruning = false;
            StateHasChanged();
        }
    }

    private WorktreeStatus? GetWorktreeStatus(string worktreePath)
    {
        return _worktreeStatuses.GetValueOrDefault(worktreePath);
    }

    private async Task FixBranchAsync(WorktreeInfo worktree)
    {
        if (string.IsNullOrEmpty(worktree.ExpectedBranch))
        {
            _errorMessage = "No expected branch to fix";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.CheckoutBranchAsync(worktree.Path, worktree.ExpectedBranch);
            if (success)
            {
                _successMessage = $"Checked out branch {worktree.ExpectedBranch}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to checkout branch {worktree.ExpectedBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to fix branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task PullLatestAsync(WorktreeInfo worktree)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.PullLatestAsync(worktree.Path);
            if (success)
            {
                _successMessage = $"Pulled latest changes for {GetShortBranchName(worktree.Branch)}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = "Failed to pull latest changes";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to pull: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateWorktreeForBranchAsync(string branchName)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var worktreePath = await GitWorktreeService.CreateWorktreeAsync(
                Project.LocalPath,
                branchName,
                createBranch: false);

            if (!string.IsNullOrEmpty(worktreePath))
            {
                _successMessage = $"Created worktree for {branchName}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create worktree for {branchName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to create worktree: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task CreateWorktreeFromRemoteAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            // Use the dedicated method that creates the worktree without checking out in main
            var worktreePath = await GitWorktreeService.CreateWorktreeFromRemoteBranchAsync(
                Project.LocalPath,
                remoteBranch);

            if (!string.IsNullOrEmpty(worktreePath))
            {
                _successMessage = $"Created worktree for {remoteBranch}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to create worktree for {remoteBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to checkout remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task DeleteRemoteBranchAsync(string remoteBranch)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.DeleteRemoteBranchAsync(Project.LocalPath, remoteBranch);
            if (success)
            {
                _successMessage = $"Deleted remote branch origin/{remoteBranch}";
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to delete remote branch {remoteBranch}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete remote branch: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task RepairLostWorktreeAsync(LostWorktreeInfo lost)
    {
        if (!lost.CanRepair || string.IsNullOrEmpty(lost.MatchingBranchName))
        {
            _errorMessage = "Cannot repair: no matching branch found";
            return;
        }

        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.RepairWorktreeAsync(
                Project.LocalPath,
                lost.Path,
                lost.MatchingBranchName);

            if (success)
            {
                _successMessage = $"Repaired worktree for branch {lost.MatchingBranchName}";
                await RefreshDataAsync();
                await OnDataChanged.InvokeAsync();
            }
            else
            {
                _errorMessage = $"Failed to repair worktree for {lost.FolderName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to repair worktree: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private void ShowDeleteLostWorktreeConfirmation(LostWorktreeInfo lost)
    {
        _deleteTargetKey = $"lost:{lost.FolderName}";
        _deleteTargetName = lost.FolderName;
        _deleteTargetIsMerged = false;
        _deleteIncludesWorktree = false;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = false;
        _deleteLostWorktreeHasChanges = lost.Status?.HasChanges ?? false;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = null;
        _deleteTargetLostWorktree = lost;
    }

    private async Task DeleteLostWorktreeAsync(LostWorktreeInfo lost)
    {
        _operationInProgress = true;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            var success = await GitWorktreeService.DeleteWorktreeFolderAsync(lost.Path);
            if (success)
            {
                _successMessage = $"Deleted folder {lost.FolderName}";
                HideDeleteConfirmation();
                await RefreshDataAsync();
            }
            else
            {
                _errorMessage = $"Failed to delete folder {lost.FolderName}";
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to delete folder: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartSessionAsync(WorktreeInfo worktree, SessionMode mode)
    {
        var entityId = GetWorktreeEntityId(worktree);
        var branchName = GetShortBranchName(worktree.Branch);

        StartupTracker.MarkAsStarting(entityId);
        StateHasChanged();

        try
        {
            var session = await SessionService.StartSessionAsync(
                entityId,
                Project.Id,
                worktree.Path,
                mode,
                Project.DefaultModel ?? "sonnet",
                systemPrompt: $"You are working on branch: {branchName}");

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start session for worktree {WorktreePath}", worktree.Path);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start session: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task StartMainBranchSessionAsync(WorktreeInfo worktree)
    {
        var entityId = GetWorktreeEntityId(worktree);

        StartupTracker.MarkAsStarting(entityId);
        StateHasChanged();

        try
        {
            // Start a new blank session on the main branch without a system prompt
            var session = await SessionService.StartSessionAsync(
                entityId,
                Project.Id,
                worktree.Path,
                SessionMode.Build,
                Project.DefaultModel ?? "sonnet",
                systemPrompt: null);

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start main branch session for worktree {WorktreePath}", worktree.Path);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start session: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task StopSessionAsync(ClaudeSession session)
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            await SessionService.StopSessionAsync(session.Id);
            _successMessage = "Session stopped";
            await RefreshDataAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to stop session: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task StartRebaseAgentAsync(WorktreeInfo worktree)
    {
        var branchName = GetShortBranchName(worktree.Branch);
        var entityId = $"rebase-{branchName}";

        StartupTracker.MarkAsStarting(entityId);
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Get recently merged PRs for context
            var recentMergedPRs = await PullRequestWorkflowService.GetMergedPullRequestsWithTimeAsync(Project.Id);
            var recentPRInfos = recentMergedPRs
                .Take(10)
                .Select(pr => pr.PullRequest)
                .ToList();

            var session = await RebaseAgentService.StartRebaseAgentAsync(
                Project.Id,
                worktree.Path,
                branchName,
                Project.DefaultBranch,
                Project.DefaultModel ?? "sonnet",
                recentPRInfos);

            StartupTracker.MarkAsStarted(entityId);

            // Navigate to the session
            NavigationManager.NavigateTo($"/session/{session.Id}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to start rebase agent for worktree {WorktreePath}", worktree.Path);
            StartupTracker.MarkAsFailed(entityId, ex.Message);
            _errorMessage = $"Failed to start rebase agent: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private void ShowDeleteWorktreeConfirmation(WorktreeInfo worktree, BranchInfo? branchInfo)
    {
        var branchName = GetShortBranchName(worktree.Branch);
        _deleteTargetKey = $"worktree:{branchName}";
        _deleteTargetName = branchName;
        _deleteTargetIsMerged = branchInfo?.IsMerged ?? false;
        _deleteIncludesWorktree = true;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branchInfo?.Upstream != null;
        _deleteTargetWorktree = worktree;
        _deleteTargetBranch = branchInfo;
    }

    private void ShowDeleteBranchConfirmation(BranchInfo branch)
    {
        _deleteTargetKey = $"branch:{branch.ShortName}";
        _deleteTargetName = branch.ShortName;
        _deleteTargetIsMerged = branch.IsMerged;
        _deleteIncludesWorktree = false;
        _deleteWorktreeOnly = false;
        _deleteRemoteBranch = false;
        _hasRemoteBranch = branch.Upstream != null;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = branch;
    }

    private void HideDeleteConfirmation()
    {
        _deleteTargetKey = null;
        _deleteTargetWorktree = null;
        _deleteTargetBranch = null;
        _deleteTargetLostWorktree = null;
        _deleteLostWorktreeHasChanges = false;
    }

    private async Task ExecuteDeleteAsync()
    {
        _operationInProgress = true;
        StateHasChanged();

        try
        {
            // Handle lost worktree deletion
            if (_deleteTargetLostWorktree != null)
            {
                await DeleteLostWorktreeAsync(_deleteTargetLostWorktree);
                return;
            }

            var branchName = _deleteTargetBranch?.ShortName ?? GetShortBranchName(_deleteTargetWorktree?.Branch);

            // Stop any active session first
            if (_deleteTargetWorktree != null)
            {
                var session = GetSessionForWorktree(_deleteTargetWorktree);
                if (session != null)
                {
                    await SessionService.StopSessionAsync(session.Id);
                }

                // Remove the worktree
                var worktreeRemoved = await GitWorktreeService.RemoveWorktreeAsync(
                    Project.LocalPath,
                    _deleteTargetWorktree.Path);

                if (!worktreeRemoved)
                {
                    _errorMessage = "Failed to remove worktree";
                    return;
                }
            }

            // Delete the branch if not worktree-only
            if (!_deleteWorktreeOnly && !string.IsNullOrEmpty(branchName))
            {
                var forceDelete = !_deleteTargetIsMerged;
                var branchDeleted = await GitWorktreeService.DeleteLocalBranchAsync(
                    Project.LocalPath,
                    branchName,
                    force: forceDelete);

                if (!branchDeleted)
                {
                    _errorMessage = $"Failed to delete local branch {branchName}";
                    return;
                }

                // Delete remote branch if requested
                if (_deleteRemoteBranch)
                {
                    var remoteDeleted = await GitWorktreeService.DeleteRemoteBranchAsync(
                        Project.LocalPath,
                        branchName);

                    if (!remoteDeleted)
                    {
                        _errorMessage = $"Failed to delete remote branch {branchName}";
                        return;
                    }
                }
            }

            _successMessage = _deleteWorktreeOnly
                ? $"Removed worktree for {branchName}"
                : $"Deleted {branchName}" + (_deleteRemoteBranch ? " (local and remote)" : " (local)");

            HideDeleteConfirmation();
            await RefreshDataAsync();
            await OnDataChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Delete failed: {ex.Message}";
        }
        finally
        {
            _operationInProgress = false;
            StateHasChanged();
        }
    }

    private ClaudeSession? GetSessionForWorktree(WorktreeInfo worktree)
    {
        var entityId = GetWorktreeEntityId(worktree);
        return SessionStore.GetByEntityId(entityId);
    }

    private string GetWorktreeEntityId(WorktreeInfo worktree)
    {
        // Use the branch name as the entity ID for session tracking
        var branchName = GetShortBranchName(worktree.Branch);
        return $"worktree:{branchName}";
    }

    private PullRequest? GetPullRequestForBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return null;
        return _pullRequests.FirstOrDefault(pr => pr.BranchName == branchName);
    }

    private static string GetShortBranchName(string? branch)
    {
        if (string.IsNullOrEmpty(branch)) return "unknown";
        return branch.Replace("refs/heads/", "");
    }

    private bool IsDefaultBranch(string? branchName)
    {
        if (string.IsNullOrEmpty(branchName)) return false;
        return branchName == Project.DefaultBranch;
    }

    private static string TruncateMessage(string? message, int maxLength = 60)
    {
        if (string.IsNullOrEmpty(message)) return "";
        return message.Length <= maxLength ? message : message[..(maxLength - 3)] + "...";
    }

    private static string GetSessionStatusBadgeClass(ClaudeSessionStatus status) => status switch
    {
        ClaudeSessionStatus.Running => "bg-success",
        ClaudeSessionStatus.WaitingForInput => "bg-info",
        ClaudeSessionStatus.Starting => "bg-warning text-dark",
        ClaudeSessionStatus.Stopped => "bg-secondary",
        ClaudeSessionStatus.Error => "bg-danger",
        _ => "bg-secondary"
    };
}
